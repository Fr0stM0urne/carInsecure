/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/inc/hw_adc.hADC_CC_CLKDIV_S4ADC_CC_CS_MOSC0x00000002ADC_CC_CS_PIOSC0x00000001ADC_CC_CS_SYSPLL0x00000000ADC_CC_CS_M0x0000000FADC_CC_CLKDIV_M0x000003F0ADC_PC_MCR_FULL0x00000007ADC_PC_MCR_1_20x00000005ADC_PC_MCR_1_40x00000003ADC_PC_MCR_1_8ADC_PC_MCR_MADC_PC_SR_1MADC_PC_SR_500KADC_PC_SR_250KADC_PC_SR_125KADC_PC_SR_MADC_PP_CH_SADC_PP_DC_S10ADC_PP_RSL_S18ADC_PP_MSR_1MADC_PP_MSR_500KADC_PP_MSR_250KADC_PP_MSR_125KADC_PP_MSR_MADC_PP_MCR_FULLADC_PP_MCR_MADC_PP_CH_MADC_PP_DC_M0x0000FC00ADC_PP_TYPE_SARADC_PP_TYPE_M0x00030000ADC_PP_RSL_M0x007C0000ADC_PP_TS0x00800000ADC_PP_APSHT0x01000000ADC_DCCMP7_COMP0_S0ADC_DCCMP7_COMP1_S16ADC_DCCMP7_COMP0_M0x00000FFFADC_DCCMP7_COMP1_M0x0FFF0000ADC_DCCMP6_COMP0_SADC_DCCMP6_COMP1_SADC_DCCMP6_COMP0_MADC_DCCMP6_COMP1_MADC_DCCMP5_COMP0_SADC_DCCMP5_COMP1_SADC_DCCMP5_COMP0_MADC_DCCMP5_COMP1_MADC_DCCMP4_COMP0_SADC_DCCMP4_COMP1_SADC_DCCMP4_COMP0_MADC_DCCMP4_COMP1_MADC_DCCMP3_COMP0_SADC_DCCMP3_COMP1_SADC_DCCMP3_COMP0_MADC_DCCMP3_COMP1_MADC_DCCMP2_COMP0_SADC_DCCMP2_COMP1_SADC_DCCMP2_COMP0_MADC_DCCMP2_COMP1_MADC_DCCMP1_COMP0_SADC_DCCMP1_COMP1_SADC_DCCMP1_COMP0_MADC_DCCMP1_COMP1_MADC_DCCMP0_COMP0_SADC_DCCMP0_COMP1_SADC_DCCMP0_COMP0_MADC_DCCMP0_COMP1_MADC_DCCTL7_CIM_HONCEADC_DCCTL7_CIM_HALWAYSADC_DCCTL7_CIM_ONCEADC_DCCTL7_CIM_ALWAYSADC_DCCTL7_CIM_MADC_DCCTL7_CIC_HIGH0x0000000CADC_DCCTL7_CIC_MID0x00000004ADC_DCCTL7_CIC_LOWADC_DCCTL7_CIC_MADC_DCCTL7_CIE0x00000010ADC_DCCTL7_CTM_HONCE0x00000300ADC_DCCTL7_CTM_HALWAYS0x00000200ADC_DCCTL7_CTM_ONCE0x00000100ADC_DCCTL7_CTM_ALWAYSADC_DCCTL7_CTM_MADC_DCCTL7_CTC_HIGH0x00000C00ADC_DCCTL7_CTC_MID0x00000400ADC_DCCTL7_CTC_LOWADC_DCCTL7_CTC_MADC_DCCTL7_CTE0x00001000ADC_DCCTL6_CIM_HONCEADC_DCCTL6_CIM_HALWAYSADC_DCCTL6_CIM_ONCEADC_DCCTL6_CIM_ALWAYSADC_DCCTL6_CIM_MADC_DCCTL6_CIC_HIGHADC_DCCTL6_CIC_MIDADC_DCCTL6_CIC_LOWADC_DCCTL6_CIC_MADC_DCCTL6_CIEADC_DCCTL6_CTM_HONCEADC_DCCTL6_CTM_HALWAYSADC_DCCTL6_CTM_ONCEADC_DCCTL6_CTM_ALWAYSADC_DCCTL6_CTM_MADC_DCCTL6_CTC_HIGHADC_DCCTL6_CTC_MIDADC_DCCTL6_CTC_LOWADC_DCCTL6_CTC_MADC_DCCTL6_CTEADC_DCCTL5_CIM_HONCEADC_DCCTL5_CIM_HALWAYSADC_DCCTL5_CIM_ONCEADC_DCCTL5_CIM_ALWAYSADC_DCCTL5_CIM_MADC_DCCTL5_CIC_HIGHADC_DCCTL5_CIC_MIDADC_DCCTL5_CIC_LOWADC_DCCTL5_CIC_MADC_DCCTL5_CIEADC_DCCTL5_CTM_HONCEADC_DCCTL5_CTM_HALWAYSADC_DCCTL5_CTM_ONCEADC_DCCTL5_CTM_ALWAYSADC_DCCTL5_CTM_MADC_DCCTL5_CTC_HIGHADC_DCCTL5_CTC_MIDADC_DCCTL5_CTC_LOWADC_DCCTL5_CTC_MADC_DCCTL5_CTEADC_DCCTL4_CIM_HONCEADC_DCCTL4_CIM_HALWAYSADC_DCCTL4_CIM_ONCEADC_DCCTL4_CIM_ALWAYSADC_DCCTL4_CIM_MADC_DCCTL4_CIC_HIGHADC_DCCTL4_CIC_MIDADC_DCCTL4_CIC_LOWADC_DCCTL4_CIC_MADC_DCCTL4_CIEADC_DCCTL4_CTM_HONCEADC_DCCTL4_CTM_HALWAYSADC_DCCTL4_CTM_ONCEADC_DCCTL4_CTM_ALWAYSADC_DCCTL4_CTM_MADC_DCCTL4_CTC_HIGHADC_DCCTL4_CTC_MIDADC_DCCTL4_CTC_LOWADC_DCCTL4_CTC_MADC_DCCTL4_CTEADC_DCCTL3_CIM_HONCEADC_DCCTL3_CIM_HALWAYSADC_DCCTL3_CIM_ONCEADC_DCCTL3_CIM_ALWAYSADC_DCCTL3_CIM_MADC_DCCTL3_CIC_HIGHADC_DCCTL3_CIC_MIDADC_DCCTL3_CIC_LOWADC_DCCTL3_CIC_MADC_DCCTL3_CIEADC_DCCTL3_CTM_HONCEADC_DCCTL3_CTM_HALWAYSADC_DCCTL3_CTM_ONCEADC_DCCTL3_CTM_ALWAYSADC_DCCTL3_CTM_MADC_DCCTL3_CTC_HIGHADC_DCCTL3_CTC_MIDADC_DCCTL3_CTC_LOWADC_DCCTL3_CTC_MADC_DCCTL3_CTEADC_DCCTL2_CIM_HONCEADC_DCCTL2_CIM_HALWAYSADC_DCCTL2_CIM_ONCEADC_DCCTL2_CIM_ALWAYSADC_DCCTL2_CIM_MADC_DCCTL2_CIC_HIGHADC_DCCTL2_CIC_MIDADC_DCCTL2_CIC_LOWADC_DCCTL2_CIC_MADC_DCCTL2_CIEADC_DCCTL2_CTM_HONCEADC_DCCTL2_CTM_HALWAYSADC_DCCTL2_CTM_ONCEADC_DCCTL2_CTM_ALWAYSADC_DCCTL2_CTM_MADC_DCCTL2_CTC_HIGHADC_DCCTL2_CTC_MIDADC_DCCTL2_CTC_LOWADC_DCCTL2_CTC_MADC_DCCTL2_CTEADC_DCCTL1_CIM_HONCEADC_DCCTL1_CIM_HALWAYSADC_DCCTL1_CIM_ONCEADC_DCCTL1_CIM_ALWAYSADC_DCCTL1_CIM_MADC_DCCTL1_CIC_HIGHADC_DCCTL1_CIC_MIDADC_DCCTL1_CIC_LOWADC_DCCTL1_CIC_MADC_DCCTL1_CIEADC_DCCTL1_CTM_HONCEADC_DCCTL1_CTM_HALWAYSADC_DCCTL1_CTM_ONCEADC_DCCTL1_CTM_ALWAYSADC_DCCTL1_CTM_MADC_DCCTL1_CTC_HIGHADC_DCCTL1_CTC_MIDADC_DCCTL1_CTC_LOWADC_DCCTL1_CTC_MADC_DCCTL1_CTEADC_DCCTL0_CIM_HONCEADC_DCCTL0_CIM_HALWAYSADC_DCCTL0_CIM_ONCEADC_DCCTL0_CIM_ALWAYSADC_DCCTL0_CIM_MADC_DCCTL0_CIC_HIGHADC_DCCTL0_CIC_MIDADC_DCCTL0_CIC_LOWADC_DCCTL0_CIC_MADC_DCCTL0_CIEADC_DCCTL0_CTM_HONCEADC_DCCTL0_CTM_HALWAYSADC_DCCTL0_CTM_ONCEADC_DCCTL0_CTM_ALWAYSADC_DCCTL0_CTM_MADC_DCCTL0_CTC_HIGHADC_DCCTL0_CTC_MIDADC_DCCTL0_CTC_LOWADC_DCCTL0_CTC_MADC_DCCTL0_CTEADC_DCRIC_DCINT0ADC_DCRIC_DCINT1ADC_DCRIC_DCINT2ADC_DCRIC_DCINT30x00000008ADC_DCRIC_DCINT4ADC_DCRIC_DCINT50x00000020ADC_DCRIC_DCINT60x00000040ADC_DCRIC_DCINT70x00000080ADC_DCRIC_DCTRIG00x00010000ADC_DCRIC_DCTRIG10x00020000ADC_DCRIC_DCTRIG20x00040000ADC_DCRIC_DCTRIG30x00080000ADC_DCRIC_DCTRIG40x00100000ADC_DCRIC_DCTRIG50x00200000ADC_DCRIC_DCTRIG60x00400000ADC_DCRIC_DCTRIG7ADC_SSTSH3_TSH0_SADC_SSTSH3_TSH0_MADC_SSEMUX3_EMUX0ADC_SSDC3_S0DCSEL_MADC_SSOP3_S0DCOPADC_SSFSTAT3_TPTR_SADC_SSFSTAT3_HPTR_SADC_SSFSTAT3_TPTR_MADC_SSFSTAT3_HPTR_M0x000000F0ADC_SSFSTAT3_EMPTYADC_SSFSTAT3_FULLADC_SSFIFO3_DATA_SADC_SSFIFO3_DATA_MADC_SSCTL3_D0ADC_SSCTL3_END0ADC_SSCTL3_IE0ADC_SSCTL3_TS0ADC_SSMUX3_MUX0_SADC_SSMUX3_MUX0_MADC_SSTSH2_TSH0_SADC_SSTSH2_TSH1_SADC_SSTSH2_TSH2_S8ADC_SSTSH2_TSH3_S12ADC_SSTSH2_TSH0_MADC_SSTSH2_TSH1_MADC_SSTSH2_TSH2_M0x00000F00ADC_SSTSH2_TSH3_M0x0000F000ADC_SSEMUX2_EMUX0ADC_SSEMUX2_EMUX1ADC_SSEMUX2_EMUX2ADC_SSEMUX2_EMUX3ADC_SSDC2_S0DCSEL_SADC_SSDC2_S1DCSEL_SADC_SSDC2_S2DCSEL_SADC_SSDC2_S0DCSEL_MADC_SSDC2_S1DCSEL_MADC_SSDC2_S2DCSEL_MADC_SSDC2_S3DCSEL_MADC_SSOP2_S0DCOPADC_SSOP2_S1DCOPADC_SSOP2_S2DCOPADC_SSOP2_S3DCOPADC_SSFSTAT2_TPTR_SADC_SSFSTAT2_HPTR_SADC_SSFSTAT2_TPTR_MADC_SSFSTAT2_HPTR_MADC_SSFSTAT2_EMPTYADC_SSFSTAT2_FULLADC_SSFIFO2_DATA_SADC_SSFIFO2_DATA_MADC_SSCTL2_D0ADC_SSCTL2_END0ADC_SSCTL2_IE0ADC_SSCTL2_TS0ADC_SSCTL2_D1ADC_SSCTL2_END1ADC_SSCTL2_IE1ADC_SSCTL2_TS1ADC_SSCTL2_D2ADC_SSCTL2_END2ADC_SSCTL2_IE2ADC_SSCTL2_TS20x00000800ADC_SSCTL2_D3ADC_SSCTL2_END30x00002000ADC_SSCTL2_IE30x00004000ADC_SSCTL2_TS30x00008000ADC_SSMUX2_MUX0_SADC_SSMUX2_MUX1_SADC_SSMUX2_MUX2_SADC_SSMUX2_MUX3_SADC_SSMUX2_MUX0_MADC_SSMUX2_MUX1_MADC_SSMUX2_MUX2_MADC_SSMUX2_MUX3_MADC_SSTSH1_TSH0_SADC_SSTSH1_TSH1_SADC_SSTSH1_TSH2_SADC_SSTSH1_TSH3_SADC_SSTSH1_TSH0_MADC_SSTSH1_TSH1_MADC_SSTSH1_TSH2_MADC_SSTSH1_TSH3_MADC_SSEMUX1_EMUX0ADC_SSEMUX1_EMUX1ADC_SSEMUX1_EMUX2ADC_SSEMUX1_EMUX3ADC_SSDC1_S0DCSEL_SADC_SSDC1_S1DCSEL_SADC_SSDC1_S2DCSEL_SADC_SSDC1_S0DCSEL_MADC_SSDC1_S1DCSEL_MADC_SSDC1_S2DCSEL_MADC_SSDC1_S3DCSEL_MADC_SSOP1_S0DCOPADC_SSOP1_S1DCOPADC_SSOP1_S2DCOPADC_SSOP1_S3DCOPADC_SSFSTAT1_TPTR_SADC_SSFSTAT1_HPTR_SADC_SSFSTAT1_TPTR_MADC_SSFSTAT1_HPTR_MADC_SSFSTAT1_EMPTYADC_SSFSTAT1_FULLADC_SSFIFO1_DATA_SADC_SSFIFO1_DATA_MADC_SSCTL1_D0ADC_SSCTL1_END0ADC_SSCTL1_IE0ADC_SSCTL1_TS0ADC_SSCTL1_D1ADC_SSCTL1_END1ADC_SSCTL1_IE1ADC_SSCTL1_TS1ADC_SSCTL1_D2ADC_SSCTL1_END2ADC_SSCTL1_IE2ADC_SSCTL1_TS2ADC_SSCTL1_D3ADC_SSCTL1_END3ADC_SSCTL1_IE3ADC_SSCTL1_TS3ADC_SSMUX1_MUX0_SADC_SSMUX1_MUX1_SADC_SSMUX1_MUX2_SADC_SSMUX1_MUX3_SADC_SSMUX1_MUX0_MADC_SSMUX1_MUX1_MADC_SSMUX1_MUX2_MADC_SSMUX1_MUX3_MADC_SSTSH0_TSH0_SADC_SSTSH0_TSH1_SADC_SSTSH0_TSH2_SADC_SSTSH0_TSH3_SADC_SSTSH0_TSH4_SADC_SSTSH0_TSH5_S20ADC_SSTSH0_TSH6_S24ADC_SSTSH0_TSH7_S28ADC_SSTSH0_TSH0_MADC_SSTSH0_TSH1_MADC_SSTSH0_TSH2_MADC_SSTSH0_TSH3_MADC_SSTSH0_TSH4_M0x000F0000ADC_SSTSH0_TSH5_M0x00F00000ADC_SSTSH0_TSH6_M0x0F000000ADC_SSTSH0_TSH7_M0xF0000000ADC_SSEMUX0_EMUX0ADC_SSEMUX0_EMUX1ADC_SSEMUX0_EMUX2ADC_SSEMUX0_EMUX3ADC_SSEMUX0_EMUX4ADC_SSEMUX0_EMUX5ADC_SSEMUX0_EMUX6ADC_SSEMUX0_EMUX70x10000000ADC_SSDC0_S0DCSEL_SADC_SSDC0_S1DCSEL_SADC_SSDC0_S2DCSEL_SADC_SSDC0_S3DCSEL_SADC_SSDC0_S4DCSEL_SADC_SSDC0_S5DCSEL_SADC_SSDC0_S6DCSEL_SADC_SSDC0_S0DCSEL_MADC_SSDC0_S1DCSEL_MADC_SSDC0_S2DCSEL_MADC_SSDC0_S3DCSEL_MADC_SSDC0_S4DCSEL_MADC_SSDC0_S5DCSEL_MADC_SSDC0_S6DCSEL_MADC_SSDC0_S7DCSEL_MADC_SSOP0_S0DCOPADC_SSOP0_S1DCOPADC_SSOP0_S2DCOPADC_SSOP0_S3DCOPADC_SSOP0_S4DCOPADC_SSOP0_S5DCOPADC_SSOP0_S6DCOPADC_SSOP0_S7DCOPADC_SSFSTAT0_TPTR_SADC_SSFSTAT0_HPTR_SADC_SSFSTAT0_TPTR_MADC_SSFSTAT0_HPTR_MADC_SSFSTAT0_EMPTYADC_SSFSTAT0_FULLADC_SSFIFO0_DATA_SADC_SSFIFO0_DATA_MADC_SSCTL0_D0ADC_SSCTL0_END0ADC_SSCTL0_IE0ADC_SSCTL0_TS0ADC_SSCTL0_D1ADC_SSCTL0_END1ADC_SSCTL0_IE1ADC_SSCTL0_TS1ADC_SSCTL0_D2ADC_SSCTL0_END2ADC_SSCTL0_IE2ADC_SSCTL0_TS2ADC_SSCTL0_D3ADC_SSCTL0_END3ADC_SSCTL0_IE3ADC_SSCTL0_TS3ADC_SSCTL0_D4ADC_SSCTL0_END4ADC_SSCTL0_IE4ADC_SSCTL0_TS4ADC_SSCTL0_D5ADC_SSCTL0_END5ADC_SSCTL0_IE5ADC_SSCTL0_TS5ADC_SSCTL0_D6ADC_SSCTL0_END60x02000000ADC_SSCTL0_IE60x04000000ADC_SSCTL0_TS60x08000000ADC_SSCTL0_D7ADC_SSCTL0_END70x20000000ADC_SSCTL0_IE70x40000000ADC_SSCTL0_TS70x80000000ADC_SSMUX0_MUX0_SADC_SSMUX0_MUX1_SADC_SSMUX0_MUX2_SADC_SSMUX0_MUX3_SADC_SSMUX0_MUX4_SADC_SSMUX0_MUX5_SADC_SSMUX0_MUX6_SADC_SSMUX0_MUX7_SADC_SSMUX0_MUX0_MADC_SSMUX0_MUX1_MADC_SSMUX0_MUX2_MADC_SSMUX0_MUX3_MADC_SSMUX0_MUX4_MADC_SSMUX0_MUX5_MADC_SSMUX0_MUX6_MADC_SSMUX0_MUX7_MADC_CTL_VREF_EXT_3VADC_CTL_VREF_INTERNALADC_CTL_VREF_MADC_DCISC_DCINT0ADC_DCISC_DCINT1ADC_DCISC_DCINT2ADC_DCISC_DCINT3ADC_DCISC_DCINT4ADC_DCISC_DCINT5ADC_DCISC_DCINT6ADC_DCISC_DCINT7ADC_SAC_AVG_64X0x00000006ADC_SAC_AVG_32XADC_SAC_AVG_16XADC_SAC_AVG_8XADC_SAC_AVG_4XADC_SAC_AVG_2XADC_SAC_AVG_OFFADC_SAC_AVG_MADC_PSSI_SS0ADC_PSSI_SS1ADC_PSSI_SS2ADC_PSSI_SS3ADC_PSSI_SYNCWAITADC_PSSI_GSYNCADC_SPC_PHASE_337_5ADC_SPC_PHASE_3150x0000000EADC_SPC_PHASE_292_50x0000000DADC_SPC_PHASE_270ADC_SPC_PHASE_247_50x0000000BADC_SPC_PHASE_2250x0000000AADC_SPC_PHASE_202_50x00000009ADC_SPC_PHASE_180ADC_SPC_PHASE_157_5ADC_SPC_PHASE_135ADC_SPC_PHASE_112_5ADC_SPC_PHASE_90ADC_SPC_PHASE_67_5ADC_SPC_PHASE_45ADC_SPC_PHASE_22_5ADC_SPC_PHASE_0ADC_SPC_PHASE_MADC_SSPRI_SS0_MADC_SSPRI_SS1_M0x00000030ADC_SSPRI_SS2_MADC_SSPRI_SS3_M0x00003000ADC_TSSEL_PS0_1ADC_TSSEL_PS0_0ADC_TSSEL_PS0_MADC_TSSEL_PS1_1ADC_TSSEL_PS1_0ADC_TSSEL_PS1_MADC_TSSEL_PS2_1ADC_TSSEL_PS2_0ADC_TSSEL_PS2_M0x00300000ADC_TSSEL_PS3_1ADC_TSSEL_PS3_0ADC_TSSEL_PS3_M0x30000000ADC_USTAT_UV0ADC_USTAT_UV1ADC_USTAT_UV2ADC_USTAT_UV3ADC_EMUX_EM0_ALWAYSADC_EMUX_EM0_NEVERADC_EMUX_EM0_PWM3ADC_EMUX_EM0_PWM2ADC_EMUX_EM0_PWM1ADC_EMUX_EM0_PWM0ADC_EMUX_EM0_TIMERADC_EMUX_EM0_EXTERNALADC_EMUX_EM0_COMP2ADC_EMUX_EM0_COMP1ADC_EMUX_EM0_COMP0ADC_EMUX_EM0_PROCESSORADC_EMUX_EM0_MADC_EMUX_EM1_ALWAYSADC_EMUX_EM1_NEVER0x000000E0ADC_EMUX_EM1_PWM30x00000090ADC_EMUX_EM1_PWM2ADC_EMUX_EM1_PWM10x00000070ADC_EMUX_EM1_PWM00x00000060ADC_EMUX_EM1_TIMER0x00000050ADC_EMUX_EM1_EXTERNALADC_EMUX_EM1_COMP2ADC_EMUX_EM1_COMP1ADC_EMUX_EM1_COMP0ADC_EMUX_EM1_PROCESSORADC_EMUX_EM1_MADC_EMUX_EM2_ALWAYSADC_EMUX_EM2_NEVER0x00000E00ADC_EMUX_EM2_PWM30x00000900ADC_EMUX_EM2_PWM2ADC_EMUX_EM2_PWM10x00000700ADC_EMUX_EM2_PWM00x00000600ADC_EMUX_EM2_TIMER0x00000500ADC_EMUX_EM2_EXTERNALADC_EMUX_EM2_COMP2ADC_EMUX_EM2_COMP1ADC_EMUX_EM2_COMP0ADC_EMUX_EM2_PROCESSORADC_EMUX_EM2_MADC_EMUX_EM3_ALWAYSADC_EMUX_EM3_NEVER0x0000E000ADC_EMUX_EM3_PWM30x00009000ADC_EMUX_EM3_PWM2ADC_EMUX_EM3_PWM10x00007000ADC_EMUX_EM3_PWM00x00006000ADC_EMUX_EM3_TIMER0x00005000ADC_EMUX_EM3_EXTERNALADC_EMUX_EM3_COMP2ADC_EMUX_EM3_COMP1ADC_EMUX_EM3_COMP0ADC_EMUX_EM3_PROCESSORADC_EMUX_EM3_MADC_OSTAT_OV0ADC_OSTAT_OV1ADC_OSTAT_OV2ADC_OSTAT_OV3ADC_ISC_IN0ADC_ISC_IN1ADC_ISC_IN2ADC_ISC_IN3ADC_ISC_DMAIN0ADC_ISC_DMAIN1ADC_ISC_DMAIN2ADC_ISC_DMAIN3ADC_ISC_DCINSS0ADC_ISC_DCINSS1ADC_ISC_DCINSS2ADC_ISC_DCINSS3ADC_IM_MASK0ADC_IM_MASK1ADC_IM_MASK2ADC_IM_MASK3ADC_IM_DMAMASK0ADC_IM_DMAMASK1ADC_IM_DMAMASK2ADC_IM_DMAMASK3ADC_IM_DCONSS0ADC_IM_DCONSS1ADC_IM_DCONSS2ADC_IM_DCONSS3ADC_RIS_INR0ADC_RIS_INR1ADC_RIS_INR2ADC_RIS_INR3ADC_RIS_DMAINR0ADC_RIS_DMAINR1ADC_RIS_DMAINR2ADC_RIS_DMAINR3ADC_RIS_INRDCADC_ACTSS_ASEN0ADC_ACTSS_ASEN1ADC_ACTSS_ASEN2ADC_ACTSS_ASEN3ADC_ACTSS_ADEN0ADC_ACTSS_ADEN1ADC_ACTSS_ADEN2ADC_ACTSS_ADEN3ADC_ACTSS_BUSYADC_O_CC0x00000FC8ADC_O_PC0x00000FC4ADC_O_PP0x00000FC0ADC_O_DCCMP70x00000E5CADC_O_DCCMP60x00000E58ADC_O_DCCMP50x00000E54ADC_O_DCCMP40x00000E50ADC_O_DCCMP30x00000E4CADC_O_DCCMP20x00000E48ADC_O_DCCMP10x00000E44ADC_O_DCCMP00x00000E40ADC_O_DCCTL70x00000E1CADC_O_DCCTL60x00000E18ADC_O_DCCTL50x00000E14ADC_O_DCCTL40x00000E10ADC_O_DCCTL30x00000E0CADC_O_DCCTL20x00000E08ADC_O_DCCTL10x00000E04ADC_O_DCCTL0ADC_O_DCRIC0x00000D00ADC_O_SSTSH30x000000BCADC_O_SSEMUX30x000000B8ADC_O_SSDC30x000000B4ADC_O_SSOP30x000000B0ADC_O_SSFSTAT30x000000ACADC_O_SSFIFO30x000000A8ADC_O_SSCTL30x000000A4ADC_O_SSMUX30x000000A0ADC_O_SSTSH20x0000009CADC_O_SSEMUX20x00000098ADC_O_SSDC20x00000094ADC_O_SSOP2ADC_O_SSFSTAT20x0000008CADC_O_SSFIFO20x00000088ADC_O_SSCTL20x00000084ADC_O_SSMUX2ADC_O_SSTSH10x0000007CADC_O_SSEMUX10x00000078ADC_O_SSDC10x00000074ADC_O_SSOP1ADC_O_SSFSTAT10x0000006CADC_O_SSFIFO10x00000068ADC_O_SSCTL10x00000064ADC_O_SSMUX1ADC_O_SSTSH00x0000005CADC_O_SSEMUX00x00000058ADC_O_SSDC00x00000054ADC_O_SSOP0ADC_O_SSFSTAT00x0000004CADC_O_SSFIFO00x00000048ADC_O_SSCTL00x00000044ADC_O_SSMUX0ADC_O_CTL0x00000038ADC_O_DCISC0x00000034ADC_O_SACADC_O_PSSI0x00000028ADC_O_SPC0x00000024ADC_O_SSPRIADC_O_TSSEL0x0000001CADC_O_USTAT0x00000018ADC_O_EMUX0x00000014ADC_O_OSTATADC_O_ISCADC_O_IMADC_O_RISADC_O_ACTSS__HW_ADC_H__// __HW_ADC_H__// MOSC// PIOSC// PLL VCO divided by CLKDIV// ADC Clock Source// PLL VCO Clock Divisor//*****************************************************************************//// The following are defines for the bit fields in the ADC_O_CC register.// defined by TADC and NSH// Full conversion rate (FCONV) as// conversion// before starting the next// pauses for 16 TADC periods// conversion completes, the logic// Half conversion rate. After a// pauses for 48 TADC periods// Quarter conversion rate. After a// pauses for 112 TADC periods// Eighth conversion rate. After a// Conversion Rate// 1 Msps// 500 ksps// 250 ksps// 125 ksps// ADC Sample Rate// The following are defines for the bit fields in the ADC_O_PC register.// Maximum ADC Sample Rate// Maximum Conversion Rate// ADC Channel Count// Digital Comparator Count// SAR// ADC Architecture// Resolution// Temperature Sensor// Sample-and-Hold Time// Application-Programmable// The following are defines for the bit fields in the ADC_O_PP register.// Compare 0// Compare 1// The following are defines for the bit fields in the ADC_O_DCCMP7 register.// The following are defines for the bit fields in the ADC_O_DCCMP6 register.// The following are defines for the bit fields in the ADC_O_DCCMP5 register.// The following are defines for the bit fields in the ADC_O_DCCMP4 register.// The following are defines for the bit fields in the ADC_O_DCCMP3 register.// The following are defines for the bit fields in the ADC_O_DCCMP2 register.// The following are defines for the bit fields in the ADC_O_DCCMP1 register.// The following are defines for the bit fields in the ADC_O_DCCMP0 register.// Hysteresis Once// Hysteresis Always// Once// Always// Comparison Interrupt Mode// High Band// Mid Band// Low Band// Comparison Interrupt Condition// Comparison Interrupt Enable// Comparison Trigger Mode// Comparison Trigger Condition// Comparison Trigger Enable// The following are defines for the bit fields in the ADC_O_DCCTL7 register.// The following are defines for the bit fields in the ADC_O_DCCTL6 register.// The following are defines for the bit fields in the ADC_O_DCCTL5 register.// The following are defines for the bit fields in the ADC_O_DCCTL4 register.// The following are defines for the bit fields in the ADC_O_DCCTL3 register.// The following are defines for the bit fields in the ADC_O_DCCTL2 register.// The following are defines for the bit fields in the ADC_O_DCCTL1 register.// The following are defines for the bit fields in the ADC_O_DCCTL0 register.// Digital Comparator Interrupt 0// Digital Comparator Interrupt 1// Digital Comparator Interrupt 2// Digital Comparator Interrupt 3// Digital Comparator Interrupt 4// Digital Comparator Interrupt 5// Digital Comparator Interrupt 6// Digital Comparator Interrupt 7// Digital Comparator Trigger 0// Digital Comparator Trigger 1// Digital Comparator Trigger 2// Digital Comparator Trigger 3// Digital Comparator Trigger 4// Digital Comparator Trigger 5// Digital Comparator Trigger 6// Digital Comparator Trigger 7// The following are defines for the bit fields in the ADC_O_DCRIC register.// Select// 1st Sample and Hold Period// The following are defines for the bit fields in the ADC_O_SSTSH3 register.// Bit)// 1st Sample Input Select (Upper// The following are defines for the bit fields in the ADC_O_SSEMUX3 register.// Sample 0 Digital Comparator// The following are defines for the bit fields in the ADC_O_SSDC3 register.// Operation// The following are defines for the bit fields in the ADC_O_SSOP3 register.// FIFO Tail Pointer// FIFO Head Pointer// FIFO Empty// FIFO Full// The following are defines for the bit fields in the ADC_O_SSFSTAT3 register.// Conversion Result Data// The following are defines for the bit fields in the ADC_O_SSFIFO3 register.// Sample Differential Input Select// End of Sequence// Sample Interrupt Enable// 1st Sample Temp Sensor Select// The following are defines for the bit fields in the ADC_O_SSCTL3 register.// 1st Sample Input Select// The following are defines for the bit fields in the ADC_O_SSMUX3 register.// 2nd Sample and Hold Period// 3rd Sample and Hold Period// 4th Sample and Hold Period// The following are defines for the bit fields in the ADC_O_SSTSH2 register.// 2th Sample Input Select (Upper// 3rd Sample Input Select (Upper// 4th Sample Input Select (Upper// The following are defines for the bit fields in the ADC_O_SSEMUX2 register.// Sample 1 Digital Comparator// Sample 2 Digital Comparator// Sample 3 Digital Comparator// The following are defines for the bit fields in the ADC_O_SSDC2 register.// The following are defines for the bit fields in the ADC_O_SSOP2 register.// The following are defines for the bit fields in the ADC_O_SSFSTAT2 register.// The following are defines for the bit fields in the ADC_O_SSFIFO2 register.// 1st Sample Differential Input// 1st Sample is End of Sequence// 1st Sample Interrupt Enable// 2nd Sample Differential Input// 2nd Sample is End of Sequence// 2nd Sample Interrupt Enable// 2nd Sample Temp Sensor Select// 3rd Sample Differential Input// 3rd Sample is End of Sequence// 3rd Sample Interrupt Enable// 3rd Sample Temp Sensor Select// 4th Sample Differential Input// 4th Sample is End of Sequence// 4th Sample Interrupt Enable// 4th Sample Temp Sensor Select// The following are defines for the bit fields in the ADC_O_SSCTL2 register.// 2nd Sample Input Select// 3rd Sample Input Select// 4th Sample Input Select// The following are defines for the bit fields in the ADC_O_SSMUX2 register.// The following are defines for the bit fields in the ADC_O_SSTSH1 register.// The following are defines for the bit fields in the ADC_O_SSEMUX1 register.// The following are defines for the bit fields in the ADC_O_SSDC1 register.// The following are defines for the bit fields in the ADC_O_SSOP1 register.// The following are defines for the bit fields in the ADC_O_SSFSTAT1 register.// The following are defines for the bit fields in the ADC_O_SSFIFO1 register.// The following are defines for the bit fields in the ADC_O_SSCTL1 register.// The following are defines for the bit fields in the ADC_O_SSMUX1 register.// 5th Sample and Hold Period// 6th Sample and Hold Period// 7th Sample and Hold Period// 8th Sample and Hold Period// The following are defines for the bit fields in the ADC_O_SSTSH0 register.// 5th Sample Input Select (Upper// 6th Sample Input Select (Upper// 7th Sample Input Select (Upper// 8th Sample Input Select (Upper// The following are defines for the bit fields in the ADC_O_SSEMUX0 register.// Sample 4 Digital Comparator// Sample 5 Digital Comparator// Sample 6 Digital Comparator// Sample 7 Digital Comparator// The following are defines for the bit fields in the ADC_O_SSDC0 register.// The following are defines for the bit fields in the ADC_O_SSOP0 register.// The following are defines for the bit fields in the ADC_O_SSFSTAT0 register.// The following are defines for the bit fields in the ADC_O_SSFIFO0 register.// 5th Sample Differential Input// 5th Sample is End of Sequence// 5th Sample Interrupt Enable// 5th Sample Temp Sensor Select// 6th Sample Differential Input// 6th Sample is End of Sequence// 6th Sample Interrupt Enable// 6th Sample Temp Sensor Select// 7th Sample Differential Input// 7th Sample is End of Sequence// 7th Sample Interrupt Enable// 7th Sample Temp Sensor Select// 8th Sample Differential Input// 8th Sample is End of Sequence// 8th Sample Interrupt Enable// 8th Sample Temp Sensor Select// The following are defines for the bit fields in the ADC_O_SSCTL0 register.// 5th Sample Input Select// 6th Sample Input Select// 7th Sample Input Select// 8th Sample Input Select// The following are defines for the bit fields in the ADC_O_SSMUX0 register.// references// inputs are the voltage// The external VREFA+ and VREFA-// VDDA and GNDA are the voltage// Voltage Reference Select// The following are defines for the bit fields in the ADC_O_CTL register.// Status and Clear// Digital Comparator 0 Interrupt// Digital Comparator 1 Interrupt// Digital Comparator 2 Interrupt// Digital Comparator 3 Interrupt// Digital Comparator 4 Interrupt// Digital Comparator 5 Interrupt// Digital Comparator 6 Interrupt// Digital Comparator 7 Interrupt// The following are defines for the bit fields in the ADC_O_DCISC register.// 64x hardware oversampling// 32x hardware oversampling// 16x hardware oversampling// 8x hardware oversampling// 4x hardware oversampling// 2x hardware oversampling// No hardware oversampling// Hardware Averaging Control// The following are defines for the bit fields in the ADC_O_SAC register.// SS0 Initiate// SS1 Initiate// SS2 Initiate// SS3 Initiate// Synchronize Wait// Global Synchronize// The following are defines for the bit fields in the ADC_O_PSSI register.// ADC sample lags by 337.5// ADC sample lags by 315.0// ADC sample lags by 292.5// ADC sample lags by 270.0// ADC sample lags by 247.5// ADC sample lags by 225.0// ADC sample lags by 202.5// ADC sample lags by 180.0// ADC sample lags by 157.5// ADC sample lags by 135.0// ADC sample lags by 112.5// ADC sample lags by 90.0// ADC sample lags by 67.5// ADC sample lags by 45.0// ADC sample lags by 22.5// ADC sample lags by 0.0// Phase Difference// The following are defines for the bit fields in the ADC_O_SPC register.// SS0 Priority// SS1 Priority// SS2 Priority// SS3 Priority// The following are defines for the bit fields in the ADC_O_SSPRI register.// trigger) in PWM module 1// Use Generator 0 (and its// trigger) in PWM module 0// Generator 0 PWM Module Trigger// Use Generator 1 (and its// Generator 1 PWM Module Trigger// Use Generator 2 (and its// Generator 2 PWM Module Trigger// Use Generator 3 (and its// Generator 3 PWM Module Trigger// The following are defines for the bit fields in the ADC_O_TSSEL register.// SS0 FIFO Underflow// SS1 FIFO Underflow// SS2 FIFO Underflow// SS3 FIFO Underflow// The following are defines for the bit fields in the ADC_O_USTAT register.// Always (continuously sample)// Never Trigger// PWM generator 3// PWM generator 2// PWM generator 1// PWM generator 0// Timer// External (GPIO Pins)// Analog Comparator 2// Analog Comparator 1// Analog Comparator 0// Processor (default)// SS0 Trigger Select// SS1 Trigger Select// SS2 Trigger Select// SS3 Trigger Select// The following are defines for the bit fields in the ADC_O_EMUX register.// SS0 FIFO Overflow// SS1 FIFO Overflow// SS2 FIFO Overflow// SS3 FIFO Overflow// The following are defines for the bit fields in the ADC_O_OSTAT register.// SS0 Interrupt Status and Clear// SS1 Interrupt Status and Clear// SS2 Interrupt Status and Clear// SS3 Interrupt Status and Clear// Clear// SS0 DMA Interrupt Status and// SS1 DMA Interrupt Status and// SS2 DMA Interrupt Status and// SS3 DMA Interrupt Status and// Status on SS0// Digital Comparator Interrupt// Status on SS1// Status on SS2// Status on SS3// The following are defines for the bit fields in the ADC_O_ISC register.// SS0 Interrupt Mask// SS1 Interrupt Mask// SS2 Interrupt Mask// SS3 Interrupt Mask// SS0 DMA Interrupt Mask// SS1 DMA Interrupt Mask// SS2 DMA Interrupt Mask// SS3 DMA Interrupt Mask// SS0// Digital Comparator Interrupt on// SS1// SS2// SS3// The following are defines for the bit fields in the ADC_O_IM register.// SS0 Raw Interrupt Status// SS1 Raw Interrupt Status// SS2 Raw Interrupt Status// SS3 Raw Interrupt Status// SS0 DMA Raw Interrupt Status// SS1 DMA Raw Interrupt Status// SS2 DMA Raw Interrupt Status// SS3 DMA Raw Interrupt Status// Status// Digital Comparator Raw Interrupt// The following are defines for the bit fields in the ADC_O_RIS register.// ADC SS0 Enable// ADC SS1 Enable// ADC SS2 Enable// ADC SS3 Enable// ADC SS1 DMA Enable// ADC SS2 DMA Enable// ADC SS3 DMA Enable// ADC Busy// The following are defines for the bit fields in the ADC_O_ACTSS register.// ADC Clock Configuration// ADC Peripheral Configuration// ADC Peripheral Properties// ADC Digital Comparator Range 7// ADC Digital Comparator Range 6// ADC Digital Comparator Range 5// ADC Digital Comparator Range 4// ADC Digital Comparator Range 3// ADC Digital Comparator Range 2// ADC Digital Comparator Range 1// ADC Digital Comparator Range 0// ADC Digital Comparator Control 7// ADC Digital Comparator Control 6// ADC Digital Comparator Control 5// ADC Digital Comparator Control 4// ADC Digital Comparator Control 3// ADC Digital Comparator Control 2// ADC Digital Comparator Control 1// ADC Digital Comparator Control 0// Initial Conditions// ADC Digital Comparator Reset// Hold Time// ADC Sample Sequence 3 Sample and// Input Multiplexer Select 3// ADC Sample Sequence Extended// Comparator Select// ADC Sample Sequence 3 Digital// ADC Sample Sequence 3 Operation// ADC Sample Sequence FIFO 3// 3// ADC Sample Sequence Result FIFO// ADC Sample Sequence Control 3// Multiplexer Select 3// ADC Sample Sequence Input// ADC Sample Sequence 2 Sample and// Input Multiplexer Select 2// ADC Sample Sequence 2 Digital// ADC Sample Sequence 2 Operation// ADC Sample Sequence FIFO 2// 2// ADC Sample Sequence Control 2// Multiplexer Select 2// ADC Sample Sequence 1 Sample and// Input Multiplexer Select 1// ADC Sample Sequence 1 Digital// ADC Sample Sequence 1 Operation// ADC Sample Sequence FIFO 1// 1// ADC Sample Sequence Control 1// Multiplexer Select 1// ADC Sample Sequence 0 Sample and// Input Multiplexer Select 0// ADC Sample Sequence 0 Digital// ADC Sample Sequence 0 Operation// ADC Sample Sequence FIFO 0// 0// ADC Sample Sequence Control 0// Multiplexer Select 0// ADC Control// ADC Digital Comparator Interrupt// ADC Sample Averaging Control// Initiate// ADC Processor Sample Sequence// ADC Sample Phase Control// ADC Sample Sequencer Priority// ADC Trigger Source Select// ADC Underflow Status// ADC Event Multiplexer Select// ADC Overflow Status// ADC Interrupt Status and Clear// ADC Interrupt Mask// ADC Raw Interrupt Status// ADC Active Sample Sequencer// The following are defines for the ADC register offsets.// This is part of revision 2.2.0.295 of the Tiva Firmware Development Package.// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS//   from this software without specific prior written permission.//   its contributors may be used to endorse or promote products derived//   Neither the name of Texas Instruments Incorporated nor the names of//   distribution.//   documentation and/or other materials provided with the  //   notice, this list of conditions and the following disclaimer in the//   Redistributions in binary form must reproduce the above copyright//   notice, this list of conditions and the following disclaimer.//   Redistributions of source code must retain the above copyright//   are met://   modification, are permitted provided that the following conditions//   Redistribution and use in source and binary forms, with or without// Software License Agreement// Copyright (c) 2005-2020 Texas Instruments Incorporated.  All rights reserved.// hw_adc.h - Macros used when accessing the ADC hardware./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/inc/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/home/frost/Documents/ectf_2023/qlSpace/home/frost/Documents/ectf_2023/home/frost/Documents/home/frost/home//home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/inc/hw_ints.hNUM_PRIORITY_BITS3NUM_PRIORITYNUM_INTERRUPTSINT_CONCAT(NUM_INTERRUPTS_, INT_DEVICE_CLASS)INT_WTIMER5BINT_CONCAT(INT_WTIMER5B_, INT_DEVICE_CLASS)INT_WTIMER5AINT_CONCAT(INT_WTIMER5A_, INT_DEVICE_CLASS)INT_WTIMER4BINT_CONCAT(INT_WTIMER4B_, INT_DEVICE_CLASS)INT_WTIMER4AINT_CONCAT(INT_WTIMER4A_, INT_DEVICE_CLASS)INT_WTIMER3BINT_CONCAT(INT_WTIMER3B_, INT_DEVICE_CLASS)INT_WTIMER3AINT_CONCAT(INT_WTIMER3A_, INT_DEVICE_CLASS)INT_WTIMER2BINT_CONCAT(INT_WTIMER2B_, INT_DEVICE_CLASS)INT_WTIMER2AINT_CONCAT(INT_WTIMER2A_, INT_DEVICE_CLASS)INT_WTIMER1BINT_CONCAT(INT_WTIMER1B_, INT_DEVICE_CLASS)INT_WTIMER1AINT_CONCAT(INT_WTIMER1A_, INT_DEVICE_CLASS)INT_WTIMER0BINT_CONCAT(INT_WTIMER0B_, INT_DEVICE_CLASS)INT_WTIMER0AINT_CONCAT(INT_WTIMER0A_, INT_DEVICE_CLASS)INT_WATCHDOGINT_CONCAT(INT_WATCHDOG_, INT_DEVICE_CLASS)INT_USB0INT_CONCAT(INT_USB0_, INT_DEVICE_CLASS)INT_UDMAERRINT_CONCAT(INT_UDMAERR_, INT_DEVICE_CLASS)INT_UDMAINT_CONCAT(INT_UDMA_, INT_DEVICE_CLASS)INT_UART7INT_CONCAT(INT_UART7_, INT_DEVICE_CLASS)INT_UART6INT_CONCAT(INT_UART6_, INT_DEVICE_CLASS)INT_UART5INT_CONCAT(INT_UART5_, INT_DEVICE_CLASS)INT_UART4INT_CONCAT(INT_UART4_, INT_DEVICE_CLASS)INT_UART3INT_CONCAT(INT_UART3_, INT_DEVICE_CLASS)INT_UART2INT_CONCAT(INT_UART2_, INT_DEVICE_CLASS)INT_UART1INT_CONCAT(INT_UART1_, INT_DEVICE_CLASS)INT_UART0INT_CONCAT(INT_UART0_, INT_DEVICE_CLASS)INT_TIMER7BINT_CONCAT(INT_TIMER7B_, INT_DEVICE_CLASS)INT_TIMER7AINT_CONCAT(INT_TIMER7A_, INT_DEVICE_CLASS)INT_TIMER6BINT_CONCAT(INT_TIMER6B_, INT_DEVICE_CLASS)INT_TIMER6AINT_CONCAT(INT_TIMER6A_, INT_DEVICE_CLASS)INT_TIMER5BINT_CONCAT(INT_TIMER5B_, INT_DEVICE_CLASS)INT_TIMER5AINT_CONCAT(INT_TIMER5A_, INT_DEVICE_CLASS)INT_TIMER4BINT_CONCAT(INT_TIMER4B_, INT_DEVICE_CLASS)INT_TIMER4AINT_CONCAT(INT_TIMER4A_, INT_DEVICE_CLASS)INT_TIMER3BINT_CONCAT(INT_TIMER3B_, INT_DEVICE_CLASS)INT_TIMER3AINT_CONCAT(INT_TIMER3A_, INT_DEVICE_CLASS)INT_TIMER2BINT_CONCAT(INT_TIMER2B_, INT_DEVICE_CLASS)INT_TIMER2AINT_CONCAT(INT_TIMER2A_, INT_DEVICE_CLASS)INT_TIMER1BINT_CONCAT(INT_TIMER1B_, INT_DEVICE_CLASS)INT_TIMER1AINT_CONCAT(INT_TIMER1A_, INT_DEVICE_CLASS)INT_TIMER0BINT_CONCAT(INT_TIMER0B_, INT_DEVICE_CLASS)INT_TIMER0AINT_CONCAT(INT_TIMER0A_, INT_DEVICE_CLASS)INT_TAMPER0INT_CONCAT(INT_TAMPER0_, INT_DEVICE_CLASS)INT_SYSEXCINT_CONCAT(INT_SYSEXC_, INT_DEVICE_CLASS)INT_SYSCTLINT_CONCAT(INT_SYSCTL_, INT_DEVICE_CLASS)INT_SSI3INT_CONCAT(INT_SSI3_, INT_DEVICE_CLASS)INT_SSI2INT_CONCAT(INT_SSI2_, INT_DEVICE_CLASS)INT_SSI1INT_CONCAT(INT_SSI1_, INT_DEVICE_CLASS)INT_SSI0INT_CONCAT(INT_SSI0_, INT_DEVICE_CLASS)INT_SHA0INT_CONCAT(INT_SHA0_, INT_DEVICE_CLASS)INT_QEI1INT_CONCAT(INT_QEI1_, INT_DEVICE_CLASS)INT_QEI0INT_CONCAT(INT_QEI0_, INT_DEVICE_CLASS)INT_PWM1_FAULTINT_CONCAT(INT_PWM1_FAULT_, INT_DEVICE_CLASS)INT_PWM1_3INT_CONCAT(INT_PWM1_3_, INT_DEVICE_CLASS)INT_PWM1_2INT_CONCAT(INT_PWM1_2_, INT_DEVICE_CLASS)INT_PWM1_1INT_CONCAT(INT_PWM1_1_, INT_DEVICE_CLASS)INT_PWM1_0INT_CONCAT(INT_PWM1_0_, INT_DEVICE_CLASS)INT_PWM0_FAULTINT_CONCAT(INT_PWM0_FAULT_, INT_DEVICE_CLASS)INT_PWM0_3INT_CONCAT(INT_PWM0_3_, INT_DEVICE_CLASS)INT_PWM0_2INT_CONCAT(INT_PWM0_2_, INT_DEVICE_CLASS)INT_PWM0_1INT_CONCAT(INT_PWM0_1_, INT_DEVICE_CLASS)INT_PWM0_0INT_CONCAT(INT_PWM0_0_, INT_DEVICE_CLASS)INT_ONEWIRE0INT_CONCAT(INT_ONEWIRE0_, INT_DEVICE_CLASS)INT_LCD0INT_CONCAT(INT_LCD0_, INT_DEVICE_CLASS)INT_I2C9INT_CONCAT(INT_I2C9_, INT_DEVICE_CLASS)INT_I2C8INT_CONCAT(INT_I2C8_, INT_DEVICE_CLASS)INT_I2C7INT_CONCAT(INT_I2C7_, INT_DEVICE_CLASS)INT_I2C6INT_CONCAT(INT_I2C6_, INT_DEVICE_CLASS)INT_I2C5INT_CONCAT(INT_I2C5_, INT_DEVICE_CLASS)INT_I2C4INT_CONCAT(INT_I2C4_, INT_DEVICE_CLASS)INT_I2C3INT_CONCAT(INT_I2C3_, INT_DEVICE_CLASS)INT_I2C2INT_CONCAT(INT_I2C2_, INT_DEVICE_CLASS)INT_I2C1INT_CONCAT(INT_I2C1_, INT_DEVICE_CLASS)INT_I2C0INT_CONCAT(INT_I2C0_, INT_DEVICE_CLASS)INT_HIBERNATEINT_CONCAT(INT_HIBERNATE_, INT_DEVICE_CLASS)INT_GPIOTINT_CONCAT(INT_GPIOT_, INT_DEVICE_CLASS)INT_GPIOSINT_CONCAT(INT_GPIOS_, INT_DEVICE_CLASS)INT_GPIORINT_CONCAT(INT_GPIOR_, INT_DEVICE_CLASS)INT_GPIOQ7INT_CONCAT(INT_GPIOQ7_, INT_DEVICE_CLASS)INT_GPIOQ6INT_CONCAT(INT_GPIOQ6_, INT_DEVICE_CLASS)INT_GPIOQ5INT_CONCAT(INT_GPIOQ5_, INT_DEVICE_CLASS)INT_GPIOQ4INT_CONCAT(INT_GPIOQ4_, INT_DEVICE_CLASS)INT_GPIOQ3INT_CONCAT(INT_GPIOQ3_, INT_DEVICE_CLASS)INT_GPIOQ2INT_CONCAT(INT_GPIOQ2_, INT_DEVICE_CLASS)INT_GPIOQ1INT_CONCAT(INT_GPIOQ1_, INT_DEVICE_CLASS)INT_GPIOQ0INT_CONCAT(INT_GPIOQ0_, INT_DEVICE_CLASS)INT_GPIOP7INT_CONCAT(INT_GPIOP7_, INT_DEVICE_CLASS)INT_GPIOP6INT_CONCAT(INT_GPIOP6_, INT_DEVICE_CLASS)INT_GPIOP5INT_CONCAT(INT_GPIOP5_, INT_DEVICE_CLASS)INT_GPIOP4INT_CONCAT(INT_GPIOP4_, INT_DEVICE_CLASS)INT_GPIOP3INT_CONCAT(INT_GPIOP3_, INT_DEVICE_CLASS)INT_GPIOP2INT_CONCAT(INT_GPIOP2_, INT_DEVICE_CLASS)INT_GPIOP1INT_CONCAT(INT_GPIOP1_, INT_DEVICE_CLASS)INT_GPIOP0INT_CONCAT(INT_GPIOP0_, INT_DEVICE_CLASS)INT_GPIONINT_CONCAT(INT_GPION_, INT_DEVICE_CLASS)INT_GPIOMINT_CONCAT(INT_GPIOM_, INT_DEVICE_CLASS)INT_GPIOLINT_CONCAT(INT_GPIOL_, INT_DEVICE_CLASS)INT_GPIOKINT_CONCAT(INT_GPIOK_, INT_DEVICE_CLASS)INT_GPIOJINT_CONCAT(INT_GPIOJ_, INT_DEVICE_CLASS)INT_GPIOHINT_CONCAT(INT_GPIOH_, INT_DEVICE_CLASS)INT_GPIOGINT_CONCAT(INT_GPIOG_, INT_DEVICE_CLASS)INT_GPIOFINT_CONCAT(INT_GPIOF_, INT_DEVICE_CLASS)INT_GPIOEINT_CONCAT(INT_GPIOE_, INT_DEVICE_CLASS)INT_GPIODINT_CONCAT(INT_GPIOD_, INT_DEVICE_CLASS)INT_GPIOCINT_CONCAT(INT_GPIOC_, INT_DEVICE_CLASS)INT_GPIOBINT_CONCAT(INT_GPIOB_, INT_DEVICE_CLASS)INT_GPIOAINT_CONCAT(INT_GPIOA_, INT_DEVICE_CLASS)INT_FLASHINT_CONCAT(INT_FLASH_, INT_DEVICE_CLASS)INT_EPI0INT_CONCAT(INT_EPI0_, INT_DEVICE_CLASS)INT_EMAC0INT_CONCAT(INT_EMAC0_, INT_DEVICE_CLASS)INT_DES0INT_CONCAT(INT_DES0_, INT_DEVICE_CLASS)INT_COMP2INT_CONCAT(INT_COMP2_, INT_DEVICE_CLASS)INT_COMP1INT_CONCAT(INT_COMP1_, INT_DEVICE_CLASS)INT_COMP0INT_CONCAT(INT_COMP0_, INT_DEVICE_CLASS)INT_CAN1INT_CONCAT(INT_CAN1_, INT_DEVICE_CLASS)INT_CAN0INT_CONCAT(INT_CAN0_, INT_DEVICE_CLASS)INT_AES0INT_CONCAT(INT_AES0_, INT_DEVICE_CLASS)INT_ADC1SS3INT_CONCAT(INT_ADC1SS3_, INT_DEVICE_CLASS)INT_ADC1SS2INT_CONCAT(INT_ADC1SS2_, INT_DEVICE_CLASS)INT_ADC1SS1INT_CONCAT(INT_ADC1SS1_, INT_DEVICE_CLASS)INT_ADC1SS0INT_CONCAT(INT_ADC1SS0_, INT_DEVICE_CLASS)INT_ADC0SS3INT_CONCAT(INT_ADC0SS3_, INT_DEVICE_CLASS)INT_ADC0SS2INT_CONCAT(INT_ADC0SS2_, INT_DEVICE_CLASS)INT_ADC0SS1INT_CONCAT(INT_ADC0SS1_, INT_DEVICE_CLASS)INT_ADC0SS0INT_CONCAT(INT_ADC0SS0_, INT_DEVICE_CLASS)INT_CONCAT(intname,class)INT_RESOLVE(intname, class)INT_DEVICE_CLASS"UNKNOWN"NUM_INTERRUPTS_TM4C129129INT_GPIOT_TM4C129127INT_I2C9_TM4C129126INT_I2C8_TM4C129125INT_ONEWIRE0_TM4C129121INT_I2C7_TM4C129119INT_I2C6_TM4C129118INT_TIMER7B_TM4C129117INT_TIMER7A_TM4C129116INT_TIMER6B_TM4C129115INT_TIMER6A_TM4C129114INT_LCD0_TM4C129113INT_DES0_TM4C129112INT_AES0_TM4C129111INT_SHA0_TM4C129110INT_GPIOS_TM4C129109INT_GPIOR_TM4C129108INT_GPIOQ7_TM4C129107INT_GPIOQ6_TM4C129106INT_GPIOQ5_TM4C129105INT_GPIOQ4_TM4C129104INT_GPIOQ3_TM4C129103INT_GPIOQ2_TM4C129102INT_GPIOQ1_TM4C129101INT_GPIOQ0_TM4C129100INT_GPIOP7_TM4C12999INT_GPIOP6_TM4C12998INT_GPIOP5_TM4C12997INT_GPIOP4_TM4C12996INT_GPIOP3_TM4C12995INT_GPIOP2_TM4C12994INT_GPIOP1_TM4C12993INT_GPIOP0_TM4C12992INT_TAMPER0_TM4C12991INT_GPION_TM4C12989INT_GPIOM_TM4C12988INT_I2C5_TM4C12987INT_I2C4_TM4C12986INT_SYSEXC_TM4C12983INT_TIMER5B_TM4C12982INT_TIMER5A_TM4C12981INT_TIMER4B_TM4C12980INT_TIMER4A_TM4C12979INT_I2C3_TM4C12978INT_I2C2_TM4C12977INT_UART7_TM4C12976INT_UART6_TM4C12975INT_UART5_TM4C12974INT_UART4_TM4C12973INT_UART3_TM4C12972INT_SSI3_TM4C12971INT_SSI2_TM4C12970INT_GPIOL_TM4C12969INT_GPIOK_TM4C12968INT_GPIOJ_TM4C12967INT_EPI0_TM4C12966INT_ADC1SS3_TM4C12965INT_ADC1SS2_TM4C12964INT_ADC1SS1_TM4C12963INT_ADC1SS0_TM4C12962INT_UDMAERR_TM4C12961INT_UDMA_TM4C12960INT_PWM0_3_TM4C12959INT_USB0_TM4C12958INT_HIBERNATE_TM4C12957INT_EMAC0_TM4C12956INT_CAN1_TM4C12955INT_CAN0_TM4C12954INT_I2C1_TM4C12953INT_TIMER3B_TM4C12952INT_TIMER3A_TM4C12951INT_SSI1_TM4C12950INT_UART2_TM4C12949INT_GPIOH_TM4C12948INT_GPIOG_TM4C12947INT_GPIOF_TM4C12946INT_FLASH_TM4C12945INT_SYSCTL_TM4C12944INT_COMP2_TM4C12943INT_COMP1_TM4C12942INT_COMP0_TM4C12941INT_TIMER2B_TM4C12940INT_TIMER2A_TM4C12939INT_TIMER1B_TM4C12938INT_TIMER1A_TM4C12937INT_TIMER0B_TM4C12936INT_TIMER0A_TM4C12935INT_WATCHDOG_TM4C12934INT_ADC0SS3_TM4C12933INT_ADC0SS2_TM4C12932INT_ADC0SS1_TM4C12931INT_ADC0SS0_TM4C12930INT_QEI0_TM4C12929INT_PWM0_2_TM4C129INT_PWM0_1_TM4C12927INT_PWM0_0_TM4C12926INT_PWM0_FAULT_TM4C12925INT_I2C0_TM4C129INT_SSI0_TM4C12923INT_UART1_TM4C12922INT_UART0_TM4C12921INT_GPIOE_TM4C129INT_GPIOD_TM4C12919INT_GPIOC_TM4C129INT_GPIOB_TM4C12917INT_GPIOA_TM4C129NUM_INTERRUPTS_TM4C123155INT_PWM1_FAULT_TM4C123154INT_PWM1_3_TM4C123153INT_PWM1_2_TM4C123152INT_PWM1_1_TM4C123151INT_PWM1_0_TM4C123150INT_GPIOQ7_TM4C123147INT_GPIOQ6_TM4C123146INT_GPIOQ5_TM4C123145INT_GPIOQ4_TM4C123144INT_GPIOQ3_TM4C123143INT_GPIOQ2_TM4C123142INT_GPIOQ1_TM4C123141INT_GPIOQ0_TM4C123140INT_GPIOP7_TM4C123139INT_GPIOP6_TM4C123138INT_GPIOP5_TM4C123137INT_GPIOP4_TM4C123136INT_GPIOP3_TM4C123135INT_GPIOP2_TM4C123134INT_GPIOP1_TM4C123133INT_GPIOP0_TM4C123132INT_GPION_TM4C123128INT_GPIOM_TM4C123INT_I2C5_TM4C123INT_I2C4_TM4C123INT_SYSEXC_TM4C123122INT_WTIMER5B_TM4C123INT_WTIMER5A_TM4C123120INT_WTIMER4B_TM4C123INT_WTIMER4A_TM4C123INT_WTIMER3B_TM4C123INT_WTIMER3A_TM4C123INT_WTIMER2B_TM4C123INT_WTIMER2A_TM4C123INT_WTIMER1B_TM4C123INT_WTIMER1A_TM4C123INT_WTIMER0B_TM4C123INT_WTIMER0A_TM4C123INT_TIMER5B_TM4C123INT_TIMER5A_TM4C123INT_TIMER4B_TM4C123INT_TIMER4A_TM4C123INT_I2C3_TM4C12385INT_I2C2_TM4C12384INT_UART7_TM4C123INT_UART6_TM4C123INT_UART5_TM4C123INT_UART4_TM4C123INT_UART3_TM4C123INT_SSI3_TM4C123INT_SSI2_TM4C123INT_GPIOL_TM4C123INT_GPIOK_TM4C123INT_GPIOJ_TM4C123INT_ADC1SS3_TM4C123INT_ADC1SS2_TM4C123INT_ADC1SS1_TM4C123INT_ADC1SS0_TM4C123INT_UDMAERR_TM4C123INT_UDMA_TM4C123INT_PWM0_3_TM4C123INT_USB0_TM4C123INT_HIBERNATE_TM4C123INT_CAN1_TM4C123INT_CAN0_TM4C123INT_QEI1_TM4C123INT_I2C1_TM4C123INT_TIMER3B_TM4C123INT_TIMER3A_TM4C123INT_SSI1_TM4C123INT_UART2_TM4C123INT_GPIOH_TM4C123INT_GPIOG_TM4C123INT_GPIOF_TM4C123INT_FLASH_TM4C123INT_SYSCTL_TM4C123INT_COMP2_TM4C123INT_COMP1_TM4C123INT_COMP0_TM4C123INT_TIMER2B_TM4C123INT_TIMER2A_TM4C123INT_TIMER1B_TM4C123INT_TIMER1A_TM4C123INT_TIMER0B_TM4C123INT_TIMER0A_TM4C123INT_WATCHDOG_TM4C123INT_ADC0SS3_TM4C123INT_ADC0SS2_TM4C123INT_ADC0SS1_TM4C123INT_ADC0SS0_TM4C123INT_QEI0_TM4C123INT_PWM0_2_TM4C123INT_PWM0_1_TM4C123INT_PWM0_0_TM4C123INT_PWM0_FAULT_TM4C123INT_I2C0_TM4C123INT_SSI0_TM4C123INT_UART1_TM4C123INT_UART0_TM4C123INT_GPIOE_TM4C123INT_GPIOD_TM4C123INT_GPIOC_TM4C123INT_GPIOB_TM4C123INT_GPIOA_TM4C123FAULT_SYSTICK15FAULT_PENDSV14FAULT_DEBUGFAULT_SVCALL11FAULT_USAGE6FAULT_BUS5FAULT_MPUFAULT_HARDFAULT_NMI2__HW_INTS_H__defined(TARGET_IS_TM4C123_RA1) || defined(TARGET_IS_TM4C123_RA2) || \defined(TARGET_IS_TM4C129_RA0) || defined(PART_TM4C1290NCPDT) || \// __HW_INTS_H__// The following are defines for the total number of priority levels.// The following are defines for the total number of interrupts.// The following are defines for the interrupt assignments.// Macros to resolve the INT_PERIPH_CLASS name to a common INT_PERIPH name.// TM4C129 Interrupt Class Definition// TM4C123 Interrupt Class Definition// GPIO T// I2C 9// I2C 8// 1-Wire// I2C 7// I2C 6// 16/32-Bit Timer 7B// 16/32-Bit Timer 7A// 16/32-Bit Timer 6B// 16/32-Bit Timer 6A// LCD// DES// AES// SHA/MD5// GPIO Port S// GPIO Port R// GPIO Port Q7// GPIO Port Q6// GPIO Port Q5// GPIO Port Q4// GPIO Port Q3// GPIO Port Q2// GPIO Port Q1// GPIO Port Q (Summary or Q0)// GPIO Port P7// GPIO Port P6// GPIO Port P5// GPIO Port P4// GPIO Port P3// GPIO Port P2// GPIO Port P1// GPIO Port P (Summary or P0)// Tamper// GPIO Port N// GPIO Port M// I2C 5// I2C 4// (imprecise)// Floating-Point Exception// Timer 5B// Timer 5A// Timer 4B// Timer 4A// I2C 3// I2C 2// UART 7// UART 6// UART 5// UART 4// UART 3// SSI 3// SSI 2// GPIO Port L// GPIO Port K// GPIO Port J// EPI 0// ADC1 Sequence 3// ADC1 Sequence 2// ADC1 Sequence 1// ADC1 Sequence 0// uDMA 0 Error// uDMA 0 Software// PWM Generator 3// USB MAC// HIB// Ethernet MAC// CAN1// CAN 0// I2C1// 16/32-Bit Timer 3B// 16/32-Bit Timer 3A// SSI1// UART2// GPIO Port H// GPIO Port G// GPIO Port F// Flash Memory Control// System Control// 16/32-Bit Timer 2B// 16/32-Bit Timer 2A// 16/32-Bit Timer 1B// 16/32-Bit Timer 1A// 16/32-Bit Timer 0B// 16/32-Bit Timer 0A// Watchdog Timers 0 and 1// ADC0 Sequence 3// ADC0 Sequence 2// ADC0 Sequence 1// ADC0 Sequence 0// QEI0// PWM Generator 2// PWM Generator 1// PWM Generator 0// PWM Fault// I2C0// SSI0// UART1// UART0// GPIO Port E// GPIO Port D// GPIO Port C// GPIO Port B// GPIO Port A// TM4C129 Class Interrupts// PWM1 Fault// PWM1 Generator 3// PWM1 Generator 2// PWM1 Generator 1// PWM1 Generator 0// I2C5// I2C4// System Exception (imprecise)// 32/64-Bit Timer 5B// 32/64-Bit Timer 5A// 32/64-Bit Timer 4B// 32/64-Bit Timer 4A// 32/64-Bit Timer 3B// 32/64-Bit Timer 3A// 32/64-Bit Timer 2B// 32/64-Bit Timer 2A// 32/64-Bit Timer 1B// 32/64-Bit Timer 1A// 32/64-Bit Timer 0B// 32/64-Bit Timer 0A// 16/32-Bit Timer 5B// 16/32-Bit Timer 5A// 16/32-Bit Timer 4B// 16/32-Bit Timer 4A// I2C3// I2C2// UART7// UART6// UART5// UART4// UART3// SSI3// SSI2// uDMA Error// uDMA Software// USB// Hibernation Module// CAN0// QEI1// Timer 3B// Control// Flash Memory Control and EEPROM// PWM0 Generator 2// PWM0 Generator 1// PWM0 Generator 0// PWM0 Fault// TM4C123 Class Interrupts// System Tick// PendSV// Debug monitor// SVCall// Usage fault// Bus fault// MPU fault// Hard fault// NMI fault// The following are defines for the fault assignments.// MCUs.// hw_ints.h - Macros that define the interrupt assignment on Tiva C Series/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/inc/hw_sysctl.hSYSCTL_PWRTC_VDD_UBOR0SYSCTL_PWRTC_VDDA_UBOR0SYSCTL_RESC_HIBSYSCTL_DID0_CLASS_SNOWFLAKE0x000A0000SYSCTL_DID0_CLASS_BLIZZARD0x00050000SYSCTL_CCMCGREQ_SHACFGSYSCTL_CCMCGREQ_AESCFGSYSCTL_CCMCGREQ_DESCFGSYSCTL_UNIQUEID3_ID_SSYSCTL_UNIQUEID3_ID_M0xFFFFFFFFSYSCTL_UNIQUEID2_ID_SSYSCTL_UNIQUEID2_ID_MSYSCTL_UNIQUEID1_ID_SSYSCTL_UNIQUEID1_ID_MSYSCTL_UNIQUEID0_ID_SSYSCTL_UNIQUEID0_ID_MSYSCTL_PREMAC_R0SYSCTL_PROWIRE_R0SYSCTL_PRLCD_R0SYSCTL_PRCCM_R0SYSCTL_PRWTIMER_R0SYSCTL_PRWTIMER_R1SYSCTL_PRWTIMER_R2SYSCTL_PRWTIMER_R3SYSCTL_PRWTIMER_R4SYSCTL_PRWTIMER_R5SYSCTL_PREEPROM_R0SYSCTL_PRQEI_R0SYSCTL_PRQEI_R1SYSCTL_PRPWM_R0SYSCTL_PRPWM_R1SYSCTL_PRACMP_R0SYSCTL_PRADC_R0SYSCTL_PRADC_R1SYSCTL_PRCAN_R0SYSCTL_PRCAN_R1SYSCTL_PREPHY_R0SYSCTL_PRUSB_R0SYSCTL_PRI2C_R0SYSCTL_PRI2C_R1SYSCTL_PRI2C_R2SYSCTL_PRI2C_R3SYSCTL_PRI2C_R4SYSCTL_PRI2C_R5SYSCTL_PRI2C_R6SYSCTL_PRI2C_R7SYSCTL_PRI2C_R8SYSCTL_PRI2C_R9SYSCTL_PRSSI_R0SYSCTL_PRSSI_R1SYSCTL_PRSSI_R2SYSCTL_PRSSI_R3SYSCTL_PRUART_R0SYSCTL_PRUART_R1SYSCTL_PRUART_R2SYSCTL_PRUART_R3SYSCTL_PRUART_R4SYSCTL_PRUART_R5SYSCTL_PRUART_R6SYSCTL_PRUART_R7SYSCTL_PRHIB_R0SYSCTL_PREPI_R0SYSCTL_PRDMA_R0SYSCTL_PRGPIO_R0SYSCTL_PRGPIO_R1SYSCTL_PRGPIO_R2SYSCTL_PRGPIO_R3SYSCTL_PRGPIO_R4SYSCTL_PRGPIO_R5SYSCTL_PRGPIO_R6SYSCTL_PRGPIO_R7SYSCTL_PRGPIO_R8SYSCTL_PRGPIO_R9SYSCTL_PRGPIO_R10SYSCTL_PRGPIO_R11SYSCTL_PRGPIO_R12SYSCTL_PRGPIO_R13SYSCTL_PRGPIO_R14SYSCTL_PRGPIO_R15SYSCTL_PRGPIO_R16SYSCTL_PRGPIO_R17SYSCTL_PRTIMER_R0SYSCTL_PRTIMER_R1SYSCTL_PRTIMER_R2SYSCTL_PRTIMER_R3SYSCTL_PRTIMER_R4SYSCTL_PRTIMER_R5SYSCTL_PRTIMER_R6SYSCTL_PRTIMER_R7SYSCTL_PRWD_R0SYSCTL_PRWD_R1SYSCTL_PCEMAC_P0SYSCTL_PCOWIRE_P0SYSCTL_PCLCD_P0SYSCTL_PCCCM_P0SYSCTL_PCEEPROM_P0SYSCTL_PCQEI_P0SYSCTL_PCPWM_P0SYSCTL_PCACMP_P0SYSCTL_PCADC_P0SYSCTL_PCADC_P1SYSCTL_PCCAN_P0SYSCTL_PCCAN_P1SYSCTL_PCEPHY_P0SYSCTL_PCUSB_P0SYSCTL_PCI2C_P0SYSCTL_PCI2C_P1SYSCTL_PCI2C_P2SYSCTL_PCI2C_P3SYSCTL_PCI2C_P4SYSCTL_PCI2C_P5SYSCTL_PCI2C_P6SYSCTL_PCI2C_P7SYSCTL_PCI2C_P8SYSCTL_PCI2C_P9SYSCTL_PCSSI_P0SYSCTL_PCSSI_P1SYSCTL_PCSSI_P2SYSCTL_PCSSI_P3SYSCTL_PCUART_P0SYSCTL_PCUART_P1SYSCTL_PCUART_P2SYSCTL_PCUART_P3SYSCTL_PCUART_P4SYSCTL_PCUART_P5SYSCTL_PCUART_P6SYSCTL_PCUART_P7SYSCTL_PCHIB_P0SYSCTL_PCEPI_P0SYSCTL_PCDMA_P0SYSCTL_PCGPIO_P0SYSCTL_PCGPIO_P1SYSCTL_PCGPIO_P2SYSCTL_PCGPIO_P3SYSCTL_PCGPIO_P4SYSCTL_PCGPIO_P5SYSCTL_PCGPIO_P6SYSCTL_PCGPIO_P7SYSCTL_PCGPIO_P8SYSCTL_PCGPIO_P9SYSCTL_PCGPIO_P10SYSCTL_PCGPIO_P11SYSCTL_PCGPIO_P12SYSCTL_PCGPIO_P13SYSCTL_PCGPIO_P14SYSCTL_PCGPIO_P15SYSCTL_PCGPIO_P16SYSCTL_PCGPIO_P17SYSCTL_PCTIMER_P0SYSCTL_PCTIMER_P1SYSCTL_PCTIMER_P2SYSCTL_PCTIMER_P3SYSCTL_PCTIMER_P4SYSCTL_PCTIMER_P5SYSCTL_PCTIMER_P6SYSCTL_PCTIMER_P7SYSCTL_PCWD_P0SYSCTL_PCWD_P1SYSCTL_DCGCEMAC_D0SYSCTL_DCGCOWIRE_D0SYSCTL_DCGCLCD_D0SYSCTL_DCGCCCM_D0SYSCTL_DCGCWTIMER_D0SYSCTL_DCGCWTIMER_D1SYSCTL_DCGCWTIMER_D2SYSCTL_DCGCWTIMER_D3SYSCTL_DCGCWTIMER_D4SYSCTL_DCGCWTIMER_D5SYSCTL_DCGCEEPROM_D0SYSCTL_DCGCQEI_D0SYSCTL_DCGCQEI_D1SYSCTL_DCGCPWM_D0SYSCTL_DCGCPWM_D1SYSCTL_DCGCACMP_D0SYSCTL_DCGCADC_D0SYSCTL_DCGCADC_D1SYSCTL_DCGCCAN_D0SYSCTL_DCGCCAN_D1SYSCTL_DCGCEPHY_D0SYSCTL_DCGCUSB_D0SYSCTL_DCGCI2C_D0SYSCTL_DCGCI2C_D1SYSCTL_DCGCI2C_D2SYSCTL_DCGCI2C_D3SYSCTL_DCGCI2C_D4SYSCTL_DCGCI2C_D5SYSCTL_DCGCI2C_D6SYSCTL_DCGCI2C_D7SYSCTL_DCGCI2C_D8SYSCTL_DCGCI2C_D9SYSCTL_DCGCSSI_D0SYSCTL_DCGCSSI_D1SYSCTL_DCGCSSI_D2SYSCTL_DCGCSSI_D3SYSCTL_DCGCUART_D0SYSCTL_DCGCUART_D1SYSCTL_DCGCUART_D2SYSCTL_DCGCUART_D3SYSCTL_DCGCUART_D4SYSCTL_DCGCUART_D5SYSCTL_DCGCUART_D6SYSCTL_DCGCUART_D7SYSCTL_DCGCHIB_D0SYSCTL_DCGCEPI_D0SYSCTL_DCGCDMA_D0SYSCTL_DCGCGPIO_D0SYSCTL_DCGCGPIO_D1SYSCTL_DCGCGPIO_D2SYSCTL_DCGCGPIO_D3SYSCTL_DCGCGPIO_D4SYSCTL_DCGCGPIO_D5SYSCTL_DCGCGPIO_D6SYSCTL_DCGCGPIO_D7SYSCTL_DCGCGPIO_D8SYSCTL_DCGCGPIO_D9SYSCTL_DCGCGPIO_D10SYSCTL_DCGCGPIO_D11SYSCTL_DCGCGPIO_D12SYSCTL_DCGCGPIO_D13SYSCTL_DCGCGPIO_D14SYSCTL_DCGCGPIO_D15SYSCTL_DCGCGPIO_D16SYSCTL_DCGCGPIO_D17SYSCTL_DCGCTIMER_D0SYSCTL_DCGCTIMER_D1SYSCTL_DCGCTIMER_D2SYSCTL_DCGCTIMER_D3SYSCTL_DCGCTIMER_D4SYSCTL_DCGCTIMER_D5SYSCTL_DCGCTIMER_D6SYSCTL_DCGCTIMER_D7SYSCTL_DCGCWD_D0SYSCTL_DCGCWD_D1SYSCTL_SCGCEMAC_S0SYSCTL_SCGCOWIRE_S0SYSCTL_SCGCLCD_S0SYSCTL_SCGCCCM_S0SYSCTL_SCGCWTIMER_S0SYSCTL_SCGCWTIMER_S1SYSCTL_SCGCWTIMER_S2SYSCTL_SCGCWTIMER_S3SYSCTL_SCGCWTIMER_S4SYSCTL_SCGCWTIMER_S5SYSCTL_SCGCEEPROM_S0SYSCTL_SCGCQEI_S0SYSCTL_SCGCQEI_S1SYSCTL_SCGCPWM_S0SYSCTL_SCGCPWM_S1SYSCTL_SCGCACMP_S0SYSCTL_SCGCADC_S0SYSCTL_SCGCADC_S1SYSCTL_SCGCCAN_S0SYSCTL_SCGCCAN_S1SYSCTL_SCGCEPHY_S0SYSCTL_SCGCUSB_S0SYSCTL_SCGCI2C_S0SYSCTL_SCGCI2C_S1SYSCTL_SCGCI2C_S2SYSCTL_SCGCI2C_S3SYSCTL_SCGCI2C_S4SYSCTL_SCGCI2C_S5SYSCTL_SCGCI2C_S6SYSCTL_SCGCI2C_S7SYSCTL_SCGCI2C_S8SYSCTL_SCGCI2C_S9SYSCTL_SCGCSSI_S0SYSCTL_SCGCSSI_S1SYSCTL_SCGCSSI_S2SYSCTL_SCGCSSI_S3SYSCTL_SCGCUART_S0SYSCTL_SCGCUART_S1SYSCTL_SCGCUART_S2SYSCTL_SCGCUART_S3SYSCTL_SCGCUART_S4SYSCTL_SCGCUART_S5SYSCTL_SCGCUART_S6SYSCTL_SCGCUART_S7SYSCTL_SCGCHIB_S0SYSCTL_SCGCEPI_S0SYSCTL_SCGCDMA_S0SYSCTL_SCGCGPIO_S0SYSCTL_SCGCGPIO_S1SYSCTL_SCGCGPIO_S2SYSCTL_SCGCGPIO_S3SYSCTL_SCGCGPIO_S4SYSCTL_SCGCGPIO_S5SYSCTL_SCGCGPIO_S6SYSCTL_SCGCGPIO_S7SYSCTL_SCGCGPIO_S8SYSCTL_SCGCGPIO_S9SYSCTL_SCGCGPIO_S10SYSCTL_SCGCGPIO_S11SYSCTL_SCGCGPIO_S12SYSCTL_SCGCGPIO_S13SYSCTL_SCGCGPIO_S14SYSCTL_SCGCGPIO_S15SYSCTL_SCGCGPIO_S16SYSCTL_SCGCGPIO_S17SYSCTL_SCGCTIMER_S0SYSCTL_SCGCTIMER_S1SYSCTL_SCGCTIMER_S2SYSCTL_SCGCTIMER_S3SYSCTL_SCGCTIMER_S4SYSCTL_SCGCTIMER_S5SYSCTL_SCGCTIMER_S6SYSCTL_SCGCTIMER_S7SYSCTL_SCGCWD_S0SYSCTL_SCGCWD_S1SYSCTL_RCGCEMAC_R0SYSCTL_RCGCOWIRE_R0SYSCTL_RCGCLCD_R0SYSCTL_RCGCCCM_R0SYSCTL_RCGCWTIMER_R0SYSCTL_RCGCWTIMER_R1SYSCTL_RCGCWTIMER_R2SYSCTL_RCGCWTIMER_R3SYSCTL_RCGCWTIMER_R4SYSCTL_RCGCWTIMER_R5SYSCTL_RCGCEEPROM_R0SYSCTL_RCGCQEI_R0SYSCTL_RCGCQEI_R1SYSCTL_RCGCPWM_R0SYSCTL_RCGCPWM_R1SYSCTL_RCGCACMP_R0SYSCTL_RCGCADC_R0SYSCTL_RCGCADC_R1SYSCTL_RCGCCAN_R0SYSCTL_RCGCCAN_R1SYSCTL_RCGCEPHY_R0SYSCTL_RCGCUSB_R0SYSCTL_RCGCI2C_R0SYSCTL_RCGCI2C_R1SYSCTL_RCGCI2C_R2SYSCTL_RCGCI2C_R3SYSCTL_RCGCI2C_R4SYSCTL_RCGCI2C_R5SYSCTL_RCGCI2C_R6SYSCTL_RCGCI2C_R7SYSCTL_RCGCI2C_R8SYSCTL_RCGCI2C_R9SYSCTL_RCGCSSI_R0SYSCTL_RCGCSSI_R1SYSCTL_RCGCSSI_R2SYSCTL_RCGCSSI_R3SYSCTL_RCGCUART_R0SYSCTL_RCGCUART_R1SYSCTL_RCGCUART_R2SYSCTL_RCGCUART_R3SYSCTL_RCGCUART_R4SYSCTL_RCGCUART_R5SYSCTL_RCGCUART_R6SYSCTL_RCGCUART_R7SYSCTL_RCGCHIB_R0SYSCTL_RCGCEPI_R0SYSCTL_RCGCDMA_R0SYSCTL_RCGCGPIO_R0SYSCTL_RCGCGPIO_R1SYSCTL_RCGCGPIO_R2SYSCTL_RCGCGPIO_R3SYSCTL_RCGCGPIO_R4SYSCTL_RCGCGPIO_R5SYSCTL_RCGCGPIO_R6SYSCTL_RCGCGPIO_R7SYSCTL_RCGCGPIO_R8SYSCTL_RCGCGPIO_R9SYSCTL_RCGCGPIO_R10SYSCTL_RCGCGPIO_R11SYSCTL_RCGCGPIO_R12SYSCTL_RCGCGPIO_R13SYSCTL_RCGCGPIO_R14SYSCTL_RCGCGPIO_R15SYSCTL_RCGCGPIO_R16SYSCTL_RCGCGPIO_R17SYSCTL_RCGCTIMER_R0SYSCTL_RCGCTIMER_R1SYSCTL_RCGCTIMER_R2SYSCTL_RCGCTIMER_R3SYSCTL_RCGCTIMER_R4SYSCTL_RCGCTIMER_R5SYSCTL_RCGCTIMER_R6SYSCTL_RCGCTIMER_R7SYSCTL_RCGCWD_R0SYSCTL_RCGCWD_R1SYSCTL_SREMAC_R0SYSCTL_SROWIRE_R0SYSCTL_SRLCD_R0SYSCTL_SRCCM_R0SYSCTL_SRWTIMER_R0SYSCTL_SRWTIMER_R1SYSCTL_SRWTIMER_R2SYSCTL_SRWTIMER_R3SYSCTL_SRWTIMER_R4SYSCTL_SRWTIMER_R5SYSCTL_SREEPROM_R0SYSCTL_SRQEI_R0SYSCTL_SRQEI_R1SYSCTL_SRPWM_R0SYSCTL_SRPWM_R1SYSCTL_SRACMP_R0SYSCTL_SRADC_R0SYSCTL_SRADC_R1SYSCTL_SRCAN_R0SYSCTL_SRCAN_R1SYSCTL_SREPHY_R0SYSCTL_SRUSB_R0SYSCTL_SRI2C_R0SYSCTL_SRI2C_R1SYSCTL_SRI2C_R2SYSCTL_SRI2C_R3SYSCTL_SRI2C_R4SYSCTL_SRI2C_R5SYSCTL_SRI2C_R6SYSCTL_SRI2C_R7SYSCTL_SRI2C_R8SYSCTL_SRI2C_R9SYSCTL_SRSSI_R0SYSCTL_SRSSI_R1SYSCTL_SRSSI_R2SYSCTL_SRSSI_R3SYSCTL_SRUART_R0SYSCTL_SRUART_R1SYSCTL_SRUART_R2SYSCTL_SRUART_R3SYSCTL_SRUART_R4SYSCTL_SRUART_R5SYSCTL_SRUART_R6SYSCTL_SRUART_R7SYSCTL_SRHIB_R0SYSCTL_SREPI_R0SYSCTL_SRDMA_R0SYSCTL_SRGPIO_R0SYSCTL_SRGPIO_R1SYSCTL_SRGPIO_R2SYSCTL_SRGPIO_R3SYSCTL_SRGPIO_R4SYSCTL_SRGPIO_R5SYSCTL_SRGPIO_R6SYSCTL_SRGPIO_R7SYSCTL_SRGPIO_R8SYSCTL_SRGPIO_R9SYSCTL_SRGPIO_R10SYSCTL_SRGPIO_R11SYSCTL_SRGPIO_R12SYSCTL_SRGPIO_R13SYSCTL_SRGPIO_R14SYSCTL_SRGPIO_R15SYSCTL_SRGPIO_R16SYSCTL_SRGPIO_R17SYSCTL_SRTIMER_R0SYSCTL_SRTIMER_R1SYSCTL_SRTIMER_R2SYSCTL_SRTIMER_R3SYSCTL_SRTIMER_R4SYSCTL_SRTIMER_R5SYSCTL_SRTIMER_R6SYSCTL_SRTIMER_R7SYSCTL_SRWD_R0SYSCTL_SRWD_R1SYSCTL_PPHIM_P0SYSCTL_PPEMAC_P0SYSCTL_PPOWIRE_P0SYSCTL_PPLCD_P0SYSCTL_PPCCM_P0SYSCTL_PPRTS_P0SYSCTL_PPWTIMER_P0SYSCTL_PPWTIMER_P1SYSCTL_PPWTIMER_P2SYSCTL_PPWTIMER_P3SYSCTL_PPWTIMER_P4SYSCTL_PPWTIMER_P5SYSCTL_PPEEPROM_P0SYSCTL_PPFAN_P0SYSCTL_PPPECI_P0SYSCTL_PPLPC_P0SYSCTL_PPQEI_P0SYSCTL_PPQEI_P1SYSCTL_PPPWM_P0SYSCTL_PPPWM_P1SYSCTL_PPACMP_P0SYSCTL_PPADC_P0SYSCTL_PPADC_P1SYSCTL_PPCAN_P0SYSCTL_PPCAN_P1SYSCTL_PPEPHY_P0SYSCTL_PPUSB_P0SYSCTL_PPI2C_P0SYSCTL_PPI2C_P1SYSCTL_PPI2C_P2SYSCTL_PPI2C_P3SYSCTL_PPI2C_P4SYSCTL_PPI2C_P5SYSCTL_PPI2C_P6SYSCTL_PPI2C_P7SYSCTL_PPI2C_P8SYSCTL_PPI2C_P9SYSCTL_PPSSI_P0SYSCTL_PPSSI_P1SYSCTL_PPSSI_P2SYSCTL_PPSSI_P3SYSCTL_PPUART_P0SYSCTL_PPUART_P1SYSCTL_PPUART_P2SYSCTL_PPUART_P3SYSCTL_PPUART_P4SYSCTL_PPUART_P5SYSCTL_PPUART_P6SYSCTL_PPUART_P7SYSCTL_PPHIB_P0SYSCTL_PPEPI_P0SYSCTL_PPDMA_P0SYSCTL_PPGPIO_P0SYSCTL_PPGPIO_P1SYSCTL_PPGPIO_P2SYSCTL_PPGPIO_P3SYSCTL_PPGPIO_P4SYSCTL_PPGPIO_P5SYSCTL_PPGPIO_P6SYSCTL_PPGPIO_P7SYSCTL_PPGPIO_P8SYSCTL_PPGPIO_P9SYSCTL_PPGPIO_P10SYSCTL_PPGPIO_P11SYSCTL_PPGPIO_P12SYSCTL_PPGPIO_P13SYSCTL_PPGPIO_P14SYSCTL_PPGPIO_P15SYSCTL_PPGPIO_P16SYSCTL_PPGPIO_P17SYSCTL_PPTIMER_P0SYSCTL_PPTIMER_P1SYSCTL_PPTIMER_P2SYSCTL_PPTIMER_P3SYSCTL_PPTIMER_P4SYSCTL_PPTIMER_P5SYSCTL_PPTIMER_P6SYSCTL_PPTIMER_P7SYSCTL_PPWD_P0SYSCTL_PPWD_P1SYSCTL_LCDMPC_PWRCTL_ONSYSCTL_LCDMPC_PWRCTL_OFFSYSCTL_LCDMPC_PWRCTL_MSYSCTL_EMACMPC_PWRCTL_ONSYSCTL_EMACMPC_PWRCTL_OFFSYSCTL_EMACMPC_PWRCTL_MSYSCTL_EMACPDS_PWRSTAT_ONSYSCTL_EMACPDS_PWRSTAT_OFFSYSCTL_EMACPDS_PWRSTAT_MSYSCTL_EMACPDS_MEMSTAT_ONSYSCTL_EMACPDS_MEMSTAT_OFFSYSCTL_EMACPDS_MEMSTAT_MSYSCTL_USBMPC_PWRCTL_ONSYSCTL_USBMPC_PWRCTL_RETAINSYSCTL_USBMPC_PWRCTL_OFFSYSCTL_USBMPC_PWRCTL_MSYSCTL_USBPDS_PWRSTAT_ONSYSCTL_USBPDS_PWRSTAT_OFFSYSCTL_USBPDS_PWRSTAT_MSYSCTL_USBPDS_MEMSTAT_ONSYSCTL_USBPDS_MEMSTAT_RETAINSYSCTL_USBPDS_MEMSTAT_OFFSYSCTL_USBPDS_MEMSTAT_MSYSCTL_HSSR_CDOFF_SSYSCTL_HSSR_KEY_SSYSCTL_HSSR_CDOFF_M0x00FFFFFFSYSCTL_HSSR_KEY_M0xFF000000SYSCTL_RESBEHAVCTL_EXTRES_PORSYSCTL_RESBEHAVCTL_EXTRES_SYSRSTSYSCTL_RESBEHAVCTL_EXTRES_MSYSCTL_RESBEHAVCTL_BOR_PORSYSCTL_RESBEHAVCTL_BOR_SYSRSTSYSCTL_RESBEHAVCTL_BOR_MSYSCTL_RESBEHAVCTL_WDOG0_PORSYSCTL_RESBEHAVCTL_WDOG0_SYSRSTSYSCTL_RESBEHAVCTL_WDOG0_MSYSCTL_RESBEHAVCTL_WDOG1_POR0x000000C0SYSCTL_RESBEHAVCTL_WDOG1_SYSRSTSYSCTL_RESBEHAVCTL_WDOG1_MSYSCTL_LDODPCTL_VLDO_1_35V0x0000001BSYSCTL_LDODPCTL_VLDO_1_30V0x0000001ASYSCTL_LDODPCTL_VLDO_1_25V0x00000019SYSCTL_LDODPCTL_VLDO_1_20VSYSCTL_LDODPCTL_VLDO_1_15V0x00000017SYSCTL_LDODPCTL_VLDO_1_10V0x00000016SYSCTL_LDODPCTL_VLDO_1_05V0x00000015SYSCTL_LDODPCTL_VLDO_1_00VSYSCTL_LDODPCTL_VLDO_0_95V0x00000013SYSCTL_LDODPCTL_VLDO_0_90V0x00000012SYSCTL_LDODPCTL_VLDO_M0x000000FFSYSCTL_LDODPCTL_VADJENSYSCTL_LDOSPCTL_VLDO_1_20VSYSCTL_LDOSPCTL_VLDO_1_15VSYSCTL_LDOSPCTL_VLDO_1_10VSYSCTL_LDOSPCTL_VLDO_1_05VSYSCTL_LDOSPCTL_VLDO_1_00VSYSCTL_LDOSPCTL_VLDO_0_95VSYSCTL_LDOSPCTL_VLDO_0_90VSYSCTL_LDOSPCTL_VLDO_MSYSCTL_LDOSPCTL_VADJENSYSCTL_NVMSTAT_FWBSYSCTL_DC9_ADC0DC0SYSCTL_DC9_ADC0DC1SYSCTL_DC9_ADC0DC2SYSCTL_DC9_ADC0DC3SYSCTL_DC9_ADC0DC4SYSCTL_DC9_ADC0DC5SYSCTL_DC9_ADC0DC6SYSCTL_DC9_ADC0DC7SYSCTL_DC9_ADC1DC0SYSCTL_DC9_ADC1DC1SYSCTL_DC9_ADC1DC2SYSCTL_DC9_ADC1DC3SYSCTL_DC9_ADC1DC4SYSCTL_DC9_ADC1DC5SYSCTL_DC9_ADC1DC6SYSCTL_DC9_ADC1DC7SYSCTL_DSLPPWRCFG_SRAMPM_LPSYSCTL_DSLPPWRCFG_SRAMPM_SBYSYSCTL_DSLPPWRCFG_SRAMPM_NRMSYSCTL_DSLPPWRCFG_SRAMPM_MSYSCTL_DSLPPWRCFG_FLASHPM_SLPSYSCTL_DSLPPWRCFG_FLASHPM_NRMSYSCTL_DSLPPWRCFG_FLASHPM_MSYSCTL_DSLPPWRCFG_TSPDSYSCTL_DSLPPWRCFG_LDOSMSYSCTL_SLPPWRCFG_SRAMPM_LPSYSCTL_SLPPWRCFG_SRAMPM_SBYSYSCTL_SLPPWRCFG_SRAMPM_NRMSYSCTL_SLPPWRCFG_SRAMPM_MSYSCTL_SLPPWRCFG_FLASHPM_SLPSYSCTL_SLPPWRCFG_FLASHPM_NRMSYSCTL_SLPPWRCFG_FLASHPM_MSYSCTL_PLLSTAT_LOCKSYSCTL_PLLFREQ1_N_SSYSCTL_PLLFREQ1_Q_SSYSCTL_PLLFREQ1_N_M0x0000001FSYSCTL_PLLFREQ1_Q_M0x00001F00SYSCTL_PLLFREQ0_MINT_SSYSCTL_PLLFREQ0_MFRAC_SSYSCTL_PLLFREQ0_MINT_M0x000003FFSYSCTL_PLLFREQ0_MFRAC_M0x000FFC00SYSCTL_PLLFREQ0_PLLPWRSYSCTL_PIOSCSTAT_CT_SSYSCTL_PIOSCSTAT_DT_SSYSCTL_PIOSCSTAT_CT_M0x0000007FSYSCTL_PIOSCSTAT_CRFAILSYSCTL_PIOSCSTAT_CRPASSSYSCTL_PIOSCSTAT_CRNONESYSCTL_PIOSCSTAT_CR_MSYSCTL_PIOSCSTAT_DT_M0x007F0000SYSCTL_PIOSCCAL_UT_SSYSCTL_PIOSCCAL_UT_MSYSCTL_PIOSCCAL_UPDATESYSCTL_PIOSCCAL_CALSYSCTL_PIOSCCAL_UTENSYSCTL_SYSPROP_FPUSYSCTL_DIVSCLK_DIV_SSYSCTL_DIVSCLK_DIV_MSYSCTL_DIVSCLK_SRC_MOSCSYSCTL_DIVSCLK_SRC_PIOSCSYSCTL_DIVSCLK_SRC_SYSCLKSYSCTL_DIVSCLK_SRC_MSYSCTL_DIVSCLK_ENSYSCTL_DSCLKCFG_DSSYSDIV_SSYSCTL_DSCLKCFG_DSSYSDIV_MSYSCTL_DSCLKCFG_DSOSCSRC_RTCSYSCTL_DSCLKCFG_DSOSCSRC_MOSCSYSCTL_DSCLKCFG_DSOSCSRC_LFIOSCSYSCTL_DSCLKCFG_DSOSCSRC_PIOSCSYSCTL_DSCLKCFG_DSOSCSRC_MSYSCTL_DSCLKCFG_MOSCDPDSYSCTL_DSCLKCFG_PIOSCPDSYSCTL_DSLPCLKCFG_D_SSYSCTL_DSLPCLKCFG_PIOSCPDSYSCTL_DSLPCLKCFG_O_32SYSCTL_DSLPCLKCFG_O_30SYSCTL_DSLPCLKCFG_O_IOSYSCTL_DSLPCLKCFG_O_IGNSYSCTL_DSLPCLKCFG_O_MSYSCTL_DSLPCLKCFG_D_M0x1F800000SYSCTL_ALTCLKCFG_ALTCLK_LFIOSCSYSCTL_ALTCLKCFG_ALTCLK_RTCOSCSYSCTL_ALTCLKCFG_ALTCLK_PIOSCSYSCTL_ALTCLKCFG_ALTCLK_MSYSCTL_DCGC2_GPIOASYSCTL_DCGC2_GPIOBSYSCTL_DCGC2_GPIOCSYSCTL_DCGC2_GPIODSYSCTL_DCGC2_GPIOESYSCTL_DCGC2_GPIOFSYSCTL_DCGC2_GPIOGSYSCTL_DCGC2_GPIOHSYSCTL_DCGC2_GPIOJSYSCTL_DCGC2_UDMASYSCTL_DCGC2_USB0SYSCTL_DCGC1_UART0SYSCTL_DCGC1_UART1SYSCTL_DCGC1_UART2SYSCTL_DCGC1_SSI0SYSCTL_DCGC1_SSI1SYSCTL_DCGC1_QEI0SYSCTL_DCGC1_QEI1SYSCTL_DCGC1_I2C0SYSCTL_DCGC1_I2C1SYSCTL_DCGC1_TIMER0SYSCTL_DCGC1_TIMER1SYSCTL_DCGC1_TIMER2SYSCTL_DCGC1_TIMER3SYSCTL_DCGC1_COMP0SYSCTL_DCGC1_COMP1SYSCTL_DCGC1_COMP2SYSCTL_DCGC0_WDT0SYSCTL_DCGC0_HIBSYSCTL_DCGC0_ADC0SYSCTL_DCGC0_ADC1SYSCTL_DCGC0_PWM0SYSCTL_DCGC0_CAN0SYSCTL_DCGC0_CAN1SYSCTL_DCGC0_WDT1SYSCTL_SCGC2_GPIOASYSCTL_SCGC2_GPIOBSYSCTL_SCGC2_GPIOCSYSCTL_SCGC2_GPIODSYSCTL_SCGC2_GPIOESYSCTL_SCGC2_GPIOFSYSCTL_SCGC2_GPIOGSYSCTL_SCGC2_GPIOHSYSCTL_SCGC2_GPIOJSYSCTL_SCGC2_UDMASYSCTL_SCGC2_USB0SYSCTL_SCGC1_UART0SYSCTL_SCGC1_UART1SYSCTL_SCGC1_UART2SYSCTL_SCGC1_SSI0SYSCTL_SCGC1_SSI1SYSCTL_SCGC1_QEI0SYSCTL_SCGC1_QEI1SYSCTL_SCGC1_I2C0SYSCTL_SCGC1_I2C1SYSCTL_SCGC1_TIMER0SYSCTL_SCGC1_TIMER1SYSCTL_SCGC1_TIMER2SYSCTL_SCGC1_TIMER3SYSCTL_SCGC1_COMP0SYSCTL_SCGC1_COMP1SYSCTL_SCGC1_COMP2SYSCTL_SCGC0_WDT0SYSCTL_SCGC0_HIBSYSCTL_SCGC0_ADCSPD_MSYSCTL_SCGC0_ADC0SYSCTL_SCGC0_ADC1SYSCTL_SCGC0_PWM0SYSCTL_SCGC0_CAN0SYSCTL_SCGC0_CAN1SYSCTL_SCGC0_WDT1SYSCTL_RCGC2_GPIOASYSCTL_RCGC2_GPIOBSYSCTL_RCGC2_GPIOCSYSCTL_RCGC2_GPIODSYSCTL_RCGC2_GPIOESYSCTL_RCGC2_GPIOFSYSCTL_RCGC2_GPIOGSYSCTL_RCGC2_GPIOHSYSCTL_RCGC2_GPIOJSYSCTL_RCGC2_UDMASYSCTL_RCGC2_USB0SYSCTL_RCGC1_UART0SYSCTL_RCGC1_UART1SYSCTL_RCGC1_UART2SYSCTL_RCGC1_SSI0SYSCTL_RCGC1_SSI1SYSCTL_RCGC1_QEI0SYSCTL_RCGC1_QEI1SYSCTL_RCGC1_I2C0SYSCTL_RCGC1_I2C1SYSCTL_RCGC1_TIMER0SYSCTL_RCGC1_TIMER1SYSCTL_RCGC1_TIMER2SYSCTL_RCGC1_TIMER3SYSCTL_RCGC1_COMP0SYSCTL_RCGC1_COMP1SYSCTL_RCGC1_COMP2SYSCTL_RCGC0_WDT0SYSCTL_RCGC0_HIBSYSCTL_RCGC0_ADC0SPD_1MSYSCTL_RCGC0_ADC0SPD_500KSYSCTL_RCGC0_ADC0SPD_250KSYSCTL_RCGC0_ADC0SPD_125KSYSCTL_RCGC0_ADC0SPD_MSYSCTL_RCGC0_ADC1SPD_1MSYSCTL_RCGC0_ADC1SPD_500KSYSCTL_RCGC0_ADC1SPD_250KSYSCTL_RCGC0_ADC1SPD_125KSYSCTL_RCGC0_ADC1SPD_MSYSCTL_RCGC0_ADC0SYSCTL_RCGC0_ADC1SYSCTL_RCGC0_PWM0SYSCTL_RCGC0_CAN0SYSCTL_RCGC0_CAN1SYSCTL_RCGC0_WDT1SYSCTL_MEMTIM0_FWS_SSYSCTL_MEMTIM0_EWS_SSYSCTL_MEMTIM0_FWS_MSYSCTL_MEMTIM0_FBCESYSCTL_MEMTIM0_FBCHT_4_5SYSCTL_MEMTIM0_FBCHT_40x000001C0SYSCTL_MEMTIM0_FBCHT_3_50x00000180SYSCTL_MEMTIM0_FBCHT_30x00000140SYSCTL_MEMTIM0_FBCHT_2_5SYSCTL_MEMTIM0_FBCHT_2SYSCTL_MEMTIM0_FBCHT_1_5SYSCTL_MEMTIM0_FBCHT_1SYSCTL_MEMTIM0_FBCHT_0_5SYSCTL_MEMTIM0_FBCHT_M0x000003C0SYSCTL_MEMTIM0_EWS_MSYSCTL_MEMTIM0_MB10x00100010SYSCTL_MEMTIM0_EBCESYSCTL_MEMTIM0_EBCHT_4_5SYSCTL_MEMTIM0_EBCHT_40x01C00000SYSCTL_MEMTIM0_EBCHT_3_50x01800000SYSCTL_MEMTIM0_EBCHT_30x01400000SYSCTL_MEMTIM0_EBCHT_2_5SYSCTL_MEMTIM0_EBCHT_20x00C00000SYSCTL_MEMTIM0_EBCHT_1_5SYSCTL_MEMTIM0_EBCHT_1SYSCTL_MEMTIM0_EBCHT_0_5SYSCTL_MEMTIM0_EBCHT_M0x03C00000SYSCTL_RSCLKCFG_PSYSDIV_SSYSCTL_RSCLKCFG_OSYSDIV_SSYSCTL_RSCLKCFG_PSYSDIV_MSYSCTL_RSCLKCFG_OSYSDIV_MSYSCTL_RSCLKCFG_OSCSRC_RTCSYSCTL_RSCLKCFG_OSCSRC_MOSCSYSCTL_RSCLKCFG_OSCSRC_LFIOSCSYSCTL_RSCLKCFG_OSCSRC_PIOSCSYSCTL_RSCLKCFG_OSCSRC_MSYSCTL_RSCLKCFG_PLLSRC_MOSC0x03000000SYSCTL_RSCLKCFG_PLLSRC_PIOSCSYSCTL_RSCLKCFG_PLLSRC_MSYSCTL_RSCLKCFG_USEPLLSYSCTL_RSCLKCFG_ACGSYSCTL_RSCLKCFG_NEWFREQSYSCTL_RSCLKCFG_MEMTIMUSYSCTL_MOSCCTL_CVALSYSCTL_MOSCCTL_MOSCIMSYSCTL_MOSCCTL_NOXTALSYSCTL_MOSCCTL_PWRDNSYSCTL_MOSCCTL_OSCRNGSYSCTL_RCC2_SYSDIV2_SSYSCTL_RCC2_OSCSRC2_32SYSCTL_RCC2_OSCSRC2_30SYSCTL_RCC2_OSCSRC2_IO4SYSCTL_RCC2_OSCSRC2_IOSYSCTL_RCC2_OSCSRC2_MOSYSCTL_RCC2_OSCSRC2_MSYSCTL_RCC2_BYPASS2SYSCTL_RCC2_PWRDN2SYSCTL_RCC2_USBPWRDNSYSCTL_RCC2_SYSDIV2LSBSYSCTL_RCC2_SYSDIV2_MSYSCTL_RCC2_DIV400SYSCTL_RCC2_USERCC2SYSCTL_GPIOHBCTL_PORTASYSCTL_GPIOHBCTL_PORTBSYSCTL_GPIOHBCTL_PORTCSYSCTL_GPIOHBCTL_PORTDSYSCTL_GPIOHBCTL_PORTESYSCTL_GPIOHBCTL_PORTFSYSCTL_GPIOHBCTL_PORTGSYSCTL_GPIOHBCTL_PORTHSYSCTL_GPIOHBCTL_PORTJSYSCTL_NMIC_EXTERNALSYSCTL_NMIC_POWERSYSCTL_NMIC_WDT0SYSCTL_NMIC_WDT1SYSCTL_NMIC_TAMPERSYSCTL_NMIC_MOSCFAILSYSCTL_RCC_XTAL_SSYSCTL_RCC_SYSDIV_SSYSCTL_RCC_MOSCDISSYSCTL_RCC_OSCSRC_30SYSCTL_RCC_OSCSRC_INT4SYSCTL_RCC_OSCSRC_INTSYSCTL_RCC_OSCSRC_MAINSYSCTL_RCC_OSCSRC_MSYSCTL_RCC_XTAL_25MHZ0x00000680SYSCTL_RCC_XTAL_24MHZ0x00000640SYSCTL_RCC_XTAL_20MHZSYSCTL_RCC_XTAL_18MHZ0x000005C0SYSCTL_RCC_XTAL_16_3MHZ0x00000580SYSCTL_RCC_XTAL_16MHZ0x00000540SYSCTL_RCC_XTAL_14_3MHZSYSCTL_RCC_XTAL_13_5MHZ0x000004C0SYSCTL_RCC_XTAL_12_2MHZ0x00000480SYSCTL_RCC_XTAL_12MHZ0x00000440SYSCTL_RCC_XTAL_10MHZSYSCTL_RCC_XTAL_8_19MHZSYSCTL_RCC_XTAL_8MHZ0x00000380SYSCTL_RCC_XTAL_7_37MHZ0x00000340SYSCTL_RCC_XTAL_6_14MHZSYSCTL_RCC_XTAL_6MHZ0x000002C0SYSCTL_RCC_XTAL_5_12MHZ0x00000280SYSCTL_RCC_XTAL_5MHZ0x00000240SYSCTL_RCC_XTAL_4_91MHZSYSCTL_RCC_XTAL_4_09MHZSYSCTL_RCC_XTAL_4MHZSYSCTL_RCC_XTAL_M0x000007C0SYSCTL_RCC_BYPASSSYSCTL_RCC_PWRDNSYSCTL_RCC_PWMDIV_64SYSCTL_RCC_PWMDIV_32SYSCTL_RCC_PWMDIV_160x00060000SYSCTL_RCC_PWMDIV_8SYSCTL_RCC_PWMDIV_4SYSCTL_RCC_PWMDIV_2SYSCTL_RCC_PWMDIV_M0x000E0000SYSCTL_RCC_USEPWMDIVSYSCTL_RCC_USESYSDIVSYSCTL_RCC_SYSDIV_M0x07800000SYSCTL_RCC_ACGSYSCTL_PWRTC_VDD_UBORSYSCTL_PWRTC_VDDA_UBORSYSCTL_RESC_EXTSYSCTL_RESC_PORSYSCTL_RESC_BORSYSCTL_RESC_WDT0SYSCTL_RESC_SWSYSCTL_RESC_WDT1SYSCTL_RESC_HSSRSYSCTL_RESC_MOSCFAILSYSCTL_MISC_BOR1MISSYSCTL_MISC_BORMISSYSCTL_MISC_MOFMISSYSCTL_MISC_PLLLMISSYSCTL_MISC_USBPLLLMISSYSCTL_MISC_MOSCPUPMISSYSCTL_MISC_VDDAMISSYSCTL_MISC_BOR0MISSYSCTL_IMC_BOR1IMSYSCTL_IMC_BORIMSYSCTL_IMC_MOFIMSYSCTL_IMC_PLLLIMSYSCTL_IMC_USBPLLLIMSYSCTL_IMC_MOSCPUPIMSYSCTL_IMC_VDDAIMSYSCTL_IMC_BOR0IMSYSCTL_RIS_BORRISSYSCTL_RIS_BOR1RISSYSCTL_RIS_MOFRISSYSCTL_RIS_PLLLRISSYSCTL_RIS_USBPLLLRISSYSCTL_RIS_MOSCPUPRISSYSCTL_RIS_VDDARISSYSCTL_RIS_BOR0RISSYSCTL_SRCR2_GPIOASYSCTL_SRCR2_GPIOBSYSCTL_SRCR2_GPIOCSYSCTL_SRCR2_GPIODSYSCTL_SRCR2_GPIOESYSCTL_SRCR2_GPIOFSYSCTL_SRCR2_GPIOGSYSCTL_SRCR2_GPIOHSYSCTL_SRCR2_GPIOJSYSCTL_SRCR2_UDMASYSCTL_SRCR2_USB0SYSCTL_SRCR1_UART0SYSCTL_SRCR1_UART1SYSCTL_SRCR1_UART2SYSCTL_SRCR1_SSI0SYSCTL_SRCR1_SSI1SYSCTL_SRCR1_QEI0SYSCTL_SRCR1_QEI1SYSCTL_SRCR1_I2C0SYSCTL_SRCR1_I2C1SYSCTL_SRCR1_TIMER0SYSCTL_SRCR1_TIMER1SYSCTL_SRCR1_TIMER2SYSCTL_SRCR1_TIMER3SYSCTL_SRCR1_COMP0SYSCTL_SRCR1_COMP1SYSCTL_SRCR1_COMP2SYSCTL_SRCR0_WDT0SYSCTL_SRCR0_HIBSYSCTL_SRCR0_ADC0SYSCTL_SRCR0_ADC1SYSCTL_SRCR0_PWM0SYSCTL_SRCR0_CAN0SYSCTL_SRCR0_CAN1SYSCTL_SRCR0_WDT1SYSCTL_PTBOCTL_VDD_UBOR_RSTSYSCTL_PTBOCTL_VDD_UBOR_NMISYSCTL_PTBOCTL_VDD_UBOR_SYSINTSYSCTL_PTBOCTL_VDD_UBOR_NONESYSCTL_PTBOCTL_VDD_UBOR_MSYSCTL_PTBOCTL_VDDA_UBOR_RSTSYSCTL_PTBOCTL_VDDA_UBOR_NMISYSCTL_PTBOCTL_VDDA_UBOR_SYSINTSYSCTL_PTBOCTL_VDDA_UBOR_NONESYSCTL_PTBOCTL_VDDA_UBOR_MSYSCTL_PBORCTL_BOR1SYSCTL_PBORCTL_BOR0SYSCTL_DC8_ADC0AIN0SYSCTL_DC8_ADC0AIN1SYSCTL_DC8_ADC0AIN2SYSCTL_DC8_ADC0AIN3SYSCTL_DC8_ADC0AIN4SYSCTL_DC8_ADC0AIN5SYSCTL_DC8_ADC0AIN6SYSCTL_DC8_ADC0AIN7SYSCTL_DC8_ADC0AIN8SYSCTL_DC8_ADC0AIN9SYSCTL_DC8_ADC0AIN10SYSCTL_DC8_ADC0AIN11SYSCTL_DC8_ADC0AIN12SYSCTL_DC8_ADC0AIN13SYSCTL_DC8_ADC0AIN14SYSCTL_DC8_ADC0AIN15SYSCTL_DC8_ADC1AIN0SYSCTL_DC8_ADC1AIN1SYSCTL_DC8_ADC1AIN2SYSCTL_DC8_ADC1AIN3SYSCTL_DC8_ADC1AIN4SYSCTL_DC8_ADC1AIN5SYSCTL_DC8_ADC1AIN6SYSCTL_DC8_ADC1AIN7SYSCTL_DC8_ADC1AIN8SYSCTL_DC8_ADC1AIN9SYSCTL_DC8_ADC1AIN10SYSCTL_DC8_ADC1AIN11SYSCTL_DC8_ADC1AIN12SYSCTL_DC8_ADC1AIN13SYSCTL_DC8_ADC1AIN14SYSCTL_DC8_ADC1AIN15SYSCTL_DC7_DMACH0SYSCTL_DC7_DMACH1SYSCTL_DC7_DMACH2SYSCTL_DC7_DMACH3SYSCTL_DC7_DMACH4SYSCTL_DC7_DMACH5SYSCTL_DC7_DMACH6SYSCTL_DC7_DMACH7SYSCTL_DC7_DMACH8SYSCTL_DC7_DMACH9SYSCTL_DC7_DMACH10SYSCTL_DC7_DMACH11SYSCTL_DC7_DMACH12SYSCTL_DC7_DMACH13SYSCTL_DC7_DMACH14SYSCTL_DC7_DMACH15SYSCTL_DC7_DMACH16SYSCTL_DC7_DMACH17SYSCTL_DC7_DMACH18SYSCTL_DC7_DMACH19SYSCTL_DC7_DMACH20SYSCTL_DC7_DMACH21SYSCTL_DC7_DMACH22SYSCTL_DC7_DMACH23SYSCTL_DC7_DMACH24SYSCTL_DC7_DMACH25SYSCTL_DC7_DMACH26SYSCTL_DC7_DMACH27SYSCTL_DC7_DMACH28SYSCTL_DC7_DMACH29SYSCTL_DC7_DMACH30SYSCTL_DC6_USB0_OTGSYSCTL_DC6_USB0_HOSTDEVSYSCTL_DC6_USB0_DEVSYSCTL_DC6_USB0_MSYSCTL_DC6_USB0PHYSYSCTL_DC5_PWM0SYSCTL_DC5_PWM1SYSCTL_DC5_PWM2SYSCTL_DC5_PWM3SYSCTL_DC5_PWM4SYSCTL_DC5_PWM5SYSCTL_DC5_PWM6SYSCTL_DC5_PWM7SYSCTL_DC5_PWMESYNCSYSCTL_DC5_PWMEFLTSYSCTL_DC5_PWMFAULT0SYSCTL_DC5_PWMFAULT1SYSCTL_DC5_PWMFAULT2SYSCTL_DC5_PWMFAULT3SYSCTL_DC4_GPIOASYSCTL_DC4_GPIOBSYSCTL_DC4_GPIOCSYSCTL_DC4_GPIODSYSCTL_DC4_GPIOESYSCTL_DC4_GPIOFSYSCTL_DC4_GPIOGSYSCTL_DC4_GPIOHSYSCTL_DC4_GPIOJSYSCTL_DC4_ROMSYSCTL_DC4_UDMASYSCTL_DC4_CCP6SYSCTL_DC4_CCP7SYSCTL_DC4_PICALSYSCTL_DC4_E1588SYSCTL_DC4_EMAC0SYSCTL_DC4_EPHY0SYSCTL_DC3_PWM0SYSCTL_DC3_PWM1SYSCTL_DC3_PWM2SYSCTL_DC3_PWM3SYSCTL_DC3_PWM4SYSCTL_DC3_PWM5SYSCTL_DC3_C0MINUSSYSCTL_DC3_C0PLUSSYSCTL_DC3_C0OSYSCTL_DC3_C1MINUSSYSCTL_DC3_C1PLUSSYSCTL_DC3_C1OSYSCTL_DC3_C2MINUSSYSCTL_DC3_C2PLUSSYSCTL_DC3_C2OSYSCTL_DC3_PWMFAULTSYSCTL_DC3_ADC0AIN0SYSCTL_DC3_ADC0AIN1SYSCTL_DC3_ADC0AIN2SYSCTL_DC3_ADC0AIN3SYSCTL_DC3_ADC0AIN4SYSCTL_DC3_ADC0AIN5SYSCTL_DC3_ADC0AIN6SYSCTL_DC3_ADC0AIN7SYSCTL_DC3_CCP0SYSCTL_DC3_CCP1SYSCTL_DC3_CCP2SYSCTL_DC3_CCP3SYSCTL_DC3_CCP4SYSCTL_DC3_CCP5SYSCTL_DC3_32KHZSYSCTL_DC2_UART0SYSCTL_DC2_UART1SYSCTL_DC2_UART2SYSCTL_DC2_SSI0SYSCTL_DC2_SSI1SYSCTL_DC2_QEI0SYSCTL_DC2_QEI1SYSCTL_DC2_I2C0SYSCTL_DC2_I2C0HSSYSCTL_DC2_I2C1SYSCTL_DC2_I2C1HSSYSCTL_DC2_TIMER0SYSCTL_DC2_TIMER1SYSCTL_DC2_TIMER2SYSCTL_DC2_TIMER3SYSCTL_DC2_COMP0SYSCTL_DC2_COMP1SYSCTL_DC2_COMP2SYSCTL_DC2_I2S0SYSCTL_DC2_EPI0SYSCTL_DC1_JTAGSYSCTL_DC1_SWDSYSCTL_DC1_SWOSYSCTL_DC1_WDT0SYSCTL_DC1_PLLSYSCTL_DC1_TEMPSYSCTL_DC1_HIBSYSCTL_DC1_MPUSYSCTL_DC1_ADC0SPD_1MSYSCTL_DC1_ADC0SPD_500KSYSCTL_DC1_ADC0SPD_250KSYSCTL_DC1_ADC0SPD_125KSYSCTL_DC1_ADC0SPD_MSYSCTL_DC1_ADC1SPD_1MSYSCTL_DC1_ADC1SPD_500KSYSCTL_DC1_ADC1SPD_250KSYSCTL_DC1_ADC1SPD_125KSYSCTL_DC1_ADC1SPD_MSYSCTL_DC1_MINSYSDIV_20SYSCTL_DC1_MINSYSDIV_25SYSCTL_DC1_MINSYSDIV_40SYSCTL_DC1_MINSYSDIV_50SYSCTL_DC1_MINSYSDIV_80SYSCTL_DC1_MINSYSDIV_MSYSCTL_DC1_ADC0SYSCTL_DC1_ADC1SYSCTL_DC1_PWM0SYSCTL_DC1_PWM1SYSCTL_DC1_CAN0SYSCTL_DC1_CAN1SYSCTL_DC1_WDT1SYSCTL_DC0_FLASHSZ_256KSYSCTL_DC0_FLASHSZ_192K0x0000005FSYSCTL_DC0_FLASHSZ_128K0x0000003FSYSCTL_DC0_FLASHSZ_96KB0x0000002FSYSCTL_DC0_FLASHSZ_64KBSYSCTL_DC0_FLASHSZ_32KBSYSCTL_DC0_FLASHSZ_16KBSYSCTL_DC0_FLASHSZ_8KBSYSCTL_DC0_FLASHSZ_M0x0000FFFFSYSCTL_DC0_SRAMSZ_32KBSYSCTL_DC0_SRAMSZ_24KB0x005F0000SYSCTL_DC0_SRAMSZ_20KB0x004F0000SYSCTL_DC0_SRAMSZ_16KB0x003F0000SYSCTL_DC0_SRAMSZ_12KB0x002F0000SYSCTL_DC0_SRAMSZ_8KB0x001F0000SYSCTL_DC0_SRAMSZ_6KB0x00170000SYSCTL_DC0_SRAMSZ_4KBSYSCTL_DC0_SRAMSZ_2KB0x00070000SYSCTL_DC0_SRAMSZ_M0xFFFF0000SYSCTL_DID1_QUAL_FQSYSCTL_DID1_QUAL_PPSYSCTL_DID1_QUAL_ESSYSCTL_DID1_QUAL_MSYSCTL_DID1_ROHSSYSCTL_DID1_PKG_BGASYSCTL_DID1_PKG_QFPSYSCTL_DID1_PKG_MSYSCTL_DID1_TEMP_IESYSCTL_DID1_TEMP_ESYSCTL_DID1_TEMP_ISYSCTL_DID1_TEMP_CSYSCTL_DID1_TEMP_MSYSCTL_DID1_PINCNT_1280x0000C000SYSCTL_DID1_PINCNT_1570x0000A000SYSCTL_DID1_PINCNT_144SYSCTL_DID1_PINCNT_64SYSCTL_DID1_PINCNT_100SYSCTL_DID1_PINCNT_MSYSCTL_DID1_PRTNO_TM4C129XNCZAD0x00320000SYSCTL_DID1_PRTNO_TM4C129XKCZAD0x00370000SYSCTL_DID1_PRTNO_TM4C129LNCZADSYSCTL_DID1_PRTNO_TM4C129ENCZADSYSCTL_DID1_PRTNO_TM4C129ENCPDT0x002D0000SYSCTL_DID1_PRTNO_TM4C129EKCPDT0x00350000SYSCTL_DID1_PRTNO_TM4C129DNCZAD0x00290000SYSCTL_DID1_PRTNO_TM4C129DNCPDT0x00270000SYSCTL_DID1_PRTNO_TM4C129CNCZAD0x00260000SYSCTL_DID1_PRTNO_TM4C129CNCPDT0x00240000SYSCTL_DID1_PRTNO_TM4C1299NCZAD0x00230000SYSCTL_DID1_PRTNO_TM4C1299KCZAD0x00360000SYSCTL_DID1_PRTNO_TM4C1297NCZAD0x00220000SYSCTL_DID1_PRTNO_TM4C1294NCZAD0x00210000SYSCTL_DID1_PRTNO_TM4C1294NCPDTSYSCTL_DID1_PRTNO_TM4C1294KCPDT0x00340000SYSCTL_DID1_PRTNO_TM4C1292NCZAD0x001E0000SYSCTL_DID1_PRTNO_TM4C1292NCPDT0x001C0000SYSCTL_DID1_PRTNO_TM4C1290NCZAD0x001B0000SYSCTL_DID1_PRTNO_TM4C1290NCPDT0x00190000SYSCTL_DID1_PRTNO_TM4C123GH6ZRB0x00E30000SYSCTL_DID1_PRTNO_TM4C123GH6PZ0x00C10000SYSCTL_DID1_PRTNO_TM4C123GH6PM0x00A10000SYSCTL_DID1_PRTNO_TM4C123GH6PGE0x00C50000SYSCTL_DID1_PRTNO_TM4C123GE6PZSYSCTL_DID1_PRTNO_TM4C123GE6PM0x00A00000SYSCTL_DID1_PRTNO_TM4C123FH6PM0x00B10000SYSCTL_DID1_PRTNO_TM4C123FE6PM0x00B00000SYSCTL_DID1_PRTNO_TM4C123BH6ZRB0x00E90000SYSCTL_DID1_PRTNO_TM4C123BH6PZ0x00C40000SYSCTL_DID1_PRTNO_TM4C123BH6PM0x00730000SYSCTL_DID1_PRTNO_TM4C123BH6PGE0x00C60000SYSCTL_DID1_PRTNO_TM4C123BE6PZ0x00C30000SYSCTL_DID1_PRTNO_TM4C123BE6PM0x00700000SYSCTL_DID1_PRTNO_TM4C123AH6PM0x00830000SYSCTL_DID1_PRTNO_TM4C123AE6PMSYSCTL_DID1_PRTNO_TM4C1237H6PZ0x00610000SYSCTL_DID1_PRTNO_TM4C1237H6PM0x00410000SYSCTL_DID1_PRTNO_TM4C1237H6PGE0x00650000SYSCTL_DID1_PRTNO_TM4C1237E6PZ0x00600000SYSCTL_DID1_PRTNO_TM4C1237E6PMSYSCTL_DID1_PRTNO_TM4C1237D5PZ0x00660000SYSCTL_DID1_PRTNO_TM4C1237D5PM0x00480000SYSCTL_DID1_PRTNO_TM4C1236H6PM0x00510000SYSCTL_DID1_PRTNO_TM4C1236E6PM0x00500000SYSCTL_DID1_PRTNO_TM4C1236D5PM0x00520000SYSCTL_DID1_PRTNO_TM4C1233H6PZ0x00D20000SYSCTL_DID1_PRTNO_TM4C1233H6PMSYSCTL_DID1_PRTNO_TM4C1233H6PGE0x00D60000SYSCTL_DID1_PRTNO_TM4C1233E6PZ0x00D10000SYSCTL_DID1_PRTNO_TM4C1233E6PMSYSCTL_DID1_PRTNO_TM4C1233D5PZ0x00D00000SYSCTL_DID1_PRTNO_TM4C1233D5PMSYSCTL_DID1_PRTNO_TM4C1233C3PMSYSCTL_DID1_PRTNO_TM4C1232H6PM0x000B0000SYSCTL_DID1_PRTNO_TM4C1232E6PMSYSCTL_DID1_PRTNO_TM4C1232D5PM0x00090000SYSCTL_DID1_PRTNO_TM4C1232C3PMSYSCTL_DID1_PRTNO_TM4C1231H6PZ0x00310000SYSCTL_DID1_PRTNO_TM4C1231H6PM0x00110000SYSCTL_DID1_PRTNO_TM4C1231H6PGESYSCTL_DID1_PRTNO_TM4C1231E6PZSYSCTL_DID1_PRTNO_TM4C1231E6PMSYSCTL_DID1_PRTNO_TM4C1231D5PZSYSCTL_DID1_PRTNO_TM4C1231D5PMSYSCTL_DID1_PRTNO_TM4C1231C3PM0x00180000SYSCTL_DID1_PRTNO_TM4C1230H6PMSYSCTL_DID1_PRTNO_TM4C1230E6PMSYSCTL_DID1_PRTNO_TM4C1230D5PMSYSCTL_DID1_PRTNO_TM4C1230C3PMSYSCTL_DID1_PRTNO_M0x00FF0000SYSCTL_DID1_FAM_TIVASYSCTL_DID1_FAM_MSYSCTL_DID1_VER_1SYSCTL_DID1_VER_MSYSCTL_DID0_MIN_2SYSCTL_DID0_MIN_1SYSCTL_DID0_MIN_0SYSCTL_DID0_MIN_MSYSCTL_DID0_MAJ_REVCSYSCTL_DID0_MAJ_REVBSYSCTL_DID0_MAJ_REVASYSCTL_DID0_MAJ_M0x0000FF00SYSCTL_DID0_CLASS_TM4C129SYSCTL_DID0_CLASS_TM4C123SYSCTL_DID0_CLASS_MSYSCTL_DID0_VER_1SYSCTL_DID0_VER_M0x70000000SYSCTL_CCMCGREQ0x44030204SYSCTL_UNIQUEID30x400FEF2CSYSCTL_UNIQUEID20x400FEF28SYSCTL_UNIQUEID10x400FEF24SYSCTL_UNIQUEID00x400FEF20SYSCTL_PREMAC0x400FEA9CSYSCTL_PROWIRE0x400FEA98SYSCTL_PRLCD0x400FEA90SYSCTL_PRCCM0x400FEA74SYSCTL_PRWTIMER0x400FEA5CSYSCTL_PREEPROM0x400FEA58SYSCTL_PRQEI0x400FEA44SYSCTL_PRPWM0x400FEA40SYSCTL_PRACMP0x400FEA3CSYSCTL_PRADC0x400FEA38SYSCTL_PRCAN0x400FEA34SYSCTL_PREPHY0x400FEA30SYSCTL_PRUSB0x400FEA28SYSCTL_PRI2C0x400FEA20SYSCTL_PRSSI0x400FEA1CSYSCTL_PRUART0x400FEA18SYSCTL_PRHIB0x400FEA14SYSCTL_PREPI0x400FEA10SYSCTL_PRDMA0x400FEA0CSYSCTL_PRGPIO0x400FEA08SYSCTL_PRTIMER0x400FEA04SYSCTL_PRWD0x400FEA00SYSCTL_PCEMAC0x400FE99CSYSCTL_PCOWIRE0x400FE998SYSCTL_PCLCD0x400FE990SYSCTL_PCCCM0x400FE974SYSCTL_PCEEPROM0x400FE958SYSCTL_PCQEI0x400FE944SYSCTL_PCPWM0x400FE940SYSCTL_PCACMP0x400FE93CSYSCTL_PCADC0x400FE938SYSCTL_PCCAN0x400FE934SYSCTL_PCEPHY0x400FE930SYSCTL_PCUSB0x400FE928SYSCTL_PCI2C0x400FE920SYSCTL_PCSSI0x400FE91CSYSCTL_PCUART0x400FE918SYSCTL_PCHIB0x400FE914SYSCTL_PCEPI0x400FE910SYSCTL_PCDMA0x400FE90CSYSCTL_PCGPIO0x400FE908SYSCTL_PCTIMER0x400FE904SYSCTL_PCWD0x400FE900SYSCTL_DCGCEMAC0x400FE89CSYSCTL_DCGCOWIRE0x400FE898SYSCTL_DCGCLCD0x400FE890SYSCTL_DCGCCCM0x400FE874SYSCTL_DCGCWTIMER0x400FE85CSYSCTL_DCGCEEPROM0x400FE858SYSCTL_DCGCQEI0x400FE844SYSCTL_DCGCPWM0x400FE840SYSCTL_DCGCACMP0x400FE83CSYSCTL_DCGCADC0x400FE838SYSCTL_DCGCCAN0x400FE834SYSCTL_DCGCEPHY0x400FE830SYSCTL_DCGCUSB0x400FE828SYSCTL_DCGCI2C0x400FE820SYSCTL_DCGCSSI0x400FE81CSYSCTL_DCGCUART0x400FE818SYSCTL_DCGCHIB0x400FE814SYSCTL_DCGCEPI0x400FE810SYSCTL_DCGCDMA0x400FE80CSYSCTL_DCGCGPIO0x400FE808SYSCTL_DCGCTIMER0x400FE804SYSCTL_DCGCWD0x400FE800SYSCTL_SCGCEMAC0x400FE79CSYSCTL_SCGCOWIRE0x400FE798SYSCTL_SCGCLCD0x400FE790SYSCTL_SCGCCCM0x400FE774SYSCTL_SCGCWTIMER0x400FE75CSYSCTL_SCGCEEPROM0x400FE758SYSCTL_SCGCQEI0x400FE744SYSCTL_SCGCPWM0x400FE740SYSCTL_SCGCACMP0x400FE73CSYSCTL_SCGCADC0x400FE738SYSCTL_SCGCCAN0x400FE734SYSCTL_SCGCEPHY0x400FE730SYSCTL_SCGCUSB0x400FE728SYSCTL_SCGCI2C0x400FE720SYSCTL_SCGCSSI0x400FE71CSYSCTL_SCGCUART0x400FE718SYSCTL_SCGCHIB0x400FE714SYSCTL_SCGCEPI0x400FE710SYSCTL_SCGCDMA0x400FE70CSYSCTL_SCGCGPIO0x400FE708SYSCTL_SCGCTIMER0x400FE704SYSCTL_SCGCWD0x400FE700SYSCTL_RCGCEMAC0x400FE69CSYSCTL_RCGCOWIRE0x400FE698SYSCTL_RCGCLCD0x400FE690SYSCTL_RCGCCCM0x400FE674SYSCTL_RCGCWTIMER0x400FE65CSYSCTL_RCGCEEPROM0x400FE658SYSCTL_RCGCQEI0x400FE644SYSCTL_RCGCPWM0x400FE640SYSCTL_RCGCACMP0x400FE63CSYSCTL_RCGCADC0x400FE638SYSCTL_RCGCCAN0x400FE634SYSCTL_RCGCEPHY0x400FE630SYSCTL_RCGCUSB0x400FE628SYSCTL_RCGCI2C0x400FE620SYSCTL_RCGCSSI0x400FE61CSYSCTL_RCGCUART0x400FE618SYSCTL_RCGCHIB0x400FE614SYSCTL_RCGCEPI0x400FE610SYSCTL_RCGCDMA0x400FE60CSYSCTL_RCGCGPIO0x400FE608SYSCTL_RCGCTIMER0x400FE604SYSCTL_RCGCWD0x400FE600SYSCTL_SREMAC0x400FE59CSYSCTL_SROWIRE0x400FE598SYSCTL_SRLCD0x400FE590SYSCTL_SRCCM0x400FE574SYSCTL_SRWTIMER0x400FE55CSYSCTL_SREEPROM0x400FE558SYSCTL_SRQEI0x400FE544SYSCTL_SRPWM0x400FE540SYSCTL_SRACMP0x400FE53CSYSCTL_SRADC0x400FE538SYSCTL_SRCAN0x400FE534SYSCTL_SREPHY0x400FE530SYSCTL_SRUSB0x400FE528SYSCTL_SRI2C0x400FE520SYSCTL_SRSSI0x400FE51CSYSCTL_SRUART0x400FE518SYSCTL_SRHIB0x400FE514SYSCTL_SREPI0x400FE510SYSCTL_SRDMA0x400FE50CSYSCTL_SRGPIO0x400FE508SYSCTL_SRTIMER0x400FE504SYSCTL_SRWD0x400FE500SYSCTL_PPHIM0x400FE3A4SYSCTL_PPEMAC0x400FE39CSYSCTL_PPOWIRE0x400FE398SYSCTL_PPLCD0x400FE390SYSCTL_PPCCM0x400FE374SYSCTL_PPRTS0x400FE370SYSCTL_PPWTIMER0x400FE35CSYSCTL_PPEEPROM0x400FE358SYSCTL_PPFAN0x400FE354SYSCTL_PPPECI0x400FE350SYSCTL_PPLPC0x400FE348SYSCTL_PPQEI0x400FE344SYSCTL_PPPWM0x400FE340SYSCTL_PPACMP0x400FE33CSYSCTL_PPADC0x400FE338SYSCTL_PPCAN0x400FE334SYSCTL_PPEPHY0x400FE330SYSCTL_PPUSB0x400FE328SYSCTL_PPI2C0x400FE320SYSCTL_PPSSI0x400FE31CSYSCTL_PPUART0x400FE318SYSCTL_PPHIB0x400FE314SYSCTL_PPEPI0x400FE310SYSCTL_PPDMA0x400FE30CSYSCTL_PPGPIO0x400FE308SYSCTL_PPTIMER0x400FE304SYSCTL_PPWD0x400FE300SYSCTL_LCDMPC0x400FE294SYSCTL_EMACMPC0x400FE28CSYSCTL_EMACPDS0x400FE288SYSCTL_USBMPC0x400FE284SYSCTL_USBPDS0x400FE280SYSCTL_HSSR0x400FE1F4SYSCTL_RESBEHAVCTL0x400FE1D8SYSCTL_LDODPCTL0x400FE1BCSYSCTL_LDOSPCTL0x400FE1B4SYSCTL_NVMSTAT0x400FE1A0SYSCTL_DC90x400FE190SYSCTL_DSLPPWRCFG0x400FE18CSYSCTL_SLPPWRCFG0x400FE188SYSCTL_PLLSTAT0x400FE168SYSCTL_PLLFREQ10x400FE164SYSCTL_PLLFREQ00x400FE160SYSCTL_PIOSCSTAT0x400FE154SYSCTL_PIOSCCAL0x400FE150SYSCTL_SYSPROP0x400FE14CSYSCTL_DIVSCLK0x400FE148SYSCTL_DSCLKCFG0x400FE144SYSCTL_DSLPCLKCFGSYSCTL_ALTCLKCFG0x400FE138SYSCTL_DCGC20x400FE128SYSCTL_DCGC10x400FE124SYSCTL_DCGC00x400FE120SYSCTL_SCGC20x400FE118SYSCTL_SCGC10x400FE114SYSCTL_SCGC00x400FE110SYSCTL_RCGC20x400FE108SYSCTL_RCGC10x400FE104SYSCTL_RCGC00x400FE100SYSCTL_MEMTIM00x400FE0C0SYSCTL_RSCLKCFG0x400FE0B0SYSCTL_MOSCCTL0x400FE07CSYSCTL_RCC20x400FE070SYSCTL_GPIOHBCTL0x400FE06CSYSCTL_NMIC0x400FE064SYSCTL_RCC0x400FE060SYSCTL_PWRTCSYSCTL_RESC0x400FE05CSYSCTL_MISC0x400FE058SYSCTL_IMC0x400FE054SYSCTL_RIS0x400FE050SYSCTL_SRCR20x400FE048SYSCTL_SRCR10x400FE044SYSCTL_SRCR00x400FE040SYSCTL_PTBOCTL0x400FE038SYSCTL_PBORCTL0x400FE030SYSCTL_DC80x400FE02CSYSCTL_DC70x400FE028SYSCTL_DC60x400FE024SYSCTL_DC50x400FE020SYSCTL_DC40x400FE01CSYSCTL_DC30x400FE018SYSCTL_DC20x400FE014SYSCTL_DC10x400FE010SYSCTL_DC00x400FE008SYSCTL_DID10x400FE004SYSCTL_DID00x400FE000__HW_SYSCTL_H__DEPRECATED// __HW_SYSCTL_H__// VDD Under BOR0 Status// VDDA Under BOR0 Status// register.// The following are deprecated defines for the bit fields in the SYSCTL_PWRTC// HIB Reset// The following are deprecated defines for the bit fields in the SYSCTL_RESC// microcontrollers// Tiva(TM) C Series TM4C129-class// Tiva(TM) C Series TM4C123-class// The following are deprecated defines for the bit fields in the SYSCTL_DID0// The following definitions are deprecated.// SHA/MD5 Clock Gating Request// AES Clock Gating Request// DES Clock Gating Request// The following are defines for the bit fields in the SYSCTL_CCMCGREQ// Unique ID// The following are defines for the bit fields in the SYSCTL_UNIQUEID3// The following are defines for the bit fields in the SYSCTL_UNIQUEID2// The following are defines for the bit fields in the SYSCTL_UNIQUEID1// The following are defines for the bit fields in the SYSCTL_UNIQUEID0// Ready// Ethernet MAC Module 0 Peripheral// The following are defines for the bit fields in the SYSCTL_PREMAC register.// 1-Wire Module 0 Peripheral Ready// The following are defines for the bit fields in the SYSCTL_PROWIRE register.// Peripheral Ready// LCD Controller Module 0// The following are defines for the bit fields in the SYSCTL_PRLCD register.// CRC and Cryptographic Modules// The following are defines for the bit fields in the SYSCTL_PRCCM register.// Timer 0 Peripheral Ready// 32/64-Bit Wide General-Purpose// Timer 1 Peripheral Ready// Timer 2 Peripheral Ready// Timer 3 Peripheral Ready// Timer 4 Peripheral Ready// Timer 5 Peripheral Ready// The following are defines for the bit fields in the SYSCTL_PRWTIMER// EEPROM Module Peripheral Ready// The following are defines for the bit fields in the SYSCTL_PREEPROM// QEI Module 0 Peripheral Ready// QEI Module 1 Peripheral Ready// The following are defines for the bit fields in the SYSCTL_PRQEI register.// PWM Module 0 Peripheral Ready// PWM Module 1 Peripheral Ready// The following are defines for the bit fields in the SYSCTL_PRPWM register.// Analog Comparator Module 0// The following are defines for the bit fields in the SYSCTL_PRACMP register.// ADC Module 0 Peripheral Ready// ADC Module 1 Peripheral Ready// The following are defines for the bit fields in the SYSCTL_PRADC register.// CAN Module 0 Peripheral Ready// CAN Module 1 Peripheral Ready// The following are defines for the bit fields in the SYSCTL_PRCAN register.// Ethernet PHY Module Peripheral// The following are defines for the bit fields in the SYSCTL_PREPHY register.// USB Module Peripheral Ready// The following are defines for the bit fields in the SYSCTL_PRUSB register.// I2C Module 0 Peripheral Ready// I2C Module 1 Peripheral Ready// I2C Module 2 Peripheral Ready// I2C Module 3 Peripheral Ready// I2C Module 4 Peripheral Ready// I2C Module 5 Peripheral Ready// I2C Module 6 Peripheral Ready// I2C Module 7 Peripheral Ready// I2C Module 8 Peripheral Ready// I2C Module 9 Peripheral Ready// The following are defines for the bit fields in the SYSCTL_PRI2C register.// SSI Module 0 Peripheral Ready// SSI Module 1 Peripheral Ready// SSI Module 2 Peripheral Ready// SSI Module 3 Peripheral Ready// The following are defines for the bit fields in the SYSCTL_PRSSI register.// UART Module 0 Peripheral Ready// UART Module 1 Peripheral Ready// UART Module 2 Peripheral Ready// UART Module 3 Peripheral Ready// UART Module 4 Peripheral Ready// UART Module 5 Peripheral Ready// UART Module 6 Peripheral Ready// UART Module 7 Peripheral Ready// The following are defines for the bit fields in the SYSCTL_PRUART register.// Hibernation Module Peripheral// The following are defines for the bit fields in the SYSCTL_PRHIB register.// EPI Module Peripheral Ready// The following are defines for the bit fields in the SYSCTL_PREPI register.// uDMA Module Peripheral Ready// The following are defines for the bit fields in the SYSCTL_PRDMA register.// GPIO Port A Peripheral Ready// GPIO Port B Peripheral Ready// GPIO Port C Peripheral Ready// GPIO Port D Peripheral Ready// GPIO Port E Peripheral Ready// GPIO Port F Peripheral Ready// GPIO Port G Peripheral Ready// GPIO Port H Peripheral Ready// GPIO Port J Peripheral Ready// GPIO Port K Peripheral Ready// GPIO Port L Peripheral Ready// GPIO Port M Peripheral Ready// GPIO Port N Peripheral Ready// GPIO Port P Peripheral Ready// GPIO Port Q Peripheral Ready// GPIO Port R Peripheral Ready// GPIO Port S Peripheral Ready// GPIO Port T Peripheral Ready// The following are defines for the bit fields in the SYSCTL_PRGPIO register.// 0 Peripheral Ready// 16/32-Bit General-Purpose Timer// 1 Peripheral Ready// 2 Peripheral Ready// 3 Peripheral Ready// 4 Peripheral Ready// 5 Peripheral Ready// 6 Peripheral Ready// 7 Peripheral Ready// The following are defines for the bit fields in the SYSCTL_PRTIMER register.// Watchdog Timer 0 Peripheral// Watchdog Timer 1 Peripheral// The following are defines for the bit fields in the SYSCTL_PRWD register.// Ethernet MAC Module 0 Power// The following are defines for the bit fields in the SYSCTL_PCEMAC register.// 1-Wire Module 0 Power Control// The following are defines for the bit fields in the SYSCTL_PCOWIRE register.// LCD Controller Module 0 Power// The following are defines for the bit fields in the SYSCTL_PCLCD register.// Power Control// The following are defines for the bit fields in the SYSCTL_PCCCM register.// EEPROM Module 0 Power Control// The following are defines for the bit fields in the SYSCTL_PCEEPROM// QEI Module 0 Power Control// The following are defines for the bit fields in the SYSCTL_PCQEI register.// PWM Module 0 Power Control// The following are defines for the bit fields in the SYSCTL_PCPWM register.// Analog Comparator Module 0 Power// The following are defines for the bit fields in the SYSCTL_PCACMP register.// ADC Module 0 Power Control// ADC Module 1 Power Control// The following are defines for the bit fields in the SYSCTL_PCADC register.// CAN Module 0 Power Control// CAN Module 1 Power Control// The following are defines for the bit fields in the SYSCTL_PCCAN register.// Ethernet PHY Module Power// The following are defines for the bit fields in the SYSCTL_PCEPHY register.// USB Module Power Control// The following are defines for the bit fields in the SYSCTL_PCUSB register.// I2C Module 0 Power Control// I2C Module 1 Power Control// I2C Module 2 Power Control// I2C Module 3 Power Control// I2C Module 4 Power Control// I2C Module 5 Power Control// I2C Module 6 Power Control// I2C Module 7 Power Control// I2C Module 8 Power Control// I2C Module 9 Power Control// The following are defines for the bit fields in the SYSCTL_PCI2C register.// SSI Module 0 Power Control// SSI Module 1 Power Control// SSI Module 2 Power Control// SSI Module 3 Power Control// The following are defines for the bit fields in the SYSCTL_PCSSI register.// UART Module 0 Power Control// UART Module 1 Power Control// UART Module 2 Power Control// UART Module 3 Power Control// UART Module 4 Power Control// UART Module 5 Power Control// UART Module 6 Power Control// UART Module 7 Power Control// The following are defines for the bit fields in the SYSCTL_PCUART register.// Hibernation Module Power Control// The following are defines for the bit fields in the SYSCTL_PCHIB register.// EPI Module Power Control// The following are defines for the bit fields in the SYSCTL_PCEPI register.// uDMA Module Power Control// The following are defines for the bit fields in the SYSCTL_PCDMA register.// GPIO Port A Power Control// GPIO Port B Power Control// GPIO Port C Power Control// GPIO Port D Power Control// GPIO Port E Power Control// GPIO Port F Power Control// GPIO Port G Power Control// GPIO Port H Power Control// GPIO Port J Power Control// GPIO Port K Power Control// GPIO Port L Power Control// GPIO Port M Power Control// GPIO Port N Power Control// GPIO Port P Power Control// GPIO Port Q Power Control// GPIO Port R Power Control// GPIO Port S Power Control// GPIO Port T Power Control// The following are defines for the bit fields in the SYSCTL_PCGPIO register.// General-Purpose Timer 0 Power// General-Purpose Timer 1 Power// General-Purpose Timer 2 Power// General-Purpose Timer 3 Power// General-Purpose Timer 4 Power// General-Purpose Timer 5 Power// General-Purpose Timer 6 Power// General-Purpose Timer 7 Power// The following are defines for the bit fields in the SYSCTL_PCTIMER register.// Watchdog Timer 0 Power Control// Watchdog Timer 1 Power Control// The following are defines for the bit fields in the SYSCTL_PCWD register.// Mode Clock Gating Control// Ethernet MAC Module 0 Deep-Sleep// The following are defines for the bit fields in the SYSCTL_DCGCEMAC// Clock Gating Control// 1-Wire Module 0 Deep-Sleep Mode// The following are defines for the bit fields in the SYSCTL_DCGCOWIRE// Deep-Sleep Mode Clock Gating// The following are defines for the bit fields in the SYSCTL_DCGCLCD register.// The following are defines for the bit fields in the SYSCTL_DCGCCCM register.// Gating Control// Timer 0 Deep-Sleep Mode Clock// Timer 1 Deep-Sleep Mode Clock// Timer 2 Deep-Sleep Mode Clock// Timer 3 Deep-Sleep Mode Clock// Timer 4 Deep-Sleep Mode Clock// Timer 5 Deep-Sleep Mode Clock// The following are defines for the bit fields in the SYSCTL_DCGCWTIMER// EEPROM Module Deep-Sleep Mode// The following are defines for the bit fields in the SYSCTL_DCGCEEPROM// QEI Module 0 Deep-Sleep Mode// QEI Module 1 Deep-Sleep Mode// The following are defines for the bit fields in the SYSCTL_DCGCQEI register.// PWM Module 0 Deep-Sleep Mode// PWM Module 1 Deep-Sleep Mode// The following are defines for the bit fields in the SYSCTL_DCGCPWM register.// The following are defines for the bit fields in the SYSCTL_DCGCACMP// ADC Module 0 Deep-Sleep Mode// ADC Module 1 Deep-Sleep Mode// The following are defines for the bit fields in the SYSCTL_DCGCADC register.// CAN Module 0 Deep-Sleep Mode// CAN Module 1 Deep-Sleep Mode// The following are defines for the bit fields in the SYSCTL_DCGCCAN register.// PHY Module Deep-Sleep Mode Clock// The following are defines for the bit fields in the SYSCTL_DCGCEPHY// USB Module Deep-Sleep Mode Clock// The following are defines for the bit fields in the SYSCTL_DCGCUSB register.// I2C Module 0 Deep-Sleep Mode// I2C Module 1 Deep-Sleep Mode// I2C Module 2 Deep-Sleep Mode// I2C Module 3 Deep-Sleep Mode// I2C Module 4 Deep-Sleep Mode// I2C Module 5 Deep-Sleep Mode// I2C Module 6 Deep-Sleep Mode// I2C Module 7 Deep-Sleep Mode// I2C Module 8 Deep-Sleep Mode// I2C Module 9 Deep-Sleep Mode// The following are defines for the bit fields in the SYSCTL_DCGCI2C register.// SSI Module 0 Deep-Sleep Mode// SSI Module 1 Deep-Sleep Mode// SSI Module 2 Deep-Sleep Mode// SSI Module 3 Deep-Sleep Mode// The following are defines for the bit fields in the SYSCTL_DCGCSSI register.// UART Module 0 Deep-Sleep Mode// UART Module 1 Deep-Sleep Mode// UART Module 2 Deep-Sleep Mode// UART Module 3 Deep-Sleep Mode// UART Module 4 Deep-Sleep Mode// UART Module 5 Deep-Sleep Mode// UART Module 6 Deep-Sleep Mode// UART Module 7 Deep-Sleep Mode// The following are defines for the bit fields in the SYSCTL_DCGCUART// Hibernation Module Deep-Sleep// The following are defines for the bit fields in the SYSCTL_DCGCHIB register.// EPI Module Deep-Sleep Mode Clock// The following are defines for the bit fields in the SYSCTL_DCGCEPI register.// uDMA Module Deep-Sleep Mode// The following are defines for the bit fields in the SYSCTL_DCGCDMA register.// GPIO Port A Deep-Sleep Mode// GPIO Port B Deep-Sleep Mode// GPIO Port C Deep-Sleep Mode// GPIO Port D Deep-Sleep Mode// GPIO Port E Deep-Sleep Mode// GPIO Port F Deep-Sleep Mode// GPIO Port G Deep-Sleep Mode// GPIO Port H Deep-Sleep Mode// GPIO Port J Deep-Sleep Mode// GPIO Port K Deep-Sleep Mode// GPIO Port L Deep-Sleep Mode// GPIO Port M Deep-Sleep Mode// GPIO Port N Deep-Sleep Mode// GPIO Port P Deep-Sleep Mode// GPIO Port Q Deep-Sleep Mode// GPIO Port R Deep-Sleep Mode// GPIO Port S Deep-Sleep Mode// GPIO Port T Deep-Sleep Mode// The following are defines for the bit fields in the SYSCTL_DCGCGPIO// 0 Deep-Sleep Mode Clock Gating// 1 Deep-Sleep Mode Clock Gating// 2 Deep-Sleep Mode Clock Gating// 3 Deep-Sleep Mode Clock Gating// 4 Deep-Sleep Mode Clock Gating// 5 Deep-Sleep Mode Clock Gating// 6 Deep-Sleep Mode Clock Gating// 7 Deep-Sleep Mode Clock Gating// The following are defines for the bit fields in the SYSCTL_DCGCTIMER// Watchdog Timer 0 Deep-Sleep Mode// Watchdog Timer 1 Deep-Sleep Mode// The following are defines for the bit fields in the SYSCTL_DCGCWD register.// Ethernet MAC Module 0 Sleep Mode// The following are defines for the bit fields in the SYSCTL_SCGCEMAC// 1-Wire Module 0 Sleep Mode Clock// The following are defines for the bit fields in the SYSCTL_SCGCOWIRE// LCD Controller Module 0 Sleep// The following are defines for the bit fields in the SYSCTL_SCGCLCD register.// Sleep Mode Clock Gating Control// The following are defines for the bit fields in the SYSCTL_SCGCCCM register.// Timer 0 Sleep Mode Clock Gating// Timer 1 Sleep Mode Clock Gating// Timer 2 Sleep Mode Clock Gating// Timer 3 Sleep Mode Clock Gating// Timer 4 Sleep Mode Clock Gating// Timer 5 Sleep Mode Clock Gating// The following are defines for the bit fields in the SYSCTL_SCGCWTIMER// EEPROM Module Sleep Mode Clock// The following are defines for the bit fields in the SYSCTL_SCGCEEPROM// QEI Module 0 Sleep Mode Clock// QEI Module 1 Sleep Mode Clock// The following are defines for the bit fields in the SYSCTL_SCGCQEI register.// PWM Module 0 Sleep Mode Clock// PWM Module 1 Sleep Mode Clock// The following are defines for the bit fields in the SYSCTL_SCGCPWM register.// Analog Comparator Module 0 Sleep// The following are defines for the bit fields in the SYSCTL_SCGCACMP// ADC Module 0 Sleep Mode Clock// ADC Module 1 Sleep Mode Clock// The following are defines for the bit fields in the SYSCTL_SCGCADC register.// CAN Module 0 Sleep Mode Clock// CAN Module 1 Sleep Mode Clock// The following are defines for the bit fields in the SYSCTL_SCGCCAN register.// PHY Module Sleep Mode Clock// The following are defines for the bit fields in the SYSCTL_SCGCEPHY// USB Module Sleep Mode Clock// The following are defines for the bit fields in the SYSCTL_SCGCUSB register.// I2C Module 0 Sleep Mode Clock// I2C Module 1 Sleep Mode Clock// I2C Module 2 Sleep Mode Clock// I2C Module 3 Sleep Mode Clock// I2C Module 4 Sleep Mode Clock// I2C Module 5 Sleep Mode Clock// I2C Module 6 Sleep Mode Clock// I2C Module 7 Sleep Mode Clock// I2C Module 8 Sleep Mode Clock// I2C Module 9 Sleep Mode Clock// The following are defines for the bit fields in the SYSCTL_SCGCI2C register.// SSI Module 0 Sleep Mode Clock// SSI Module 1 Sleep Mode Clock// SSI Module 2 Sleep Mode Clock// SSI Module 3 Sleep Mode Clock// The following are defines for the bit fields in the SYSCTL_SCGCSSI register.// UART Module 0 Sleep Mode Clock// UART Module 1 Sleep Mode Clock// UART Module 2 Sleep Mode Clock// UART Module 3 Sleep Mode Clock// UART Module 4 Sleep Mode Clock// UART Module 5 Sleep Mode Clock// UART Module 6 Sleep Mode Clock// UART Module 7 Sleep Mode Clock// The following are defines for the bit fields in the SYSCTL_SCGCUART// Hibernation Module Sleep Mode// The following are defines for the bit fields in the SYSCTL_SCGCHIB register.// EPI Module Sleep Mode Clock// The following are defines for the bit fields in the SYSCTL_SCGCEPI register.// uDMA Module Sleep Mode Clock// The following are defines for the bit fields in the SYSCTL_SCGCDMA register.// GPIO Port A Sleep Mode Clock// GPIO Port B Sleep Mode Clock// GPIO Port C Sleep Mode Clock// GPIO Port D Sleep Mode Clock// GPIO Port E Sleep Mode Clock// GPIO Port F Sleep Mode Clock// GPIO Port G Sleep Mode Clock// GPIO Port H Sleep Mode Clock// GPIO Port J Sleep Mode Clock// GPIO Port K Sleep Mode Clock// GPIO Port L Sleep Mode Clock// GPIO Port M Sleep Mode Clock// GPIO Port N Sleep Mode Clock// GPIO Port P Sleep Mode Clock// GPIO Port Q Sleep Mode Clock// GPIO Port R Sleep Mode Clock// GPIO Port S Sleep Mode Clock// GPIO Port T Sleep Mode Clock// The following are defines for the bit fields in the SYSCTL_SCGCGPIO// 0 Sleep Mode Clock Gating// 1 Sleep Mode Clock Gating// 2 Sleep Mode Clock Gating// 3 Sleep Mode Clock Gating// 4 Sleep Mode Clock Gating// 5 Sleep Mode Clock Gating// 6 Sleep Mode Clock Gating// 7 Sleep Mode Clock Gating// The following are defines for the bit fields in the SYSCTL_SCGCTIMER// Watchdog Timer 0 Sleep Mode// Watchdog Timer 1 Sleep Mode// The following are defines for the bit fields in the SYSCTL_SCGCWD register.// Ethernet MAC Module 0 Run Mode// The following are defines for the bit fields in the SYSCTL_RCGCEMAC// 1-Wire Module 0 Run Mode Clock// The following are defines for the bit fields in the SYSCTL_RCGCOWIRE// LCD Controller Module 0 Run Mode// The following are defines for the bit fields in the SYSCTL_RCGCLCD register.// Run Mode Clock Gating Control// The following are defines for the bit fields in the SYSCTL_RCGCCCM register.// Timer 0 Run Mode Clock Gating// Timer 1 Run Mode Clock Gating// Timer 2 Run Mode Clock Gating// Timer 3 Run Mode Clock Gating// Timer 4 Run Mode Clock Gating// Timer 5 Run Mode Clock Gating// The following are defines for the bit fields in the SYSCTL_RCGCWTIMER// EEPROM Module Run Mode Clock// The following are defines for the bit fields in the SYSCTL_RCGCEEPROM// QEI Module 0 Run Mode Clock// QEI Module 1 Run Mode Clock// The following are defines for the bit fields in the SYSCTL_RCGCQEI register.// PWM Module 0 Run Mode Clock// PWM Module 1 Run Mode Clock// The following are defines for the bit fields in the SYSCTL_RCGCPWM register.// Analog Comparator Module 0 Run// The following are defines for the bit fields in the SYSCTL_RCGCACMP// ADC Module 0 Run Mode Clock// ADC Module 1 Run Mode Clock// The following are defines for the bit fields in the SYSCTL_RCGCADC register.// CAN Module 0 Run Mode Clock// CAN Module 1 Run Mode Clock// The following are defines for the bit fields in the SYSCTL_RCGCCAN register.// Ethernet PHY Module Run Mode// The following are defines for the bit fields in the SYSCTL_RCGCEPHY// USB Module Run Mode Clock Gating// The following are defines for the bit fields in the SYSCTL_RCGCUSB register.// I2C Module 0 Run Mode Clock// I2C Module 1 Run Mode Clock// I2C Module 2 Run Mode Clock// I2C Module 3 Run Mode Clock// I2C Module 4 Run Mode Clock// I2C Module 5 Run Mode Clock// I2C Module 6 Run Mode Clock// I2C Module 7 Run Mode Clock// I2C Module 8 Run Mode Clock// I2C Module 9 Run Mode Clock// The following are defines for the bit fields in the SYSCTL_RCGCI2C register.// SSI Module 0 Run Mode Clock// SSI Module 1 Run Mode Clock// SSI Module 2 Run Mode Clock// SSI Module 3 Run Mode Clock// The following are defines for the bit fields in the SYSCTL_RCGCSSI register.// UART Module 0 Run Mode Clock// UART Module 1 Run Mode Clock// UART Module 2 Run Mode Clock// UART Module 3 Run Mode Clock// UART Module 4 Run Mode Clock// UART Module 5 Run Mode Clock// UART Module 6 Run Mode Clock// UART Module 7 Run Mode Clock// The following are defines for the bit fields in the SYSCTL_RCGCUART// Hibernation Module Run Mode// The following are defines for the bit fields in the SYSCTL_RCGCHIB register.// EPI Module Run Mode Clock Gating// The following are defines for the bit fields in the SYSCTL_RCGCEPI register.// uDMA Module Run Mode Clock// The following are defines for the bit fields in the SYSCTL_RCGCDMA register.// GPIO Port A Run Mode Clock// GPIO Port B Run Mode Clock// GPIO Port C Run Mode Clock// GPIO Port D Run Mode Clock// GPIO Port E Run Mode Clock// GPIO Port F Run Mode Clock// GPIO Port G Run Mode Clock// GPIO Port H Run Mode Clock// GPIO Port J Run Mode Clock// GPIO Port K Run Mode Clock// GPIO Port L Run Mode Clock// GPIO Port M Run Mode Clock// GPIO Port N Run Mode Clock// GPIO Port P Run Mode Clock// GPIO Port Q Run Mode Clock// GPIO Port R Run Mode Clock// GPIO Port S Run Mode Clock// GPIO Port T Run Mode Clock// The following are defines for the bit fields in the SYSCTL_RCGCGPIO// 0 Run Mode Clock Gating Control// 1 Run Mode Clock Gating Control// 2 Run Mode Clock Gating Control// 3 Run Mode Clock Gating Control// 4 Run Mode Clock Gating Control// 5 Run Mode Clock Gating Control// 6 Run Mode Clock Gating Control// 7 Run Mode Clock Gating Control// The following are defines for the bit fields in the SYSCTL_RCGCTIMER// Watchdog Timer 0 Run Mode Clock// Watchdog Timer 1 Run Mode Clock// The following are defines for the bit fields in the SYSCTL_RCGCWD register.// Software Reset// Ethernet Controller MAC Module 0// The following are defines for the bit fields in the SYSCTL_SREMAC register.// 1-Wire Module Software Reset// The following are defines for the bit fields in the SYSCTL_SROWIRE register.// LCD Module 0 Software Reset// The following are defines for the bit fields in the SYSCTL_SRLCD register.// The following are defines for the bit fields in the SYSCTL_SRCCM register.// Timer 0 Software Reset// Timer 1 Software Reset// Timer 2 Software Reset// Timer 3 Software Reset// Timer 4 Software Reset// Timer 5 Software Reset// The following are defines for the bit fields in the SYSCTL_SRWTIMER// EEPROM Module Software Reset// The following are defines for the bit fields in the SYSCTL_SREEPROM// QEI Module 0 Software Reset// QEI Module 1 Software Reset// The following are defines for the bit fields in the SYSCTL_SRQEI register.// PWM Module 0 Software Reset// PWM Module 1 Software Reset// The following are defines for the bit fields in the SYSCTL_SRPWM register.// The following are defines for the bit fields in the SYSCTL_SRACMP register.// ADC Module 0 Software Reset// ADC Module 1 Software Reset// The following are defines for the bit fields in the SYSCTL_SRADC register.// CAN Module 0 Software Reset// CAN Module 1 Software Reset// The following are defines for the bit fields in the SYSCTL_SRCAN register.// Reset// Ethernet PHY Module Software// The following are defines for the bit fields in the SYSCTL_SREPHY register.// USB Module Software Reset// The following are defines for the bit fields in the SYSCTL_SRUSB register.// I2C Module 0 Software Reset// I2C Module 1 Software Reset// I2C Module 2 Software Reset// I2C Module 3 Software Reset// I2C Module 4 Software Reset// I2C Module 5 Software Reset// I2C Module 6 Software Reset// I2C Module 7 Software Reset// I2C Module 8 Software Reset// I2C Module 9 Software Reset// The following are defines for the bit fields in the SYSCTL_SRI2C register.// SSI Module 0 Software Reset// SSI Module 1 Software Reset// SSI Module 2 Software Reset// SSI Module 3 Software Reset// The following are defines for the bit fields in the SYSCTL_SRSSI register.// UART Module 0 Software Reset// UART Module 1 Software Reset// UART Module 2 Software Reset// UART Module 3 Software Reset// UART Module 4 Software Reset// UART Module 5 Software Reset// UART Module 6 Software Reset// UART Module 7 Software Reset// The following are defines for the bit fields in the SYSCTL_SRUART register.// Hibernation Module Software// The following are defines for the bit fields in the SYSCTL_SRHIB register.// EPI Module Software Reset// The following are defines for the bit fields in the SYSCTL_SREPI register.// uDMA Module Software Reset// The following are defines for the bit fields in the SYSCTL_SRDMA register.// GPIO Port A Software Reset// GPIO Port B Software Reset// GPIO Port C Software Reset// GPIO Port D Software Reset// GPIO Port E Software Reset// GPIO Port F Software Reset// GPIO Port G Software Reset// GPIO Port H Software Reset// GPIO Port J Software Reset// GPIO Port K Software Reset// GPIO Port L Software Reset// GPIO Port M Software Reset// GPIO Port N Software Reset// GPIO Port P Software Reset// GPIO Port Q Software Reset// GPIO Port R Software Reset// GPIO Port S Software Reset// GPIO Port T Software Reset// The following are defines for the bit fields in the SYSCTL_SRGPIO register.// 0 Software Reset// 1 Software Reset// 2 Software Reset// 3 Software Reset// 4 Software Reset// 5 Software Reset// 6 Software Reset// 7 Software Reset// The following are defines for the bit fields in the SYSCTL_SRTIMER register.// Watchdog Timer 0 Software Reset// Watchdog Timer 1 Software Reset// The following are defines for the bit fields in the SYSCTL_SRWD register.// HIM Module Present// The following are defines for the bit fields in the SYSCTL_PPHIM register.// Present// Ethernet Controller Module// The following are defines for the bit fields in the SYSCTL_PPEMAC register.// 1-Wire Module Present// The following are defines for the bit fields in the SYSCTL_PPOWIRE register.// LCD Module Present// The following are defines for the bit fields in the SYSCTL_PPLCD register.// The following are defines for the bit fields in the SYSCTL_PPCCM register.// RTS Module Present// The following are defines for the bit fields in the SYSCTL_PPRTS register.// Timer 0 Present// Timer 1 Present// Timer 2 Present// Timer 3 Present// Timer 4 Present// Timer 5 Present// The following are defines for the bit fields in the SYSCTL_PPWTIMER// EEPROM Module Present// The following are defines for the bit fields in the SYSCTL_PPEEPROM// FAN Module 0 Present// The following are defines for the bit fields in the SYSCTL_PPFAN register.// PECI Module Present// The following are defines for the bit fields in the SYSCTL_PPPECI register.// LPC Module Present// The following are defines for the bit fields in the SYSCTL_PPLPC register.// QEI Module 0 Present// QEI Module 1 Present// The following are defines for the bit fields in the SYSCTL_PPQEI register.// PWM Module 0 Present// PWM Module 1 Present// The following are defines for the bit fields in the SYSCTL_PPPWM register.// Analog Comparator Module Present// The following are defines for the bit fields in the SYSCTL_PPACMP register.// ADC Module 0 Present// ADC Module 1 Present// The following are defines for the bit fields in the SYSCTL_PPADC register.// CAN Module 0 Present// CAN Module 1 Present// The following are defines for the bit fields in the SYSCTL_PPCAN register.// Ethernet PHY Module Present// The following are defines for the bit fields in the SYSCTL_PPEPHY register.// USB Module Present// The following are defines for the bit fields in the SYSCTL_PPUSB register.// I2C Module 0 Present// I2C Module 1 Present// I2C Module 2 Present// I2C Module 3 Present// I2C Module 4 Present// I2C Module 5 Present// I2C Module 6 Present// I2C Module 7 Present// I2C Module 8 Present// I2C Module 9 Present// The following are defines for the bit fields in the SYSCTL_PPI2C register.// SSI Module 0 Present// SSI Module 1 Present// SSI Module 2 Present// SSI Module 3 Present// The following are defines for the bit fields in the SYSCTL_PPSSI register.// UART Module 0 Present// UART Module 1 Present// UART Module 2 Present// UART Module 3 Present// UART Module 4 Present// UART Module 5 Present// UART Module 6 Present// UART Module 7 Present// The following are defines for the bit fields in the SYSCTL_PPUART register.// Hibernation Module Present// The following are defines for the bit fields in the SYSCTL_PPHIB register.// EPI Module Present// The following are defines for the bit fields in the SYSCTL_PPEPI register.// uDMA Module Present// The following are defines for the bit fields in the SYSCTL_PPDMA register.// GPIO Port A Present// GPIO Port B Present// GPIO Port C Present// GPIO Port D Present// GPIO Port E Present// GPIO Port F Present// GPIO Port G Present// GPIO Port H Present// GPIO Port J Present// GPIO Port K Present// GPIO Port L Present// GPIO Port M Present// GPIO Port N Present// GPIO Port P Present// GPIO Port Q Present// GPIO Port R Present// GPIO Port S Present// GPIO Port T Present// The following are defines for the bit fields in the SYSCTL_PPGPIO register.// 0 Present// 1 Present// 2 Present// 3 Present// 4 Present// 5 Present// 6 Present// 7 Present// The following are defines for the bit fields in the SYSCTL_PPTIMER register.// Watchdog Timer 0 Present// Watchdog Timer 1 Present// The following are defines for the bit fields in the SYSCTL_PPWD register.// Array On// Array OFF// Memory Array Power Control// The following are defines for the bit fields in the SYSCTL_LCDMPC register.// The following are defines for the bit fields in the SYSCTL_EMACMPC register.// ON// OFF// Power Domain Status// Memory Array Power Status// The following are defines for the bit fields in the SYSCTL_EMACPDS register.// SRAM Retention// The following are defines for the bit fields in the SYSCTL_USBMPC register.// The following are defines for the bit fields in the SYSCTL_USBPDS register.// Command Descriptor Pointer// Write Key// The following are defines for the bit fields in the SYSCTL_HSSR register.// us after deassertion (Default)// Application starts less than 500// simulated POR sequence.// External RST assertion issues a// starts within 10 us// system reset. The application// External RST Pin Operation// application starts less than 500// simulated POR sequence. The// Brown Out Reset issues a// within 10 us// reset. The application starts// Brown Out Reset issues system// BOR Reset operation// deassertion (Default)// less than 500 us after// POR sequence. Application starts// Watchdog 0 issues a simulated// Watchdog 0 issues a system// Watchdog 0 Reset Operation// Watchdog 1 issues a simulated// Watchdog 1 issues a system// Watchdog 1 Reset Operation// The following are defines for the bit fields in the SYSCTL_RESBEHAVCTL// 1.35 V// 1.30 V// 1.25 V// 1.20 V// 1.15 V// 1.10 V// 1.05 V// 1.00 V// 0.95 V// 0.90 V// LDO Output Voltage// Voltage Adjust Enable// The following are defines for the bit fields in the SYSCTL_LDODPCTL// The following are defines for the bit fields in the SYSCTL_LDOSPCTL// Available// 32 Word Flash Write Buffer// The following are defines for the bit fields in the SYSCTL_NVMSTAT register.// ADC0 DC0 Present// ADC0 DC1 Present// ADC0 DC2 Present// ADC0 DC3 Present// ADC0 DC4 Present// ADC0 DC5 Present// ADC0 DC6 Present// ADC0 DC7 Present// ADC1 DC0 Present// ADC1 DC1 Present// ADC1 DC2 Present// ADC1 DC3 Present// ADC1 DC4 Present// ADC1 DC5 Present// ADC1 DC6 Present// ADC1 DC7 Present// The following are defines for the bit fields in the SYSCTL_DC9 register.// Low Power Mode// Standby Mode// Active Mode// SRAM Power Modes// Flash Power Modes// Temperature Sense Power Down// LDO Sleep Mode// The following are defines for the bit fields in the SYSCTL_DSLPPWRCFG// The following are defines for the bit fields in the SYSCTL_SLPPWRCFG// PLL Lock// The following are defines for the bit fields in the SYSCTL_PLLSTAT register.// PLL N Value// PLL Q Value// The following are defines for the bit fields in the SYSCTL_PLLFREQ1// PLL M Integer Value// PLL M Fractional Value// PLL Power// The following are defines for the bit fields in the SYSCTL_PLLFREQ0// Calibration Trim Value// failed to meet 1% accuracy// The last calibration operation// completed to meet 1% accuracy// attempted// Calibration has not been// Calibration Result// Default Trim Value// The following are defines for the bit fields in the SYSCTL_PIOSCSTAT// User Trim Value// Update Trim// Start Calibration// Use User Trim Value// The following are defines for the bit fields in the SYSCTL_PIOSCCAL// FPU Present// The following are defines for the bit fields in the SYSCTL_SYSPROP register.// Divisor Value// System Clock// Clock Source// DIVSCLK Enable// The following are defines for the bit fields in the SYSCTL_DIVSCLK register.// Deep Sleep Clock Divisor// Hibernation Module RTCOSC// LFIOSC// Deep Sleep Oscillator Source// MOSC Disable Power Down// PIOSC Power Down// The following are defines for the bit fields in the SYSCTL_DSCLKCFG// PIOSC Power Down Request// 32.768 kHz// Divider Field Override// The following are defines for the bit fields in the SYSCTL_DSLPCLKCFG// oscillator (LFIOSC)// Low-frequency internal// clock output (RTCOSC)// Hibernation Module Real-time// Alternate Clock Source// The following are defines for the bit fields in the SYSCTL_ALTCLKCFG// Port A Clock Gating Control// Port B Clock Gating Control// Port C Clock Gating Control// Port D Clock Gating Control// Port E Clock Gating Control// Port F Clock Gating Control// Port G Clock Gating Control// Port H Clock Gating Control// Port J Clock Gating Control// Micro-DMA Clock Gating Control// USB0 Clock Gating Control// The following are defines for the bit fields in the SYSCTL_DCGC2 register.// UART0 Clock Gating Control// UART1 Clock Gating Control// UART2 Clock Gating Control// SSI0 Clock Gating Control// SSI1 Clock Gating Control// QEI0 Clock Gating Control// QEI1 Clock Gating Control// I2C0 Clock Gating Control// I2C1 Clock Gating Control// Timer 0 Clock Gating Control// Timer 1 Clock Gating Control// Timer 2 Clock Gating Control// Timer 3 Clock Gating Control// Analog Comparator 0 Clock Gating// Analog Comparator 1 Clock Gating// Analog Comparator 2 Clock Gating// The following are defines for the bit fields in the SYSCTL_DCGC1 register.// WDT0 Clock Gating Control// HIB Clock Gating Control// ADC0 Clock Gating Control// ADC1 Clock Gating Control// PWM Clock Gating Control// CAN0 Clock Gating Control// CAN1 Clock Gating Control// WDT1 Clock Gating Control// The following are defines for the bit fields in the SYSCTL_DCGC0 register.// The following are defines for the bit fields in the SYSCTL_SCGC2 register.// The following are defines for the bit fields in the SYSCTL_SCGC1 register.// ADC Sample Speed// The following are defines for the bit fields in the SYSCTL_SCGC0 register.// The following are defines for the bit fields in the SYSCTL_RCGC2 register.// The following are defines for the bit fields in the SYSCTL_RCGC1 register.// 1M samples/second// 500K samples/second// 250K samples/second// 125K samples/second// ADC0 Sample Speed// ADC1 Sample Speed// The following are defines for the bit fields in the SYSCTL_RCGC0 register.// Flash Wait State// Flash Bank Clock Edge// 4.5 system clock periods// 4 system clock periods// 3.5 system clock periods// 3 system clock periods// 2.5 system clock periods// 2 system clock periods// 1.5 system clock periods// 1 system clock period// 1/2 system clock period// Flash Bank Clock High Time// EEPROM Wait States// Must be one// EEPROM Bank Clock Edge// EEPROM Clock High Time// The following are defines for the bit fields in the SYSCTL_MEMTIM0 register.// PLL System Clock Divisor// Oscillator System Clock Divisor// Oscillator (RTCOSC)// Hibernation Module RTC// MOSC is oscillator source// LFIOSC is oscillator source// PIOSC is oscillator source// Oscillator Source// source// MOSC is the PLL input clock// PIOSC is PLL input clock source// PLL Source// Use PLL// Auto Clock Gating// New PLLFREQ Accept// Memory Timing Register Update// The following are defines for the bit fields in the SYSCTL_RSCLKCFG// Clock Validation for MOSC// MOSC Failure Action// No Crystal Connected// Power Down// Oscillator Range// The following are defines for the bit fields in the SYSCTL_MOSCCTL register.// PIOSC/4// Oscillator Source 2// PLL Bypass 2// Power-Down PLL 2// Power-Down USB PLL// Additional LSB for SYSDIV2// System Clock Divisor 2// MHz// Divide PLL as 400 MHz vs. 200// Use RCC2// The following are defines for the bit fields in the SYSCTL_RCC2 register.// Bus// Port A Advanced High-Performance// Port B Advanced High-Performance// Port C Advanced High-Performance// Port D Advanced High-Performance// Port E Advanced High-Performance// Port F Advanced High-Performance// Port G Advanced High-Performance// Port H Advanced High-Performance// Port J Advanced High-Performance// The following are defines for the bit fields in the SYSCTL_GPIOHBCTL// External Pin NMI// Power/Brown Out Event NMI// Watch Dog Timer (WDT) 0 NMI// Watch Dog Timer (WDT) 1 NMI// Tamper Event NMI// MOSC Failure NMI// The following are defines for the bit fields in the SYSCTL_NMIC register.// Shift to the XTAL field// Main Oscillator Disable// IOSC/4// IOSC// 25.0 MHz (USB)// 24.0 MHz (USB)// 20.0 MHz (USB)// 18.0 MHz (USB)// 16.384 MHz// 16 MHz// 14.31818 MHz// 13.56 MHz// 12.288 MHz// 12 MHz// 10 MHz// 8.192 MHz// 8 MHz// 7.3728 MHz// 6.144 MHz// 6 MHz// 5.12 MHz// 5 MHz// 4.9152 MHz// 4.096 MHz// 4 MHz// Crystal Value// PLL Bypass// PLL Power Down// PWM clock /64// PWM clock /32// PWM clock /16// PWM clock /8// PWM clock /4// PWM clock /2// PWM Unit Clock Divisor// Enable PWM Clock Divisor// Enable System Clock Divider// System Clock Divisor// The following are defines for the bit fields in the SYSCTL_RCC register.// VDD Under BOR Status// VDDA Under BOR Status// The following are defines for the bit fields in the SYSCTL_PWRTC register.// External Reset// Power-On Reset// Brown-Out Reset// Watchdog Timer 0 Reset// Watchdog Timer 1 Reset// HSSR Reset// MOSC Failure Reset// The following are defines for the bit fields in the SYSCTL_RESC register.// VDD under BOR1 Masked Interrupt// BOR Masked Interrupt Status// Interrupt Status// Main Oscillator Failure Masked// PLL Lock Masked Interrupt Status// USB PLL Lock Masked Interrupt// MOSC Power Up Masked Interrupt// VDDA Power OK Masked Interrupt// VDD under BOR0 Masked Interrupt// The following are defines for the bit fields in the SYSCTL_MISC register.// VDD under BOR1 Interrupt Mask// Brown-Out Reset Interrupt Mask// Interrupt Mask// Main Oscillator Failure// PLL Lock Interrupt Mask// USB PLL Lock Interrupt Mask// MOSC Power Up Interrupt Mask// VDDA Power OK Interrupt Mask// VDD under BOR0 Interrupt Mask// The following are defines for the bit fields in the SYSCTL_IMC register.// Brown-Out Reset Raw Interrupt// VDD under BOR1 Raw Interrupt// Main Oscillator Failure Raw// PLL Lock Raw Interrupt Status// USB PLL Lock Raw Interrupt// MOSC Power Up Raw Interrupt// VDDA Power OK Event Raw// VDD under BOR0 Raw Interrupt// The following are defines for the bit fields in the SYSCTL_RIS register.// Port A Reset Control// Port B Reset Control// Port C Reset Control// Port D Reset Control// Port E Reset Control// Port F Reset Control// Port G Reset Control// Port H Reset Control// Port J Reset Control// Micro-DMA Reset Control// USB0 Reset Control// The following are defines for the bit fields in the SYSCTL_SRCR2 register.// UART0 Reset Control// UART1 Reset Control// UART2 Reset Control// SSI0 Reset Control// SSI1 Reset Control// QEI0 Reset Control// QEI1 Reset Control// I2C0 Reset Control// I2C1 Reset Control// Timer 0 Reset Control// Timer 1 Reset Control// Timer 2 Reset Control// Timer 3 Reset Control// Analog Comp 0 Reset Control// Analog Comp 1 Reset Control// Analog Comp 2 Reset Control// The following are defines for the bit fields in the SYSCTL_SRCR1 register.// WDT0 Reset Control// HIB Reset Control// ADC0 Reset Control// ADC1 Reset Control// PWM Reset Control// CAN0 Reset Control// CAN1 Reset Control// WDT1 Reset Control// The following are defines for the bit fields in the SYSCTL_SRCR0 register.// NMI// System control interrupt// No Action// Action// VDD (VDDS) under BOR Event// VDDA under BOR Event Action// The following are defines for the bit fields in the SYSCTL_PTBOCTL register.// VDD under BOR1 Event Action// VDD under BOR0 Event Action// The following are defines for the bit fields in the SYSCTL_PBORCTL register.// ADC Module 0 AIN0 Pin Present// ADC Module 0 AIN1 Pin Present// ADC Module 0 AIN2 Pin Present// ADC Module 0 AIN3 Pin Present// ADC Module 0 AIN4 Pin Present// ADC Module 0 AIN5 Pin Present// ADC Module 0 AIN6 Pin Present// ADC Module 0 AIN7 Pin Present// ADC Module 0 AIN8 Pin Present// ADC Module 0 AIN9 Pin Present// ADC Module 0 AIN10 Pin Present// ADC Module 0 AIN11 Pin Present// ADC Module 0 AIN12 Pin Present// ADC Module 0 AIN13 Pin Present// ADC Module 0 AIN14 Pin Present// ADC Module 0 AIN15 Pin Present// ADC Module 1 AIN0 Pin Present// ADC Module 1 AIN1 Pin Present// ADC Module 1 AIN2 Pin Present// ADC Module 1 AIN3 Pin Present// ADC Module 1 AIN4 Pin Present// ADC Module 1 AIN5 Pin Present// ADC Module 1 AIN6 Pin Present// ADC Module 1 AIN7 Pin Present// ADC Module 1 AIN8 Pin Present// ADC Module 1 AIN9 Pin Present// ADC Module 1 AIN10 Pin Present// ADC Module 1 AIN11 Pin Present// ADC Module 1 AIN12 Pin Present// ADC Module 1 AIN13 Pin Present// ADC Module 1 AIN14 Pin Present// ADC Module 1 AIN15 Pin Present// The following are defines for the bit fields in the SYSCTL_DC8 register.// DMA Channel 0// DMA Channel 1// DMA Channel 2// DMA Channel 3// DMA Channel 4// DMA Channel 5// DMA Channel 6// DMA Channel 7// DMA Channel 8// DMA Channel 9// DMA Channel 10// DMA Channel 11// DMA Channel 12// DMA Channel 13// DMA Channel 14// DMA Channel 15// DMA Channel 16// DMA Channel 17// DMA Channel 18// DMA Channel 19// DMA Channel 20// DMA Channel 21// DMA Channel 22// DMA Channel 23// DMA Channel 24// DMA Channel 25// DMA Channel 26// DMA Channel 27// DMA Channel 28// DMA Channel 29// DMA Channel 30// The following are defines for the bit fields in the SYSCTL_DC7 register.// USB0 is OTG// USB is Device or Host// USB0 is Device Only// USB Module 0 Present// USB Module 0 PHY Present// The following are defines for the bit fields in the SYSCTL_DC6 register.// PWM0 Pin Present// PWM1 Pin Present// PWM2 Pin Present// PWM3 Pin Present// PWM4 Pin Present// PWM5 Pin Present// PWM6 Pin Present// PWM7 Pin Present// PWM Extended SYNC Active// PWM Extended Fault Active// PWM Fault 0 Pin Present// PWM Fault 1 Pin Present// PWM Fault 2 Pin Present// PWM Fault 3 Pin Present// The following are defines for the bit fields in the SYSCTL_DC5 register.// Internal Code ROM Present// Micro-DMA Module Present// T3CCP0 Pin Present// T3CCP1 Pin Present// PIOSC Calibrate// 1588 Capable// Ethernet MAC Layer 0 Present// Ethernet PHY Layer 0 Present// The following are defines for the bit fields in the SYSCTL_DC4 register.// C0- Pin Present// C0+ Pin Present// C0o Pin Present// C1- Pin Present// C1+ Pin Present// C1o Pin Present// C2- Pin Present// C2+ Pin Present// C2o Pin Present// PWM Fault Pin Present// T0CCP0 Pin Present// T0CCP1 Pin Present// T1CCP0 Pin Present// T1CCP1 Pin Present// T2CCP0 Pin Present// T2CCP1 Pin Present// 32KHz Input Clock Available// The following are defines for the bit fields in the SYSCTL_DC3 register.// I2C Module 0 Speed// I2C Module 1 Speed// Timer Module 0 Present// Timer Module 1 Present// Timer Module 2 Present// Timer Module 3 Present// Analog Comparator 0 Present// Analog Comparator 1 Present// Analog Comparator 2 Present// I2S Module 0 Present// EPI Module 0 Present// The following are defines for the bit fields in the SYSCTL_DC2 register.// JTAG Present// SWD Present// SWO Trace Port Present// PLL Present// Temp Sensor Present// MPU Present// Max ADC0 Speed// Max ADC1 Speed// PLL divider of 10// Specifies a 20-MHz clock with a// PLL divider of 8// Specifies a 25-MHz clock with a// with a PLL divider of 5// Specifies a 40-MHz CPU clock// with a PLL divider of 4// Specifies a 50-MHz CPU clock// with a PLL divider of 2.5// Specifies an 80-MHz CPU clock// System Clock Divider// Watchdog Timer1 Present// The following are defines for the bit fields in the SYSCTL_DC1 register.// 256 KB of Flash// 192 KB of Flash// 128 KB of Flash// 96 KB of Flash// 64 KB of Flash// 32 KB of Flash// 16 KB of Flash// 8 KB of Flash// Flash Size// 32 KB of SRAM// 24 KB of SRAM// 20 KB of SRAM// 16 KB of SRAM// 12 KB of SRAM// 8 KB of SRAM// 6 KB of SRAM// 4 KB of SRAM// 2 KB of SRAM// SRAM Size// The following are defines for the bit fields in the SYSCTL_DC0 register.// Fully Qualified// Pilot Production (unqualified)// Engineering Sample (unqualified)// Qualification Status// RoHS-Compliance// BGA package// QFP package// Package Type// (-40C to 105C) devices. See// and extended temperature range// temperature range (-40C to 85C)// Available in both industrial// Extended temperature range// Industrial temperature range// Commercial temperature range// Temperature Range// 128-pin TQFP package// 157-pin BGA package// 144-pin LQFP package// 64-pin LQFP package// 100-pin LQFP package// Package Pin Count// TM4C129XNCZAD// TM4C129XKCZAD// TM4C129LNCZAD// TM4C129ENCZAD// TM4C129ENCPDT// TM4C129EKCPDT// TM4C129DNCZAD// TM4C129DNCPDT// TM4C129CNCZAD// TM4C129CNCPDT// TM4C1299NCZAD// TM4C1299KCZAD// TM4C1297NCZAD// TM4C1294NCZAD// TM4C1294NCPDT// TM4C1294KCPDT// TM4C1292NCZAD// TM4C1292NCPDT// TM4C1290NCZAD// TM4C1290NCPDT// TM4C123GH6ZRB// TM4C123GH6PZ// TM4C123GH6PM// TM4C123GH6PGE// TM4C123GE6PZ// TM4C123GE6PM// TM4C123FH6PM// TM4C123FE6PM// TM4C123BH6ZRB// TM4C123BH6PZ// TM4C123BH6PM// TM4C123BH6PGE// TM4C123BE6PZ// TM4C123BE6PM// TM4C123AH6PM// TM4C123AE6PM// TM4C1237H6PZ// TM4C1237H6PM// TM4C1237H6PGE// TM4C1237E6PZ// TM4C1237E6PM// TM4C1237D5PZ// TM4C1237D5PM// TM4C1236H6PM// TM4C1236E6PM// TM4C1236D5PM// TM4C1233H6PZ// TM4C1233H6PM// TM4C1233H6PGE// TM4C1233E6PZ// TM4C1233E6PM// TM4C1233D5PZ// TM4C1233D5PM// TM4C1233C3PM// TM4C1232H6PM// TM4C1232E6PM// TM4C1232D5PM// TM4C1232C3PM// TM4C1231H6PZ// TM4C1231H6PM// TM4C1231H6PGE// TM4C1231E6PZ// TM4C1231E6PM// TM4C1231D5PZ// TM4C1231D5PM// TM4C1231C3PM// TM4C1230H6PM// TM4C1230E6PM// TM4C1230D5PM// TM4C1230C3PM// Part Number// Tiva family of microcontollers// Family// fury_ib// DID1 Version// The following are defines for the bit fields in the SYSCTL_DID1 register.// Second metal layer change// First metal layer change// revision update// Initial device, or a major// Minor Revision// revision)// Revision C (second base layer// Revision B (first base layer// Revision A (initial device)// Major Revision// Tiva(TM) TM4C129-class// Tiva TM4C123x and TM4E123x// Device Class// register format.// Second version of the DID0// DID0 Version// The following are defines for the bit fields in the SYSCTL_DID0 register.// Gating Request// Cryptographic Modules Clock// Unique ID 3// Unique ID 2// Unique ID 1// Unique ID 0// Ethernet MAC Peripheral Ready// 1-Wire Peripheral Ready// LCD Controller Peripheral Ready// Timer Peripheral Ready// EEPROM Peripheral Ready// Quadrature Encoder Interface// Pulse Width Modulator Peripheral// Analog Comparator Peripheral// Analog-to-Digital Converter// Controller Area Network// Ethernet PHY Peripheral Ready// Universal Serial Bus Peripheral// Inter-Integrated Circuit// Synchronous Serial Interface// Receiver/Transmitter Peripheral// Universal Asynchronous// Hibernation Peripheral Ready// EPI Peripheral Ready// Micro Direct Memory Access// General-Purpose Input/Output// Watchdog Timer Peripheral Ready// Ethernet MAC Power Control// 1-Wire Power Control// LCD Controller Power Control// EEPROM Power Control// Pulse Width Modulator Power// Analog Comparator Power Control// Controller Area Network Power// Ethernet PHY Power Control// Universal Serial Bus Power// Inter-Integrated Circuit Power// Receiver/Transmitter Power// Hibernation Power Control// External Peripheral Interface// Micro Direct Memory Access Power// Watchdog Timer Power Control// Ethernet MAC Deep-Sleep Mode// 1-Wire Deep-Sleep Mode Clock// LCD Controller Deep-Sleep Mode// Timer Deep-Sleep Mode Clock// EEPROM Deep-Sleep Mode Clock// Pulse Width Modulator Deep-Sleep// Analog Comparator Deep-Sleep// Ethernet PHY Deep-Sleep Mode// Universal Serial Bus Deep-Sleep// Receiver/Transmitter Deep-Sleep// Hibernation Deep-Sleep Mode// EPI Deep-Sleep Mode Clock Gating// Watchdog Timer Deep-Sleep Mode// Ethernet MAC Sleep Mode Clock// 1-Wire Sleep Mode Clock Gating// LCD Controller Sleep Mode Clock// Timer Sleep Mode Clock Gating// EEPROM Sleep Mode Clock Gating// Pulse Width Modulator Sleep Mode// Analog Comparator Sleep Mode// Controller Area Network Sleep// Ethernet PHY Sleep Mode Clock// Universal Serial Bus Sleep Mode// Inter-Integrated Circuit Sleep// Receiver/Transmitter Sleep Mode// Hibernation Sleep Mode Clock// EPI Sleep Mode Clock Gating// Micro Direct Memory Access Sleep// Watchdog Timer Sleep Mode Clock// Ethernet MAC Run Mode Clock// 1-Wire Run Mode Clock Gating// LCD Controller Run Mode Clock// Timer Run Mode Clock Gating// EEPROM Run Mode Clock Gating// Quadrature Encoder Interface Run// Pulse Width Modulator Run Mode// Analog Comparator Run Mode Clock// Analog-to-Digital Converter Run// Controller Area Network Run Mode// Ethernet PHY Run Mode Clock// Universal Serial Bus Run Mode// Inter-Integrated Circuit Run// Synchronous Serial Interface Run// Receiver/Transmitter Run Mode// Hibernation Run Mode Clock// EPI Run Mode Clock Gating// Micro Direct Memory Access Run// General-Purpose Input/Output Run// Watchdog Timer Run Mode Clock// Ethernet MAC Software Reset// 1-Wire Software Reset// LCD Controller Software Reset// Timer Software Reset// EEPROM Software Reset// Pulse Width Modulator Software// Analog Comparator Software Reset// Controller Area Network Software// Ethernet PHY Software Reset// Universal Serial Bus Software// Receiver/Transmitter Software// Hibernation Software Reset// EPI Software Reset// Watchdog Timer Software Reset// Peripheral Present// Human Interface Master// Ethernet MAC Peripheral Present// 1-Wire Peripheral Present// LCD Peripheral Present// Remote Temperature Sensor// Timer Peripheral Present// EEPROM Peripheral Present// Fan Control Peripheral Present// Interface Peripheral Present// Platform Environment Control// Low Pin Count Interface// Ethernet PHY Peripheral Present// Hibernation Peripheral Present// EPI Peripheral Present// Watchdog Timer Peripheral// LCD Memory Power Control// Ethernet MAC Memory Power// Ethernet MAC Power Domain Status// USB Memory Power Control// USB Power Domain Status// Hardware System Service Request// Reset Behavior Control Register// LDO Deep-Sleep Power Control// LDO Sleep Power Control// Non-Volatile Memory Information// Device Capabilities 9// Deep-Sleep Power Configuration// Sleep Power Configuration// PLL Status// PLL Frequency 1// PLL Frequency 0// Statistics// Precision Internal Oscillator// Calibration// System Properties// Configuration// Divisor and Source Clock// Register// Deep Sleep Clock Configuration// Alternate Clock Configuration// Control Register 2// Deep Sleep Mode Clock Gating// Control Register 1// Control Register 0// Register 2// Register 1// Register 0// 0 for Main Flash and EEPROM// Memory Timing Parameter Register// Run and Sleep Mode Configuration// Main Oscillator Control// Run-Mode Clock Configuration 2// GPIO High-Performance Bus// NMI Cause Register// Run-Mode Clock Configuration// Power-Temperature Cause// Reset Cause// Masked Interrupt Status and// Interrupt Mask Control// Raw Interrupt Status// Software Reset Control 2// Software Reset Control 1// Software Reset Control 0// Power-Temp Brown Out Control// Brown-Out Reset Control// Device Capabilities 8// Device Capabilities 7// Device Capabilities 6// Device Capabilities 5// Device Capabilities 4// Device Capabilities 3// Device Capabilities 2// Device Capabilities 1// Device Capabilities 0// Device Identification 1// Device Identification 0// The following are defines for the System Control register addresses.// hw_sysctl.h - Macros used when accessing the system control hardware./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/adc.hADCSampleRateGetADCSampleRateSetADC_CLOCK_SRC_MOSCADC_CLOCK_SRC_ALTCLKADC_CLOCK_SRC_PIOSCADC_CLOCK_SRC_PLLADC_CLOCK_RATE_EIGHTHADC_CLOCK_RATE_FOURTHADC_CLOCK_RATE_HALFADC_CLOCK_RATE_FULLADC_INT_DCON_SS3ADC_INT_DCON_SS2ADC_INT_DCON_SS1ADC_INT_DCON_SS0ADC_INT_DMA_SS3ADC_INT_DMA_SS2ADC_INT_DMA_SS1ADC_INT_DMA_SS0ADC_INT_SS3ADC_INT_SS2ADC_INT_SS1ADC_INT_SS0ADC_REF_EXT_3VADC_REF_INTADC_PHASE_337_5ADC_PHASE_315ADC_PHASE_292_5ADC_PHASE_270ADC_PHASE_247_5ADC_PHASE_225ADC_PHASE_202_5ADC_PHASE_180ADC_PHASE_157_5ADC_PHASE_135ADC_PHASE_112_5ADC_PHASE_90ADC_PHASE_67_5ADC_PHASE_45ADC_PHASE_22_5ADC_PHASE_0ADC_TRIGGER_SIGNALADC_TRIGGER_WAITADC_COMP_INT_HIGH_HONCEADC_COMP_INT_HIGH_HALWAYS0x0000001EADC_COMP_INT_HIGH_ONCE0x0000001DADC_COMP_INT_HIGH_ALWAYSADC_COMP_INT_MID_ONCEADC_COMP_INT_MID_ALWAYSADC_COMP_INT_LOW_HONCEADC_COMP_INT_LOW_HALWAYSADC_COMP_INT_LOW_ONCE0x00000011ADC_COMP_INT_LOW_ALWAYSADC_COMP_INT_NONEADC_COMP_TRIG_HIGH_HONCEADC_COMP_TRIG_HIGH_HALWAYS0x00001E00ADC_COMP_TRIG_HIGH_ONCE0x00001D00ADC_COMP_TRIG_HIGH_ALWAYS0x00001C00ADC_COMP_TRIG_MID_ONCE0x00001500ADC_COMP_TRIG_MID_ALWAYS0x00001400ADC_COMP_TRIG_LOW_HONCE0x00001300ADC_COMP_TRIG_LOW_HALWAYS0x00001200ADC_COMP_TRIG_LOW_ONCE0x00001100ADC_COMP_TRIG_LOW_ALWAYSADC_COMP_TRIG_NONEADC_CTL_SHOLD_256ADC_CTL_SHOLD_128ADC_CTL_SHOLD_64ADC_CTL_SHOLD_32ADC_CTL_SHOLD_16ADC_CTL_SHOLD_8ADC_CTL_SHOLD_4ADC_CTL_CMP7ADC_CTL_CMP6ADC_CTL_CMP50x000D0000ADC_CTL_CMP40x000C0000ADC_CTL_CMP3ADC_CTL_CMP2ADC_CTL_CMP1ADC_CTL_CMP0ADC_CTL_CH230x00000107ADC_CTL_CH220x00000106ADC_CTL_CH210x00000105ADC_CTL_CH200x00000104ADC_CTL_CH190x00000103ADC_CTL_CH180x00000102ADC_CTL_CH170x00000101ADC_CTL_CH16ADC_CTL_CH15ADC_CTL_CH14ADC_CTL_CH13ADC_CTL_CH12ADC_CTL_CH11ADC_CTL_CH10ADC_CTL_CH9ADC_CTL_CH8ADC_CTL_CH7ADC_CTL_CH6ADC_CTL_CH5ADC_CTL_CH4ADC_CTL_CH3ADC_CTL_CH2ADC_CTL_CH1ADC_CTL_CH0ADC_CTL_DADC_CTL_ENDADC_CTL_IEADC_CTL_TSADC_TRIGGER_PWM_MOD1ADC_TRIGGER_PWM_MOD0ADC_TRIGGER_ALWAYSADC_TRIGGER_NEVERADC_TRIGGER_PWM3ADC_TRIGGER_PWM2ADC_TRIGGER_PWM1ADC_TRIGGER_PWM0ADC_TRIGGER_TIMERADC_TRIGGER_EXTERNALADC_TRIGGER_COMP2ADC_TRIGGER_COMP1ADC_TRIGGER_COMP0ADC_TRIGGER_PROCESSOR__DRIVERLIB_ADC_H____cplusplusexternc_linkageADCPhaseDelayGetADCPhaseDelaySetADCReferenceGetADCReferenceSetADCBusyADCSequenceDMADisableADCSequenceDMAEnableADCIntClearExADCIntStatusExADCIntEnableExADCIntDisableExADCComparatorIntClearADCComparatorIntStatusADCComparatorIntEnableADCComparatorIntDisableADCComparatorResetADCComparatorRegionSetADCComparatorConfigureADCClockConfigGetuint32_t *unsigned long *ADCClockConfigSetADCHardwareOversampleConfigureADCSoftwareOversampleDataGetADCSoftwareOversampleStepConfigureADCSoftwareOversampleConfigureADCProcessorTriggerADCSequenceDataGetADCSequenceUnderflowClearADCSequenceUnderflowADCSequenceOverflowClearADCSequenceOverflowADCSequenceStepConfigureADCSequenceConfigureADCSequenceDisableADCSequenceEnableADCIntClearADCIntStatusADCIntEnableADCIntDisableADCIntUnregisterADCIntRegister..(*)(..)// __DRIVERLIB_ADC_H__// Mark the end of the C bindings section for C++ compilers.// Prototypes for the APIs.// Values that can be passed to ADCClockConfigSet() and ADCClockConfigGet().// ADCIntClearEx() and ADCIntStatusEx().// Values that can be passed to ADCIntDisableEx(), ADCIntEnableEx(),// External 3V reference// Internal reference// Values that can be passed to ADCReferenceSet as the ui32Ref parameter.// 337.5 degrees// 315 degrees// 292.5 degrees// 270 degrees// 247.5 degrees// 225 degrees// 202.5 degrees// 180 degrees// 157.5 degrees// 135 degrees// 112.5 degrees// 90 degrees// 67.5 degrees// 45 degrees// 22.5 degrees// 0 degrees// returned from ADCPhaseDelayGet.// Values that can be passed to ADCPhaseDelaySet as the ui32Phase parameter and// Signal the synchronous trigger// Wait for the synchronous trigger// triggers.// ADCProcessorTrigger in order to get cross-module synchronous processor// Values that can be used to modify the sequence number passed to// Interrupt High Once (Hysteresis)// (Hysteresis)// Interrupt High Always// Interrupt High Once// Interrupt Mid Once// Interrupt Mid Always// Interrupt Low Once (Hysteresis)// Interrupt Low Always// Interrupt Low Once// Interrupt Disabled// Trigger High Once (Hysteresis)// Trigger High Always (Hysteresis)// Trigger High Once// Trigger High Always// Trigger Mid Once// Trigger Mid Always// Trigger Low Once (Hysteresis)// Trigger Low Always (Hysteresis)// Trigger Low Once// Trigger Low Always// Trigger Disabled// ui32Config parameter.// Values that can be passed to ADCComparatorConfigure as part of the// Sample and hold 256 ADC clocks// Sample and hold 128 ADC clocks// Sample and hold 64 ADC clocks// Sample and hold 32 ADC clocks// Sample and hold 16 ADC clocks// Sample and hold 8 ADC clocks// Sample and hold 4 ADC clocks// Select Comparator 7// Select Comparator 6// Select Comparator 5// Select Comparator 4// Select Comparator 3// Select Comparator 2// Select Comparator 1// Select Comparator 0// Input channel 23// Input channel 22// Input channel 21// Input channel 20// Input channel 19// Input channel 18// Input channel 17// Input channel 16// Input channel 15// Input channel 14// Input channel 13// Input channel 12// Input channel 11// Input channel 10// Input channel 9// Input channel 8// Input channel 7// Input channel 6// Input channel 5// Input channel 4// Input channel 3// Input channel 2// Input channel 1// Input channel 0// Differential select// Sequence end select// Interrupt enable// Temperature sensor select// parameter.// Values that can be passed to ADCSequenceStepConfigure as the ui32Config// PWM triggers from PWM1// PWM triggers from PWM0// Always event// PWM3 event// PWM2 event// PWM1 event// PWM0 event// Timer event// External event// Analog comparator 2 event// Analog comparator 1 event// Analog comparator 0 event// Processor event// Values that can be passed to ADCSequenceConfigure as the ui32Trigger// have a C binding.// If building with a C++ compiler, make all of the definitions in this header// This is part of revision 2.2.0.295 of the Tiva Peripheral Driver Library.// adc.h - ADC headers for using the ADC driver functions./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlibui32Baseui32ADCClockui32Rateui32Phaseui32Refui32SequenceNumui32IntFlagsbMaskedui32Statusui32CompbTriggerbInterruptui32LowRefui32HighRefui32Configpui32ClockDivui32ClockDivui32Factorpui32Bufferui32Countui32Stepui32Triggerui32PrioritypfnHandler/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/debug.h__error__char *ASSERT(expr)__DRIVERLIB_DEBUG_H__DEBUG// __DRIVERLIB_DEBUG_H__// will be for procedure arguments.// The ASSERT macro, which does the actual assertion checking.  Typically, this// to an API.  This is only used when doing a DEBUG build.// Prototype for the function that is called when an invalid argument is passed// Copyright (c) 2006-2020 Texas Instruments Incorporated.  All rights reserved.// debug.h - Macros for assisting debug of the driver library.pcFilenameui32Linecompiled as c1/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/lib/gcc/arm-none-eabi/5.4.1/include/stdbool.h/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/lib/gcc/arm-none-eabi/5.4.1/include/stdint.h/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/stdint.h/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/machine/_default_types.h/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/sys/features.h/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/_newlib_version.h/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/sys/_intsup.h7/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/sys/_stdint.h9/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/inc/hw_memmap.h/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/inc/hw_types.h13/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/interrupt.h/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/adc.c"driverlib/interrupt.h""driverlib/debug.h""driverlib/adc.h""inc/hw_sysctl.h""inc/hw_types.h""inc/hw_memmap.h""inc/hw_ints.h""inc/hw_adc.h"<stdint.h><stdbool.h>ADC0_BASE + ADC_O_CC0x40038000 + 0x00000FC8107397120040401073975240volatile uint32_tvolatile uint32_t *10084294966287~ADC_CC_CLKDIV_MADC0_BASE + ADC_O_PC0x40038000 + 0x00000FC440361073975236ui32Base == ADC0_BASEui32Base + ADC_O_PCui32Base + 0x00000FC4ui32Base + ADC_O_CCui32Base + 0x00000FC8(ui32ClockDiv - 1) <= (ADC_CC_CLKDIV_M >> ADC_CC_CLKDIV_S)(ui32Config & ADC_CLOCK_RATE_FULL) != 0ui32Base + ADC_O_ACTSSui32Base + 0x0000000065536truefalse(ui32Base == ADC0_BASE) || (ui32Base == ADC1_BASE)2560x100ui32SequenceNum < 4ui32Base + ADC_O_SPCui32Base + 0x00000024(ui32Phase == ADC_PHASE_0) || (ui32Phase == ADC_PHASE_22_5) || (ui32Phase == ADC_PHASE_45) || (ui32Phase == ADC_PHASE_67_5) || (ui32Phase == ADC_PHASE_90) || (ui32Phase == ADC_PHASE_112_5) || (ui32Phase == ADC_PHASE_135) || (ui32Phase == ADC_PHASE_157_5) || (ui32Phase == ADC_PHASE_180) || (ui32Phase == ADC_PHASE_202_5) || (ui32Phase == ADC_PHASE_225) || (ui32Phase == ADC_PHASE_247_5) || (ui32Phase == ADC_PHASE_270) || (ui32Phase == ADC_PHASE_292_5) || (ui32Phase == ADC_PHASE_315) || (ui32Phase == ADC_PHASE_337_5)ui32Base + ADC_O_CTLui32Base + 0x000000384294967292~ADC_CTL_VREF_M(ui32Ref == ADC_REF_INT) || (ui32Ref == ADC_REF_EXT_3V)ui32Base + ADC_O_ISCui32Base + 0x0000000Cui32Tempui32Base + ADC_O_RISui32Base + 0x00000004524288262144786432131072917504983040(ADC_INT_DCON_SS3 | ADC_INT_DCON_SS2 |
                         ADC_INT_DCON_SS1 | ADC_INT_DCON_SS0)ui32Base + ADC_O_IMui32Base + 0x00000008ui32Base + ADC_O_DCISCui32Base + 0x000000340x10000ui32Base + ADC_O_DCRICui32Base + 0x00000D003328ui32Comp < 8ui32Base + ADC_O_DCCMP0 + (ui32Comp * 4)ui32Base + 0x00000E40 + (ui32Comp * 4)3648(ui32LowRef < 4096) && (ui32LowRef <= ui32HighRef)ui32HighRef < 4096ui32Base + ADC_O_DCCTL0 + (ui32Comp * 4)ui32Base + 0x00000E00 + (ui32Comp * 4)3584ui32Valueui32Base + ADC_O_SACui32Base + 0x00000030((ui32Factor == 0) || (ui32Factor == 2) || (ui32Factor == 4) || (ui32Factor == 8) || (ui32Factor == 16) || (ui32Factor == 32) || (ui32Factor == 64))ui32Idxui32Accumui32ADCInstADC0_BASEADC_SEQADC_SEQ_STEPui32Base + ADC_SSFIFOui32Base + (0x00000048 - 0x00000040)uint8_t[3]unsigned char[3]uint8_t[2][3]unsigned char[2][3]uint8_t(*)[3]unsigned char(*)[3]uint8_t *unsigned char *ui32SequenceNum < 3((ui32SequenceNum == 0) && (ui32Count < (8 >> g_pui8OversampleFactor[ui32ADCInst][ui32SequenceNum]))) || (ui32Count < (4 >> g_pui8OversampleFactor[ui32ADCInst][ui32SequenceNum]))ui32Base + ADC_SSMUXui32Base + (0x00000040 - 0x00000040)ui32Base + ADC_SSEMUXui32Base + (0x00000058 - 0x00000040)ui32Base + ADC_SSCTLui32Base + (0x00000044 - 0x00000040)0x0000000f0x0f38400xf002400xf0(ADC_SSCTL0_IE0 |
                                              ADC_SSCTL0_END0)((ui32SequenceNum == 0) && (ui32Step < (8 >> g_pui8OversampleFactor[ui32ADCInst][ui32SequenceNum]))) || (ui32Step < (4 >> g_pui8OversampleFactor[ui32ADCInst][ui32SequenceNum]))((ui32Factor == 2) || (ui32Factor == 4) || (ui32Factor == 8)) && ((ui32SequenceNum == 0) || (ui32Factor != 8))ui32Base + ADC_O_PSSIui32Base + 0x0000002842949017600xffff00000xfui32Base + ADC_SSFSTATui32Base + (0x0000004C - 0x00000040)ui32Base + ADC_O_USTATui32Base + 0x00000018ui32Base + ADC_O_OSTATui32Base + 0x00000010ui32Base + ADC_SSTSHui32Base + (0x0000005C - 0x00000040)157286400xf00000ui32Base + ADC_SSDCui32Base + (0x00000054 - 0x00000040)ui32Base + ADC_SSOPui32Base + (0x00000050 - 0x00000040)0xF458752((ui32SequenceNum == 0) && (ui32Step < 8)) || ((ui32SequenceNum == 1) && (ui32Step < 4)) || ((ui32SequenceNum == 2) && (ui32Step < 4)) || ((ui32SequenceNum == 3) && (ui32Step < 1))ui32Genui32Base + ADC_O_EMUXui32Base + 0x00000014ui32Base + ADC_O_SSPRIui32Base + 0x000000200x3ui32Base + ADC_O_TSSELui32Base + 0x0000001C0x30((ui32Trigger & 0xF) == ADC_TRIGGER_PROCESSOR) || ((ui32Trigger & 0xF) == ADC_TRIGGER_COMP0) || ((ui32Trigger & 0xF) == ADC_TRIGGER_COMP1) || ((ui32Trigger & 0xF) == ADC_TRIGGER_COMP2) || ((ui32Trigger & 0xF) == ADC_TRIGGER_EXTERNAL) || ((ui32Trigger & 0xF) == ADC_TRIGGER_TIMER) || ((ui32Trigger & 0xF) == ADC_TRIGGER_PWM0) || ((ui32Trigger & 0xF) == ADC_TRIGGER_PWM1) || ((ui32Trigger & 0xF) == ADC_TRIGGER_PWM2) || ((ui32Trigger & 0xF) == ADC_TRIGGER_PWM3) || ((ui32Trigger & 0xF) == ADC_TRIGGER_ALWAYS) || ((ui32Trigger & 0x30) == ADC_TRIGGER_PWM_MOD0) || ((ui32Trigger & 0x30) == ADC_TRIGGER_PWM_MOD1)ui32Priority < 4655370x100010xF0000ui8Intui8Int != 0_ADCIntNumberGetstatic10747822081879048192167116801895759872268435456327680268763136655360269090816g_pui8OversampleFactorADC_SSTSH(ADC_O_SSTSH0 - ADC_O_SSMUX0)ADC_SSDC(ADC_O_SSDC0 - ADC_O_SSMUX0)ADC_SSOP(ADC_O_SSOP0 - ADC_O_SSMUX0)ADC_SSFSTAT(ADC_O_SSFSTAT0 - ADC_O_SSMUX0)ADC_SSFIFO(ADC_O_SSFIFO0 - ADC_O_SSMUX0)ADC_SSCTL(ADC_O_SSCTL0 - ADC_O_SSMUX0)ADC_SSEMUX(ADC_O_SSEMUX0 - ADC_O_SSMUX0)ADC_SSMUX(ADC_O_SSMUX0 - ADC_O_SSMUX0)(ADC_O_SSMUX1 - ADC_O_SSMUX0)(ADC_O_SSMUX0)//! @}// Close the Doxygen group.// Add in the sample interval to the configuration.// Clear out the divider bits.// If the clock divider was requested provide the current value.// Read the current configuration.// Check the argument.//! on these values.//! or \b ADC_CLOCK_RATE_EIGHTH.  See ADCClockConfigSet() for more information//! \b ADC_CLOCK_RATE_FULL, \b ADC_CLOCK_RATE_HALF, \b ADC_CLOCK_RATE_QUARTER,//! \b ADC_CLOCK_SRC_MOSC, or \b ADC_CLOCK_SRC_ALTCLK logical ORed with one of//! of one of \b ADC_CLOCK_SRC_PLL, \b ADC_CLOCK_SRC_PIOSC,//! \return The current clock configuration of the ADC defined as a combination//!//! \endverbatim//! ui32Config = ADCClockConfigGet(ADC0_BASE, &ui32ClockDiv);//! ////! // Read the current ADC clock configuration.//! uint32_t ui32Config, ui32ClockDiv;//! \verbatim//! \b Example: Read the current ADC clock configuration.//! the ADCs.//! This function returns the ADC clock configuration and the clock divider for//! selected by the \b ADC_CLOCK_SRC in use by the ADCs.//! \param pui32ClockDiv is a pointer to the input clock divider for the clock//! always be \b ADC0_BASE.//! \param ui32Base is the base address of the ADC to configure, which must//! Returns the clock configuration for the ADC.// Write the clock select and divider.// Write the sample conversion rate.// A rate must be supplied.//! \return None.//! ADCClockConfigSet(ADC0_BASE, ADC_CLOCK_SRC_PLL | ADC_CLOCK_RATE_FULL, 24);//! // clock of 20 MHz.//! // Configure the ADC to use PLL at 480 MHz divided by 24 to get an ADC//! ...//! ADCClockConfigSet(ADC0_BASE, ADC_CLOCK_SRC_PIOSC | ADC_CLOCK_RATE_HALF, 1);//! // half the rate.//! // Configure the ADC to use PIOSC divided by one (16 MHz) and sample at//! \b Example: ADC Clock Configurations//! from 1 to 64.//! with the in the correct range to use the divider.  The actual value ranges//! \b ADC_CLOCK_SRC_PLL option because it is the only clock value that can be//! into the valid range for the ADCs.  This parameter is typically only used//! The \e ui32ClockDiv parameter allows for dividing a higher frequency down//! - \b ADC_CLOCK_RATE_EIGHTH - Every either sample.//! - \b ADC_CLOCK_RATE_QUARTER - Every fourth sample.//! - \b ADC_CLOCK_RATE_HALF - Every other sample.//! - \b ADC_CLOCK_RATE_FULL - All samples.//! application.  The values are the following://! \b ADC_CLOCK_RATE values control how often samples are provided back to the//! - \b ADC_CLOCK_SRC_MOSC - The external MOSC (TM4x129 class only).//!   module (TM4x129 class only).//! - \b ADC_CLOCK_SRC_ALTCLK - The output of the ALTCLK in the system control//! - \b ADC_CLOCK_SRC_PIOSC - The internal PIOSC at 16 MHz.//! - \b ADC_CLOCK_SRC_PLL - The main PLL output (TM4x129 class only).//! is specified.//! disabled, the MOSC is used as the clock source unless ADC_CLOCK_SRC_PIOSC//! the ADC clock unless ADC_CLOCK_SRC_PIOSC is specified.  If the PLL is//! \note For TM4C123x devices, if the PLL is enabled, the PLL/25 is used as//! after dividing must be between 16 and 32 MHz.//! final frequency for TM4C123x devices must be 16 MHz and for TM4C129x parts//! to determine value configuration options.  Regardless of the source, the//! Not all values are available on all devices so check the device data sheet//! below. The \b ADC_CLOCK_SRC_* values determine the input clock for the ADC.//! of the \b ADC_CLOCK_RATE_ and one of the \b ADC_CLOCK_SRC_ values defined//! always be \b ADC0_BASE.  The \e ui32Config value is logical OR of one//! clock configuration is shared across ADC units so \e ui32Base must//! This function is used to configure the input clock to the ADC modules.  The//! the \b ADC_CLOCK_SRC value.//! \param ui32ClockDiv is the input clock divider for the clock selected by//! \b ADC_CLOCK_RATE_* values used to configure the ADC clock input.//! \param ui32Config is a combination of the \b ADC_CLOCK_SRC_ and//! Sets the clock configuration for the ADC.// Determine if the ADC is busy.//! samples are complete.//! \return Returns \b true if the ADC is sampling or \b false if all//! starting after checking the busy status.//! \b ADC_TRIGGER_NEVER on all enabled sequencers to prevent the ADC from//! highly recommended that the event trigger is changed to//! putting the device into deep sleep.  Before using this function, it is//! Use this function to detect that the ADC is finished sampling data before//! sampling data.//! currently sampling .  If \b false is returned, then the ADC is not//! This function allows the caller to determine whether or not the ADC is//! \param ui32Base is the base address of the ADC.//! Determines whether the ADC is busy or not.// Disable the DMA on the specified sequencer.// Check the arguments.//! Prevents the specified sample sequencer from generating DMA requests.//! \param ui32SequenceNum is the sample sequence number.//! \param ui32Base is the base address of the ADC module.//! Disables DMA for sample sequencers.// Enable the DMA on the specified sequencer.//! sequencer.//! Allows DMA requests to be generated based on the FIFO level of the sample//! Enables DMA for sample sequencers.// Return the phase delay.//! \b ADC_PHASE_292_5, \b ADC_PHASE_315, or \b ADC_PHASE_337_5.//! \b ADC_PHASE_202_5, \b ADC_PHASE_225, \b ADC_PHASE_247_5, \b ADC_PHASE_270,//! \b ADC_PHASE_112_5, \b ADC_PHASE_135, \b ADC_PHASE_157_5, \b ADC_PHASE_180,//! \b ADC_PHASE_22_5, \b ADC_PHASE_45, \b ADC_PHASE_67_5, \b ADC_PHASE_90,//! \return Returns the phase delay, specified as one of \b ADC_PHASE_0,//! trigger event and the start of the sample sequence.//! This function gets the current phase delay between the detection of an ADC//! Gets the phase delay between a trigger and the start of a sequence.// Set the phase delay.//! \note This capability is not available on all parts.//! module.//! single phase delay that is applied to all sample sequences within that//! N+3, N+5, and so on, coming from the second ADC).  The ADC module has a//! samples N, N+2, N+4, and so on, coming from the first ADC and samples N+1,//! it is possible to increase the sampling rate of the analog input (with//! \b ADC_PHASE_180) and having each ADC module sample the same analog input,//! delay for a pair of ADC modules (such as \b ADC_PHASE_0 and//! event and the start of the sample sequence.  By selecting a different phase//! This function sets the phase delay between the detection of an ADC trigger//! \param ui32Phase is the phase delay, specified as one of \b ADC_PHASE_0,//! Sets the phase delay between a trigger and the start of a sequence.// Return the value of the reference.//! \return The current setting of the ADC reference.//! sheet for your part to determine if it has an external reference input.//! part that is capable of using an external reference.  Consult the data//! \note The value returned by this function is only meaningful if used on a//! of \b ADC_REF_INT, or \b ADC_REF_EXT_3V.//! Returns the value of the ADC reference setting.  The returned value is one//! Returns the current setting of the ADC reference.// Set the reference.//! an external reference.//! reference.  Consult the data sheet for your part to determine if there is//! \note The ADC reference can only be selected on parts that have an external//! a 3V reference must be supplied to the AVREF pin.//! no external reference is needed.  If \b ADC_REF_EXT_3V is chosen, then//! If \b ADC_REF_INT is chosen, then an internal 3V reference is used and //! \b ADC_REF_INT, or \b ADC_REF_EXT_3V for internal or external reference//! The ADC reference is set as specified by \e ui32Ref.  It must be one of//! \param ui32Ref is the reference to use.//! Selects the ADC reference.// interrupts rather than just those which the caller has specified.// here to clear the requested bits. Doing so would clear all outstanding// Note: The interrupt bits are "W1C" so we DO NOT use a logical OR//! the interrupt source asserted).//! being immediately reentered (because the interrupt controller still sees//! actually cleared.  Failure to do so may result in the interrupt handler//! returning from the interrupt handler before the interrupt source is//! the interrupt handler (as opposed to the very last action) to avoid//! Therefore, it is recommended that the interrupt source be cleared early in//! take several clock cycles before the interrupt source is actually cleared.//! \note Because there is a write buffer in the Cortex-M processor, it may//! values.//! See the ADCIntEnableEx() function for the list of possible \b ADC_INT*//! The \e ui32IntFlags parameter is the logical OR of the \b ADC_INT_* values.//! Clears the interrupt for the specified interrupt source(s).//! \param ui32IntFlags is the bit mask of the interrupt sources to disable.//! \param ui32Base is the base address of the ADC port.//! Clears the specified ADC interrupt sources.// modified to match this behavior.// This is exactly how the hardware works so the return code is// sequences have a pending digital comparator interrupt.// is set then the return value is modified to indicate that all sample// digital comparators caused an interrupt, if the raw interrupt status// Since, the raw interrupt status only indicates that any one of the// interrupt is active.// Read the Raw interrupt status to see if a digital comparator// requested.// Return either the masked interrupt status or the raw interrupt status as//! currently active.//! The value returned is the logical OR of the \b ADC_INT_* values that are//! \return Returns the current interrupt status for the specified ADC module.//! returned; otherwise, the raw interrupt status is returned.//! If \e bMasked is set as \b true, then the masked interrupt status is//! returned.//! \param bMasked specifies whether masked or raw interrupt status is//! Gets interrupt status for the specified ADC module.// Enable the requested interrupts.//!   sequence 3.//! - \b ADC_INT_DCON_SS3 - interrupt due to digital comparator on ADC sample//!   sequence 2.//! - \b ADC_INT_DCON_SS2 - interrupt due to digital comparator on ADC sample//!   sequence 1.//! - \b ADC_INT_DCON_SS1 - interrupt due to digital comparator on ADC sample//!   sequence 0.//! - \b ADC_INT_DCON_SS0 - interrupt due to digital comparator on ADC sample//! - \b ADC_INT_DMA_SS3 - interrupt due to DMA on ADC sample sequence 3.//! - \b ADC_INT_DMA_SS2 - interrupt due to DMA on ADC sample sequence 2.//! - \b ADC_INT_DMA_SS1 - interrupt due to DMA on ADC sample sequence 1.//! - \b ADC_INT_DMA_SS0 - interrupt due to DMA on ADC sample sequence 0.//! - \b ADC_INT_SS3 - interrupt due to ADC sample sequence 3.//! - \b ADC_INT_SS2 - interrupt due to ADC sample sequence 2.//! - \b ADC_INT_SS1 - interrupt due to ADC sample sequence 1.//! - \b ADC_INT_SS0 - interrupt due to ADC sample sequence 0.//! The \e ui32IntFlags parameter is the logical OR of any of the following://! disabled sources have no effect on the processor.//! sources that are enabled can be reflected to the processor interrupt;//! This function enables the indicated ADC interrupt sources.  Only the//! Enables ADC interrupt sources.// Disable the requested interrupts.//! This function disables the indicated ADC interrupt sources.  Only the//! Disables ADC interrupt sources.// Clear the interrupt.//! The specified interrupt status is cleared.//! \param ui32Status is the bit-mapped interrupts status to clear.//! Clears sample sequence comparator interrupt source.// Return the digital comparator interrupt status.//! \return The current comparator interrupt status.//! status is sequence agnostic.//! This function returns the digital comparator interrupt status bits.  This//! Gets the current comparator interrupt status.// Enable this sample sequence interrupt.//! This function enables the requested sample sequence comparator interrupt.//! Enables a sample sequence comparator interrupt.// Disable this sample sequence comparator interrupt.//! This function disables the requested sample sequence comparator interrupt.//! Disables a sample sequence comparator interrupt.// comparator conditions.// Set the appropriate bits to reset the trigger and/or interrupt//! value to prevent stale data from being used when a sequence is enabled.//! function allows the comparator to be reset to its initial//! Because the digital comparator uses current and previous ADC values, this//! \param bInterrupt is the flag to indicate reset of Interrupt conditions.//! \param bTrigger is the flag to indicate reset of Trigger conditions.//! \param ui32Comp is the index of the comparator.//! Resets the current ADC digital comparator conditions.// Save the new region settings.//!   value.//! - \b high-band is defined as any ADC value greater than the \e ui32HighRef//!   value but less than or equal to the \e ui32HighRef value.//! - \b mid-band is defined as any ADC value greater than the \e ui32LowRef//!   \e ui32LowRef value.//! - \b low-band is defined as any ADC value less than or equal to the//! The ADC digital comparator operation is based on three ADC value regions://! \param ui32HighRef is the reference point for the mid/high band threshold.//! \param ui32LowRef is the reference point for the low/mid band threshold.//! \param ui32Comp is the index of the comparator to configure.//! Defines the ADC digital comparator regions.// Save the new setting.//! since the last trigger output.//! transitions into high-band only if ADC output has been in the low-band//! - \b ADC_COMP_INT_HIGH_HONCE to generate ADC interrupt once when ADC output//! output is in the high-band only if ADC output has been in the low-band//! - \b ADC_COMP_INT_HIGH_HALWAYS to always generate ADC interrupt when ADC//! transitions into the high-band.//! - \b ADC_COMP_INT_HIGH_ONCE to generate ADC interrupt once when ADC output//! output is in the high-band.//! - \b ADC_COMP_INT_HIGH_ALWAYS to always generate ADC interrupt when ADC//! transitions into the mid-band.//! - \b ADC_COMP_INT_MID_ONCE to generate ADC interrupt once when ADC output//! output is in the mid-band.//! - \b ADC_COMP_INT_MID_ALWAYS to always generate ADC interrupt when ADC//! transitions into low-band only if ADC output has been in the high-band//! - \b ADC_COMP_INT_LOW_HONCE to generate ADC interrupt once when ADC output//! output is in the low-band only if ADC output has been in the high-band//! - \b ADC_COMP_INT_LOW_HALWAYS to always generate ADC interrupt when ADC//! transitions into the low-band.//! - \b ADC_COMP_INT_LOW_ONCE to generate ADC interrupt once when ADC output//! output is in the low-band.//! - \b ADC_COMP_INT_LOW_ALWAYS to always generate ADC interrupt when ADC//! - \b ADC_COMP_INT_NONE to never generate ADC interrupt.//! The \b ADC_COMP_INT_xxx term can take on the following values://! low-band since the last trigger output.//! output transitions into high-band only if ADC output has been in the//! - \b ADC_COMP_TRIG_HIGH_HONCE to trigger PWM fault condition once when ADC//! ADC output is in the high-band only if ADC output has been in the low-band//! - \b ADC_COMP_TRIG_HIGH_HALWAYS to always trigger PWM fault condition when//! output transitions into the high-band.//! - \b ADC_COMP_TRIG_HIGH_ONCE to trigger PWM fault condition once when ADC//! ADC output is in the high-band.//! - \b ADC_COMP_TRIG_HIGH_ALWAYS to always trigger PWM fault condition when//! output transitions into the mid-band.//! - \b ADC_COMP_TRIG_MID_ONCE to trigger PWM fault condition once when ADC//! ADC output is in the mid-band.//! - \b ADC_COMP_TRIG_MID_ALWAYS to always trigger PWM fault condition when//! high-band since the last trigger output.//! output transitions into low-band only if ADC output has been in the//! - \b ADC_COMP_TRIG_LOW_HONCE to trigger PWM fault condition once when ADC//! ADC output is in the low-band only if ADC output has been in the high-band//! - \b ADC_COMP_TRIG_LOW_HALWAYS to always trigger PWM fault condition when//! output transitions into the low-band.//! - \b ADC_COMP_TRIG_LOW_ONCE to trigger PWM fault condition once when ADC//! ADC output is in the low-band.//! - \b ADC_COMP_TRIG_LOW_ALWAYS to always trigger PWM fault condition when//! - \b ADC_COMP_TRIG_NONE to never trigger PWM fault condition.//! The \b ADC_COMP_TRIG_xxx term can take on the following values://! \b ADC_COMP_INT_xxx values.//! the result of a logical OR operation between the \b ADC_COMP_TRIG_xxx, and//! This function configures a comparator.  The \e ui32Config parameter is//! \param ui32Config is the configuration of the comparator.//! Configures an ADC digital comparator.// Write the shift factor to the ADC to configure the hardware oversampler.// Convert the oversampling factor to a shift factor.//! throughput of a 250 k samples/second ADC to 62.5 k samples/second.//! of throughput.  For example, enabling 4x oversampling reduces the//! Enabling hardware averaging increases the precision of the ADC at the cost//! fully oversampled analog input reading.//! oversampling APIs; each sample written into the sample sequencer FIFO is a//! not reduce the depth of the sample sequencers like the software//! Hardware oversampling applies uniformly to all sample sequencers.  It does//! oversampling.//! Specifying an oversampling factor of zero disables hardware//! different oversampling rates are supported; 2x, 4x, 8x, 16x, 32x, and 64x.//! accomplished by averaging multiple samples from the same analog input.  Six//! be used to provide better resolution on the sampled data.  Oversampling is//! This function configures the hardware oversampling for the ADC, which can//! \param ui32Factor is the number of samples to be averaged.//! Configures the hardware oversampling factor of the ADC.// Write the averaged sample to the output buffer.// Read the FIFO and add it to the accumulator.// Compute the sum of the samples.// Read the samples from the FIFO until it is empty.// Get the offset of the sequence to be read.// Evaluate the ADC Instance.//! available, for example as a result of receiving an interrupt.//! read only the samples that are available and wait until enough data is//! then incorrect results are returned.  It is the caller's responsibility to//! samples in the hardware FIFO to satisfy this many oversampled data items,//! number of samples are copied into the data buffer; if there are not enough//! a memory resident buffer with software oversampling applied.  The requested//! This function copies data from the specified sample sequence output FIFO to//! \param ui32Count is the number of samples to be read.//! \param pui32Buffer is the address where the data is stored.//! Gets the captured data for a sample sequence using software oversampling.// Go to the next hardware step.// Set the control value for this step.// Set the upper bits of the analog mux value for this step.// Set the analog mux value for this step.// oversampled sequence.// Loop through the hardware steps that make up this step of the software// Compute the shift for the bits that control this step.// Get the offset of the sequence to be configured.//! of \e ui32Config is the same as defined for ADCSequenceStepConfigure().//! the oversampling factor set by ADCSoftwareOversampleConfigure().  The value//! software oversampling feature.  The number of steps available depends on//! This function configures a step of the sample sequencer when using the//! \param ui32Config is the configuration of this step.//! \param ui32Step is the step to be configured.//! Configures a step of the software oversampled sequencer.// Save the shift factor.//! oversampling is only available on the first sample sequencer.//! can only provide four samples per trigger.  This also means that 8x//! sample sequencer by two; so 2x oversampling on the first sample sequencer//! supported).  Oversampling by 2x (for example) divides the depth of the//! one sample in depth (that is, the fourth sample sequencer is not//! Oversampling is only supported on the sample sequencers that are more than//! Three different oversampling rates are supported; 2x, 4x, and 8x.//! accomplished by averaging multiple samples from the same analog input.//! This function configures the software oversampling for the ADC, which can//! Configures the software oversampling factor of the ADC.// Generate a processor trigger for this sample sequence.//! synchronous manner.//! allowing multiple ADCs to start from a processor-initiated trigger in a//! trigger to a different ADC module that specifies \b ADC_TRIGGER_SIGNAL,//! processor-initiated trigger is delayed until a later processor-initiated//! \b ADC_TRIGGER_WAIT is ORed into the sequence number, the//! sequence trigger is configured to \b ADC_TRIGGER_PROCESSOR.  If//! This function triggers a processor-initiated sample sequence if the sample//! \b ADC_TRIGGER_WAIT or \b ADC_TRIGGER_SIGNAL optionally ORed into it.//! \param ui32SequenceNum is the sample sequence number, with//! Causes a processor trigger for a sample sequence.// Return the number of samples read.// Increment the count of samples read.// Read the FIFO and copy it to the destination.// Read samples from the FIFO until it is empty.//! \return Returns the number of samples copied to the buffer.//! if it is in the process of being executed.//! that are presently available, which may not be the entire sample sequence//! enough to hold that many samples.  This function only returns the samples//! hardware FIFO are copied into the buffer, which is assumed to be large//! to a memory resident buffer.  The number of samples available in the//! This function copies data from the specified sample sequencer output FIFO//! Gets the captured data for a sample sequence.// Clear the underflow condition for this sequence.//! subsequent underflow condition (it otherwise causes no harm).//! sequencers.  The underflow condition must be cleared in order to detect a//! This function clears an underflow condition on one of the sample//! Clears the underflow condition on a sample sequence.// Determine if there was an underflow on this sequence.//! was.//! \return Returns zero if there was not an underflow, and non-zero if there//! Underflow happens if too many samples are read from the FIFO.//! This function determines if a sample sequence underflow has occurred.//! Determines if a sample sequence underflow occurred.// Clear the overflow condition for this sequence.//! overflow condition (it otherwise causes no harm).//! The overflow condition must be cleared in order to detect a subsequent//! This function clears an overflow condition on one of the sample sequences.//! Clears the overflow condition on a sample sequence.// Determine if there was an overflow on this sequence.//! \return Returns zero if there was not an overflow, and non-zero if there//! the next trigger occurs.//! Overflow happens if the captured samples are not read from the FIFO before//! This function determines if a sample sequence overflow has occurred.//! Determines if a sample sequence overflow occurred.// Disable digital comparator if not specified.// Enable the comparator.// Program the comparator for the specified step.// Enable digital comparator if specified in the ui32Config bit-fields.// reserved bits are ignored on write access.// all devices, however on devices that do not support this feature these// Set the sample and hold time for this step.  This is not available on//! configuration.//! is specified; this function does not check the validity of the specified//! It is the responsibility of the caller to ensure that a valid configuration//! undefined results are returned by the ADC.//! differential mode is selected when the temperature sensor is being sampled,//! and 3) or undefined results are returned by the ADC.  Additionally, if//! sample (for example, \b ADC_CTL_CH0 for 0 and 1, or \b ADC_CTL_CH1 for 2//! and 1).  The channel select must be the number of the channel pair to//! Differential mode only works with adjacent channel pairs (for example, 0//! third sample sequencer, and can only be zero for the fourth sample//! seven for the first sample sequencer, from zero to three for the second and//! captured by the ADC when the trigger occurs.  It can range from zero to//! The \e ui32Step parameter determines the order in which the samples are//! written into the ADC sequence data FIFO.//! \b ADC_CTL_CMP0 through \b ADC_CTL_CMP7 selects, the ADC sample is NOT//! \note If the Digital Comparator is present and enabled using the//! ADC at the appropriate time when the trigger for this sequence occurs.//! \b ADC_CTL_CMP0 through \b ADC_CTL_CMP7.  The configuration is used by the//! configured to send the ADC sample to the selected comparator using//! digital comparators are present on the device, this step may also be//! interrupt when the step is complete (the \b ADC_CTL_IE bit).  If the//! the sequence (the \b ADC_CTL_END bit) and it can be configured to cause an//! \b ADC_CTL_TS bit).  Additionally, this step can be defined as the last in//! values), and the internal temperature sensor can be selected (the//! be sampled can be chosen (the \b ADC_CTL_CH0 through \b ADC_CTL_CH23//! \b ADC_CTL_D bit selects differential operation when set), the channel to//! ADC can be configured for single-ended or differential operation (the//! This function configures the ADC for one step of a sample sequence.  The//! ADC clocks.//! \b ADC_CTL_SHOLD_128 or \b ADC_CTL_SHOLD_256. The default sample time is 4//! \b ADC_CTL_SHOLD_16, \b ADC_CTL_SHOLD_32, \b ADC_CTL_SHOLD_64, //! logical OR of one of \b ADC_CTL_SHOLD_4, \b ADC_CTL_SHOLD_8,//! On some parts the sample and hold time can be increased by including a //! the digital comparator selects (\b ADC_CTL_CMP0 through \b ADC_CTL_CMP7).//! input channel selects (\b ADC_CTL_CH0 through \b ADC_CTL_CH23), and one of//! of \b ADC_CTL_TS, \b ADC_CTL_IE, \b ADC_CTL_END, \b ADC_CTL_D, one of the//! \param ui32Config is the configuration of this step; is a logical OR//! Configure a step of the sample sequencer.// Set the shift for the module and generator// Set the source PWM module for this sequence's PWM triggers.// Set the priority for this sample sequence.// Set the trigger event for this sample sequence.// Compute the shift for the bits that control this sample sequence.// Check the arugments.//! priorities.//! unique priority; it is up to the caller to guarantee the uniqueness of the//! programming the priority among a set of sample sequences, each must have//! represents the highest priority and 3 the lowest.  Note that when//! The \e ui32Priority parameter is a value between 0 and 3, where 0//! availability of triggers.//! members; consult the data sheet for the device in question to determine the//! Note that not all trigger sources are available on all Tiva family//!                             PWM0 to PWM3 triggers for this sequence.//! - \b ADC_TRIGGER_PWM_MOD1 - Selects PWM module 1 as the source of the//! - \b ADC_TRIGGER_PWM_MOD0 - Selects PWM module 0 as the source of the//! routed for this sequence://! \e ui32Trigger to select the PWM module from which the triggers will be//! \b ADC_TRIGGER_PWM3 is specified, one of the following should be ORed into//! When \b ADC_TRIGGER_PWM0, \b ADC_TRIGGER_PWM1, \b ADC_TRIGGER_PWM2 or//!                           there is not a higher priority source active).//!                           sample sequence to capture repeatedly (so long as//! - \b ADC_TRIGGER_ALWAYS - A trigger that is always asserted, causing the//!                         configured with PWMGenIntTrigEnable().//! - \b ADC_TRIGGER_PWM3 - A trigger generated by the fourth PWM generator;//! - \b ADC_TRIGGER_PWM2 - A trigger generated by the third PWM generator;//! - \b ADC_TRIGGER_PWM1 - A trigger generated by the second PWM generator;//! - \b ADC_TRIGGER_PWM0 - A trigger generated by the first PWM generator;//!                          TimerControlTrigger().//! - \b ADC_TRIGGER_TIMER - A trigger generated by a timer; configured with//!                             GPIOADCTriggerEnable() function.//!                             select from any GPIO using the//!                             B4 pin.  Note that some microcontrollers can//! - \b ADC_TRIGGER_EXTERNAL - A trigger generated by an input from the Port//!                          comparator; configured with ComparatorConfigure().//! - \b ADC_TRIGGER_COMP2 - A trigger generated by the third analog//! - \b ADC_TRIGGER_COMP1 - A trigger generated by the second analog//! - \b ADC_TRIGGER_COMP0 - A trigger generated by the first analog//!                              ADCProcessorTrigger() function.//! - \b ADC_TRIGGER_PROCESSOR - A trigger generated by the processor, via the//! The \e ui32Trigger parameter can take on the following values://! priority (with respect to other sample sequencer execution) are set.//! and sequencer three captures a single sample.  The trigger condition and//! up to eight samples, sequencers one and two capture up to four samples,//! Valid sample sequencers range from zero to three; sequencer zero captures//! This function configures the initiation criteria for a sample sequence.//! respect to the other sample sequences.//! \param ui32Priority is the relative priority of the sample sequence with//! sequence; must be one of the \b ADC_TRIGGER_* values.//! \param ui32Trigger is the trigger source that initiates the sample//! Configures the trigger source and priority of a sample sequence.// Disable the specified sequences.//! is detected.  A sample sequence must be disabled before it is configured.//! Prevents the specified sample sequence from being captured when its trigger//! Disables a sample sequence.// Enable the specified sequence.//! detected.  A sample sequence must be configured before it is enabled.//! Allows the specified sample sequence to be captured when its trigger is//! Enables a sample sequence.//! the interrupt from being triggered again immediately upon exit.//! asserts.  This function must be called in the interrupt handler to keep//! The specified sample sequence interrupt is cleared, so that it no longer//! Clears sample sequence interrupt source.// Return the interrupt status// appropriate sequence bit.// If the digital comparator status bit is set, reflect it to the// Return either the interrupt status or the raw interrupt status as//! \return The current raw or masked interrupt status.//! are allowed to reflect to the processor can be returned.//! sequence.  Either the raw interrupt status or the status of interrupts that//! This function returns the interrupt status for the specified sample//! the masked interrupt status is required.//! \param bMasked is false if the raw interrupt status is required and true if//! Gets the current interrupt status.// Clear any outstanding interrupts on this sample sequence.//! interrupt.//! outstanding interrupts are cleared before enabling the sample sequence//! This function enables the requested sample sequence interrupt.  Any//! Enables a sample sequence interrupt.// Disable this sample sequence interrupt.//! This function disables the requested sample sequence interrupt.//! Disables a sample sequence interrupt.// Unregister the interrupt handler.// Disable the interrupt.// Determine the interrupt to unregister based on the sequence number.//! handlers.//! \sa IntRegister() for important information about registering interrupt//! must be disabled via ADCIntDisable().//! the global interrupt in the interrupt controller; the sequence interrupt//! This function unregisters the interrupt handler.  This function disables//! Unregisters the interrupt handler for an ADC interrupt.// Enable the timer interrupt.// Register the interrupt handler.// Determine the interrupt to register based on the sequence number.//! interrupt source via ADCIntClear().//! ADCIntEnable().  It is the interrupt handler's responsibility to clear the//! interrupt controller; the sequence interrupt must be enabled with//! interrupt occurs.  This function enables the global interrupt in the//! This function sets the handler to be called when a sample sequence//! ADC sample sequence interrupt occurs.//! \param pfnHandler is a pointer to the function to be called when the//! Registers an interrupt handler for an ADC interrupt.//! does not exist.//! \return Returns the ADC sequence interrupt number or 0 if the interrupt//! number provided in the \e ui32Base and \e ui32SequenceNum parameters.//! This function returns the interrupt number for the ADC module and sequence//! number.//! Returns the interrupt number for a given ADC base address and sequence// sequencers.// The currently configured software oversampling factor for each of the ADC// sequencer's registers.// These defines are used by the ADC driver to simplify access to the ADC//! @{//! \addtogroup adc_api// adc.c - Driver for the ADC./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/inc/hw_aes.hAES_DMAIC_CINAES_DMAIC_COUTAES_DMAIC_DINAES_DMAIC_DOUTAES_DMAMIS_CINAES_DMAMIS_COUTAES_DMAMIS_DINAES_DMAMIS_DOUTAES_DMARIS_CINAES_DMARIS_COUTAES_DMARIS_DINAES_DMARIS_DOUTAES_DMAIM_CINAES_DMAIM_COUTAES_DMAIM_DINAES_DMAIM_DOUTAES_DIRTYBITS_S_ACCESSAES_DIRTYBITS_S_DIRTYAES_IRQENABLE_CONTEXT_INAES_IRQENABLE_DATA_INAES_IRQENABLE_DATA_OUTAES_IRQENABLE_CONTEXT_OUTAES_IRQSTATUS_CONTEXT_INAES_IRQSTATUS_DATA_INAES_IRQSTATUS_DATA_OUTAES_IRQSTATUS_CONTEXT_OUTAES_SYSSTATUS_RESETDONEAES_SYSCONFIG_SOFTRESETAES_SYSCONFIG_DMA_REQ_DATA_IN_ENAES_SYSCONFIG_DMA_REQ_DATA_OUT_ENAES_SYSCONFIG_DMA_REQ_CONTEXT_IN_ENAES_SYSCONFIG_DMA_REQ_CONTEXT_OUT_ENAES_SYSCONFIG_MAP_CONTEXT_OUT_ON_DATA_OUTAES_SYSCONFIG_KEYENCAES_SYSCONFIG_K3AES_REVISION_SAES_REVISION_MAES_TAG_OUT_3_HASH_SAES_TAG_OUT_3_HASH_MAES_TAG_OUT_2_HASH_SAES_TAG_OUT_2_HASH_MAES_TAG_OUT_1_HASH_SAES_TAG_OUT_1_HASH_MAES_TAG_OUT_0_HASH_SAES_TAG_OUT_0_HASH_MAES_DATA_IN_3_DATA_SAES_DATA_IN_3_DATA_MAES_DATA_IN_2_DATA_SAES_DATA_IN_2_DATA_MAES_DATA_IN_1_DATA_SAES_DATA_IN_1_DATA_MAES_DATA_IN_0_DATA_SAES_DATA_IN_0_DATA_MAES_AUTH_LENGTH_AUTH_SAES_AUTH_LENGTH_AUTH_MAES_C_LENGTH_1_LENGTH_SAES_C_LENGTH_1_LENGTH_MAES_C_LENGTH_0_LENGTH_SAES_C_LENGTH_0_LENGTH_MAES_CTRL_CCM_M_SAES_CTRL_OUTPUT_READYAES_CTRL_INPUT_READYAES_CTRL_DIRECTIONAES_CTRL_KEY_SIZE_256AES_CTRL_KEY_SIZE_192AES_CTRL_KEY_SIZE_128AES_CTRL_KEY_SIZE_MAES_CTRL_MODEAES_CTRL_CTRAES_CTRL_CTR_WIDTH_128AES_CTRL_CTR_WIDTH_96AES_CTRL_CTR_WIDTH_64AES_CTRL_CTR_WIDTH_32AES_CTRL_CTR_WIDTH_MAES_CTRL_ICMAES_CTRL_CFBAES_CTRL_XTS_K2ILJ00x00001800AES_CTRL_XTS_K2IJLAES_CTRL_XTS_TWEAKJLAES_CTRL_XTS_NOPAES_CTRL_XTS_MAES_CTRL_F8AES_CTRL_F9AES_CTRL_CBCMACAES_CTRL_GCM_HY0CALCAES_CTRL_GCM_HLY0CALCAES_CTRL_GCM_HLY0ZEROAES_CTRL_GCM_NOPAES_CTRL_GCM_MAES_CTRL_CCMAES_CTRL_CCM_L_80x00380000AES_CTRL_CCM_L_4AES_CTRL_CCM_L_2AES_CTRL_CCM_L_MAES_CTRL_CCM_M_MAES_CTRL_SAVE_CONTEXTAES_CTRL_SVCTXTRDYAES_CTRL_CTXTRDYAES_IV_IN_3_DATA_SAES_IV_IN_3_DATA_MAES_IV_IN_2_DATA_SAES_IV_IN_2_DATA_MAES_IV_IN_1_DATA_SAES_IV_IN_1_DATA_MAES_IV_IN_0_DATA_SAES_IV_IN_0_DATA_MAES_KEY1_1_KEY_SAES_KEY1_1_KEY_MAES_KEY1_0_KEY_SAES_KEY1_0_KEY_MAES_KEY1_3_KEY_SAES_KEY1_3_KEY_MAES_KEY1_2_KEY_SAES_KEY1_2_KEY_MAES_KEY1_5_KEY_SAES_KEY1_5_KEY_MAES_KEY1_4_KEY_SAES_KEY1_4_KEY_MAES_KEY1_7_KEY_SAES_KEY1_7_KEY_MAES_KEY1_6_KEY_SAES_KEY1_6_KEY_MAES_KEY2_1_KEY_SAES_KEY2_1_KEY_MAES_KEY2_0_KEY_SAES_KEY2_0_KEY_MAES_KEY2_3_KEY_SAES_KEY2_3_KEY_MAES_KEY2_2_KEY_SAES_KEY2_2_KEY_MAES_KEY2_5_KEY_SAES_KEY2_5_KEY_MAES_KEY2_4_KEY_SAES_KEY2_4_KEY_MAES_KEY2_7_KEY_SAES_KEY2_7_KEY_MAES_KEY2_6_KEY_SAES_KEY2_6_KEY_MAES_O_DMAIC0xFFFFA02CAES_O_DMAMIS0xFFFFA028AES_O_DMARIS0xFFFFA024AES_O_DMAIM0xFFFFA020AES_O_DIRTYBITSAES_O_IRQENABLEAES_O_IRQSTATUSAES_O_SYSSTATUSAES_O_SYSCONFIGAES_O_REVISIONAES_O_TAG_OUT_3AES_O_TAG_OUT_2AES_O_TAG_OUT_1AES_O_TAG_OUT_0AES_O_DATA_IN_3AES_O_DATA_IN_2AES_O_DATA_IN_1AES_O_DATA_IN_0AES_O_AUTH_LENGTHAES_O_C_LENGTH_1AES_O_C_LENGTH_0AES_O_CTRLAES_O_IV_IN_3AES_O_IV_IN_2AES_O_IV_IN_1AES_O_IV_IN_0AES_O_KEY1_10x0000003CAES_O_KEY1_0AES_O_KEY1_3AES_O_KEY1_2AES_O_KEY1_50x0000002CAES_O_KEY1_4AES_O_KEY1_7AES_O_KEY1_6AES_O_KEY2_1AES_O_KEY2_0AES_O_KEY2_3AES_O_KEY2_2AES_O_KEY2_5AES_O_KEY2_4AES_O_KEY2_7AES_O_KEY2_6__HW_AES_H__// __HW_AES_H__// Context In DMA Done Raw// Context Out DMA Done Masked// Data In DMA Done Interrupt Clear// Data Out DMA Done Interrupt// The following are defines for the bit fields in the AES_O_DMAIC register.// Data In DMA Done Masked// Data Out DMA Done Masked// The following are defines for the bit fields in the AES_O_DMAMIS register.// Context Out DMA Done Raw// Data In DMA Done Raw Interrupt// Data Out DMA Done Raw Interrupt// The following are defines for the bit fields in the AES_O_DMARIS register.// Mask// Context In DMA Done Interrupt// Context Out DMA Done Interrupt// Data In DMA Done Interrupt Mask// Data Out DMA Done Interrupt Mask// The following are defines for the bit fields in the AES_O_DMAIM register.// AES Access Bit// AES Dirty Bit// The following are defines for the bit fields in the AES_O_DIRTYBITS// Context In Interrupt Enable// Data In Interrupt Enable// Data Out Interrupt Enable// Context Out Interrupt Enable// The following are defines for the bit fields in the AES_O_IRQENABLE// Context In Interrupt Status// Data In Interrupt Status// Data Out Interrupt Status// Context Output Interrupt Status// The following are defines for the bit fields in the AES_O_IRQSTATUS// Reset Done// The following are defines for the bit fields in the AES_O_SYSSTATUS// Soft reset// DMA Request Data In Enable// DMA Request Data Out Enable// DMA Request Context In Enable// DMA Request Context Out Enable// Enable// Map Context Out on Data Out// Key Encoding// K3 Select// The following are defines for the bit fields in the AES_O_SYSCONFIG// Revision number// The following are defines for the bit fields in the AES_O_REVISION register.// Hash Result// The following are defines for the bit fields in the AES_O_TAG_OUT_3// The following are defines for the bit fields in the AES_O_TAG_OUT_2// The following are defines for the bit fields in the AES_O_TAG_OUT_1// The following are defines for the bit fields in the AES_O_TAG_OUT_0// Plaintext/Ciphertext// Secure Data RW// The following are defines for the bit fields in the AES_O_DATA_IN_3// The following are defines for the bit fields in the AES_O_DATA_IN_2// The following are defines for the bit fields in the AES_O_DATA_IN_1// The following are defines for the bit fields in the AES_O_DATA_IN_0// Authentication Data Length// The following are defines for the bit fields in the AES_O_AUTH_LENGTH// Data Length// The following are defines for the bit fields in the AES_O_C_LENGTH_1// The following are defines for the bit fields in the AES_O_C_LENGTH_0// Output Ready Status// Input Ready Status// Encryption/Decryption Selection// Key is 256 bits// Key is 192 bits// Key is 128 bits// Key Size// ECB/CBC Mode// Counter Mode// Counter is 128 bits// Counter is 96 bits// Counter is 64 bits// Counter is 32 bits// AES-CTR Mode Counter Width// AES Integer Counter Mode (ICM)// mode (CFB128) Enable// Full block AES cipher feedback// loaded via IV)// Key2 and n are loaded; j=0 (n is// the AAD length register)// loaded via IV, j is loaded via// Key2, n and j are loaded (n is// value and j loaded (value is// Previous/intermediate tweak// No operation// AES-XTS Operation Enabled// AES f8 Mode Enable// AES f9 Mode Enable// AES-CBC MAC Enable// internally)// Y0-encrypted calculated// Autonomous GHASH (both H and// internally// GHASH with H loaded and// Y0-encrypted forced to zero// AES-GCM Mode Enable// AES-CCM Mode Enable// width = 8// width = 4// width = 2// L Value// Counter with CBC-MAC (CCM)// TAG or Result IV Save// AES TAG/IV Block(s) Ready// Context Data Registers Ready// The following are defines for the bit fields in the AES_O_CTRL register.// Initialization Vector Input// The following are defines for the bit fields in the AES_O_IV_IN_3 register.// The following are defines for the bit fields in the AES_O_IV_IN_2 register.// The following are defines for the bit fields in the AES_O_IV_IN_1 register.// The following are defines for the bit fields in the AES_O_IV_IN_0 register.// Key Data// The following are defines for the bit fields in the AES_O_KEY1_1 register.// The following are defines for the bit fields in the AES_O_KEY1_0 register.// The following are defines for the bit fields in the AES_O_KEY1_3 register.// The following are defines for the bit fields in the AES_O_KEY1_2 register.// The following are defines for the bit fields in the AES_O_KEY1_5 register.// The following are defines for the bit fields in the AES_O_KEY1_4 register.// The following are defines for the bit fields in the AES_O_KEY1_7 register.// The following are defines for the bit fields in the AES_O_KEY1_6 register.// The following are defines for the bit fields in the AES_O_KEY2_1 register.// The following are defines for the bit fields in the AES_O_KEY2_0 register.// The following are defines for the bit fields in the AES_O_KEY2_3 register.// The following are defines for the bit fields in the AES_O_KEY2_2 register.// The following are defines for the bit fields in the AES_O_KEY2_5 register.// The following are defines for the bit fields in the AES_O_KEY2_4 register.// The following are defines for the bit fields in the AES_O_KEY2_7 register.// The following are defines for the bit fields in the AES_O_KEY2_6 register.// AES DMA Interrupt Clear// AES DMA Masked Interrupt Status// AES DMA Raw Interrupt Status// AES DMA Interrupt Mask// AES Dirty Bits// AES Interrupt Enable// AES Interrupt Status// AES System Status// AES System Configuration// AES IP Revision Identifier// AES Hash Tag Out 3// AES Hash Tag Out 2// AES Hash Tag Out 1// AES Hash Tag Out 0// AES Data RW Plaintext/Ciphertext// AES Authentication Data Length// AES Crypto Data Length 1// AES Crypto Data Length 0// AES Control// AES Initialization Vector Input// AES Key 1_1// AES Key 1_0// AES Key 1_3// AES Key 1_2// AES Key 1_5// AES Key 1_4// AES Key 1_7// AES Key 1_6// AES Key 2_1// AES Key 2_0// AES Key 2_3// AES Key 2_2// AES Key 2_5// AES Key 2_4// AES Key 2_7// AES Key 2_6// The following are defines for the AES register offsets.// Copyright (c) 2012-2020 Texas Instruments Incorporated.  All rights reserved.// hw_aes.h - Macros used when accessing the AES hardware./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/inc/hw_ccm.hCCM_CRCRSLTPP_RSLTPP_SCCM_CRCRSLTPP_RSLTPP_MCCM_CRCDIN_DATAIN_SCCM_CRCDIN_DATAIN_MCCM_CRCSEED_SEED_SCCM_CRCSEED_SEED_MCCM_CRCCTRL_TYPE_TCPCHKSUMCCM_CRCCTRL_TYPE_P1EDC6F41CCM_CRCCTRL_TYPE_P4C11DB7CCM_CRCCTRL_TYPE_P1021CCM_CRCCTRL_TYPE_P8055CCM_CRCCTRL_TYPE_MCCM_CRCCTRL_ENDIAN_SBSWCCM_CRCCTRL_ENDIAN_SHWNBCCM_CRCCTRL_ENDIAN_SHWCCM_CRCCTRL_ENDIAN_SBHWCCM_CRCCTRL_ENDIAN_MCCM_CRCCTRL_BRCCM_CRCCTRL_OBRCCM_CRCCTRL_RESINVCCM_CRCCTRL_SIZECCM_CRCCTRL_INIT_1CCM_CRCCTRL_INIT_0CCM_CRCCTRL_INIT_SEEDCCM_CRCCTRL_INIT_MCCM_O_CRCRSLTPP0x00000418CCM_O_CRCDIN0x00000414CCM_O_CRCSEED0x00000410CCM_O_CRCCTRL__HW_CCM_H__// __HW_CCM_H__// Post Processing Result// The following are defines for the bit fields in the CCM_O_CRCRSLTPP// Data Input// The following are defines for the bit fields in the CCM_O_CRCDIN register.// SEED/Context Value// The following are defines for the bit fields in the CCM_O_CRCSEED register.// TCP checksum// Polynomial 0x1EDC6F41// Polynomial 0x4C11DB7// Polynomial 0x1021// Polynomial 0x8005// Operation Type// B1, B2, B3)// and half-words are swapped. (B0,// Bytes are swapped in half-words// (B1, B0, B3, B2)// are not swapped in half-word.// Half-words are swapped but bytes// (B2, B3, B0, B1)// but half-words are not swapped// B2, B1, B0)// Configuration unchanged. (B3,// Endian Control// Bit reverse enable// Output Reverse Enable// Result Inverse Enable// Input Data Size// Initialize to all '1s'// Initialize to all '0s'// as the starting value// Use the CRCSEED register context// CRC Initialization// The following are defines for the bit fields in the CCM_O_CRCCTRL register.// CRC Post Processing Result// CRC Data Input// CRC SEED/Context// CRC Control// The following are defines for the EC register offsets.// hw_ccm.h - Macros used when accessing the CCM hardware./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/aes.hAES_DMA_CONTEXT_OUTAES_DMA_CONTEXT_INAES_DMA_DATA_OUTAES_DMA_DATA_INAES_INT_DMA_DATA_OUTAES_INT_DMA_DATA_INAES_INT_DMA_CONTEXT_OUTAES_INT_DMA_CONTEXT_INAES_INT_DATA_OUTAES_INT_DATA_INAES_INT_CONTEXT_OUTAES_INT_CONTEXT_INAES_CFG_CCM_M_160x01c00000AES_CFG_CCM_M_14AES_CFG_CCM_M_12AES_CFG_CCM_M_10AES_CFG_CCM_M_80x00c00000AES_CFG_CCM_M_6AES_CFG_CCM_M_4AES_CFG_CCM_L_8AES_CFG_CCM_L_7AES_CFG_CCM_L_60x00280000AES_CFG_CCM_L_5AES_CFG_CCM_L_4AES_CFG_CCM_L_3AES_CFG_CCM_L_2AES_CFG_CCM_L_1AES_CFG_CTR_WIDTH_128AES_CFG_CTR_WIDTH_96AES_CFG_CTR_WIDTH_64AES_CFG_CTR_WIDTH_32AES_CFG_MODE_CCM0x20040040AES_CFG_MODE_GCM_HY0CALC0x20030040AES_CFG_MODE_GCM_HLY0CALC0x20020040AES_CFG_MODE_GCM_HLY0ZERO0x20010000AES_CFG_MODE_CBCMAC0x20008000AES_CFG_MODE_F90x20004000AES_CFG_MODE_F8AES_CFG_MODE_XTS_K2ILJ0AES_CFG_MODE_XTS_K2IJLAES_CFG_MODE_XTS_TWEAKJLAES_CFG_MODE_CFBAES_CFG_MODE_ICMAES_CFG_MODE_CTRAES_CFG_MODE_CBCAES_CFG_MODE_ECBAES_CFG_MODE_M0x2007fe60AES_CFG_KEY_SIZE_256BITAES_CFG_KEY_SIZE_192BITAES_CFG_KEY_SIZE_128BITAES_CFG_DIR_DECRYPTAES_CFG_DIR_ENCRYPT__DRIVERLIB_AES_H__AESTagReadAESResetAESLengthSetAESKey3SetAESKey2SetAESKey1SetAESIVReadAESIVSetAESIntUnregisterAESIntStatusAESIntRegisterAESIntEnableAESIntDisableAESIntClearAESDMAEnableAESDMADisableAESDataWriteNonBlockingAESDataWriteAESDataProcessAuthAESDataAuthAESDataProcessAESDataReadNonBlockingAESDataReadAESConfigSetAESAuthLengthSet// __DRIVERLIB_AES_H__// Function prototypes.// AESEnableDMA and AESDisableDMA functions.// Defines used when enabling and disabling DMA requests in the// AESIntStatus functions.// Interrupt flags for use with the AESIntEnable, AESIntDisable, and// function.  This value is also known as M.  Only one is permitted.// field for CCM operations through the ui32Config argument in the AESConfig// The following defines are used to define the length of the authentication// This value is also known as L.  Only one is permitted.// CCM operation through the ui32Config argument in the AESConfig function.// The following defines are used to define the width of the length field for// be defined when using CTR, CCM, or GCM modes.  Only one length is permitted.// ui32Config argument in the AESConfig function.  It is only required to// The following defines are used to specify the counter width in the// ui32Config argument in the AESConfig function.  Only one is permitted.// The following defines are used to specify the mode of operation in the// argument in the AESConfig function.  Only one is permitted.// The following defines are used to specify the key size in the ui32Config// The following defines are used to specify the operation direction in the// aes.h - Defines and Macros for the AES module.pui32TagDataui64Lengthpui32Keyui32Keysizepui32IVdataui32Flagspui32Srcpui32Destui32Lengthpui32AuthSrcui32AuthLengthpui32Tag/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/inc/hw_nvic.h/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/aes.c"driverlib/aes.h""inc/hw_nvic.h""inc/hw_ccm.h""inc/hw_aes.h"ui32Base + AES_O_SYSCONFIGui32Base + 0x00000084ui32Base == AES_BASE(ui32Flags == AES_DMA_DATA_IN) || (ui32Flags == AES_DMA_DATA_OUT) || (ui32Flags == AES_DMA_CONTEXT_IN) || (ui32Flags == AES_DMA_CONTEXT_OUT)ui32Base + AES_O_DMAICui32Base + 0xFFFFA02C4294942764393216(ui32IntFlags == AES_INT_DMA_CONTEXT_IN) || (ui32IntFlags == AES_INT_DMA_CONTEXT_OUT) || (ui32IntFlags == AES_INT_DMA_DATA_IN) || (ui32IntFlags == AES_INT_DMA_DATA_OUT)ui32Base + AES_O_DMAIMui32Base + 0xFFFFA0204294942752ui32Base + AES_O_IRQENABLEui32Base + 0x00000090655350x0000ffff(ui32IntFlags == AES_INT_CONTEXT_IN) || (ui32IntFlags == AES_INT_CONTEXT_OUT) || (ui32IntFlags == AES_INT_DATA_IN) || (ui32IntFlags == AES_INT_DATA_OUT) || (ui32IntFlags == AES_INT_DMA_CONTEXT_IN) || (ui32IntFlags == AES_INT_DMA_CONTEXT_OUT) || (ui32IntFlags == AES_INT_DMA_DATA_IN) || (ui32IntFlags == AES_INT_DMA_DATA_OUT)ui32Enableui32Base + AES_O_IRQSTATUSui32Base + 0x0000008Cui32Base + AES_O_DMAMISui32Base + 0xFFFFA028ui32Base + AES_O_DMARISui32Base + 0xFFFFA02442949427600x0000000c4294942756(true)1141071872AES_BASEui32Base + AES_O_CTRLui32Base + 0x00000050ui32Base + AES_O_DATA_IN_3ui32Base + 0x0000006Cui32Base + AES_O_DATA_IN_2ui32Base + 0x00000068ui32Base + AES_O_DATA_IN_1ui32Base + 0x00000064ui32Base + AES_O_DATA_IN_0ui32Base + 0x00000060(false)ui32Base + AES_O_AUTH_LENGTHui32Base + 0x0000005Cui32Base + AES_O_C_LENGTH_0ui32Base + 0x00000054ui32Base + AES_O_C_LENGTH_1ui32Base + 0x000000581073741824(ui32Base + AES_O_TAG_OUT_0)(ui32Base + 0x00000070)(ui32Base + AES_O_TAG_OUT_1)(ui32Base + 0x00000074)(ui32Base + AES_O_TAG_OUT_2)(ui32Base + 0x00000078)(ui32Base + AES_O_TAG_OUT_3)(ui32Base + 0x0000007C)124(ui32Base + AES_O_IV_IN_0)(ui32Base + 0x00000040)(ui32Base + AES_O_IV_IN_1)(ui32Base + 0x00000044)(ui32Base + AES_O_IV_IN_2)(ui32Base + 0x00000048)(ui32Base + AES_O_IV_IN_3)(ui32Base + 0x0000004C)ui32Base + AES_O_IV_IN_0ui32Base + 0x00000040ui32Base + AES_O_IV_IN_1ui32Base + 0x00000044ui32Base + AES_O_IV_IN_2ui32Base + 0x00000048ui32Base + AES_O_IV_IN_3ui32Base + 0x0000004Cui32Base + AES_O_KEY2_4ui32Base + AES_O_KEY2_5ui32Base + AES_O_KEY2_6ui32Base + AES_O_KEY2_7ui32Base + AES_O_KEY2_0ui32Base + AES_O_KEY2_1ui32Base + AES_O_KEY2_2ui32Base + AES_O_KEY2_3(ui32Keysize == AES_CFG_KEY_SIZE_128BIT) || (ui32Keysize == AES_CFG_KEY_SIZE_192BIT) || (ui32Keysize == AES_CFG_KEY_SIZE_256BIT)ui32Base + AES_O_KEY1_0ui32Base + AES_O_KEY1_1ui32Base + 0x0000003Cui32Base + AES_O_KEY1_2ui32Base + AES_O_KEY1_3ui32Base + AES_O_KEY1_4ui32Base + AES_O_KEY1_5ui32Base + 0x0000002Cui32Base + AES_O_KEY1_6ui32Base + AES_O_KEY1_7536870912(ui32Config & AES_CFG_DIR_ENCRYPT) || (ui32Config & AES_CFG_DIR_DECRYPT)(ui32Config & AES_CFG_KEY_SIZE_128BIT) || (ui32Config & AES_CFG_KEY_SIZE_192BIT) || (ui32Config & AES_CFG_KEY_SIZE_256BIT)(ui32Config & AES_CFG_MODE_ECB) || (ui32Config & AES_CFG_MODE_CBC) || (ui32Config & AES_CFG_MODE_CTR) || (ui32Config & AES_CFG_MODE_ICM) || (ui32Config & AES_CFG_MODE_CFB) || (ui32Config & AES_CFG_MODE_XTS_TWEAKJL) || (ui32Config & AES_CFG_MODE_XTS_K2IJL) || (ui32Config & AES_CFG_MODE_XTS_K2ILJ0) || (ui32Config & AES_CFG_MODE_F8) || (ui32Config & AES_CFG_MODE_F9) || (ui32Config & AES_CFG_MODE_CTR) || (ui32Config & AES_CFG_MODE_CBCMAC) || (ui32Config & AES_CFG_MODE_GCM_HLY0ZERO) || (ui32Config & AES_CFG_MODE_GCM_HLY0CALC) || (ui32Config & AES_CFG_MODE_GCM_HY0CALC) || (ui32Config & AES_CFG_MODE_CCM)((ui32Config & AES_CFG_MODE_CTR) || (ui32Config & AES_CFG_MODE_GCM_HLY0ZERO) || (ui32Config & AES_CFG_MODE_GCM_HLY0CALC) || (ui32Config & AES_CFG_MODE_GCM_HY0CALC) || (ui32Config & AES_CFG_MODE_CCM)) && ((ui32Config & AES_CFG_CTR_WIDTH_32) || (ui32Config & AES_CFG_CTR_WIDTH_64) || (ui32Config & AES_CFG_CTR_WIDTH_96) || (ui32Config & AES_CFG_CTR_WIDTH_128))(ui32Config & AES_CFG_MODE_CCM) && ((ui32Config & AES_CFG_CCM_L_1) || (ui32Config & AES_CFG_CCM_L_2) || (ui32Config & AES_CFG_CCM_L_3) || (ui32Config & AES_CFG_CCM_L_4) || (ui32Config & AES_CFG_CCM_L_5) || (ui32Config & AES_CFG_CCM_L_6) || (ui32Config & AES_CFG_CCM_L_7) || (ui32Config & AES_CFG_CCM_L_8)) && ((ui32Config & AES_CFG_CCM_M_4) || (ui32Config & AES_CFG_CCM_M_6) || (ui32Config & AES_CFG_CCM_M_8) || (ui32Config & AES_CFG_CCM_M_10) || (ui32Config & AES_CFG_CCM_M_12) || (ui32Config & AES_CFG_CCM_M_14) || (ui32Config & AES_CFG_CCM_M_16))ui32Base + AES_O_SYSSTATUSui32Base + 0x00000088// Clear the flags in the current register value.//! - \b AES_DMA_CONTEXT_OUT//! - \b AES_DMA_CONTEXT_IN//! - \b AES_DMA_DATA_OUT//! - \b AES_DMA_DATA_IN//! following://! The \e ui32Flags parameter is the logical OR of any of the//! This function disables the uDMA request sources in the AES module.//! \param ui32Flags is a bit mask of the uDMA requests to be disabled.//! \param ui32Base is the base address of the AES module.//! Disables uDMA requests for the AES module.// Set the flags in the current register value.//! The \e ui32Flags parameter is the logical OR of any of the following://! This function enables the uDMA request sources in the AES module.//! \param ui32Flags is a bit mask of the uDMA requests to be enabled.//! Enables uDMA requests for the AES module.//! disables the interrupt in the interrupt controller.//! This function unregisters the previously registered interrupt handler and//! Unregisters an interrupt handler for the AES module.// Enable the interrupt//! interrupt controller.//! Instead, IntEnable() is used to enable AES interrupts on the//! flash, then it is not necessary to register the interrupt handler this way.//! If the application is using a static interrupt vector table stored in//! AESIntClear().//! handler being registered must clear the source of the interrupt using//! interrupt sources must be enabled using AESIntEnable().  The interrupt//! table, and enables AES interrupts on the interrupt controller; specific AES//! This function registers the interrupt handler in the interrupt vector//! enabled AES interrupts occur.//! Registers an interrupt handler for the AES module.//! interrupts should be disabled with AESIntDisable().//! \note Only the DMA done interrupts can be cleared.  The remaining//! - \b AES_INT_DMA_DATA_OUT - Data output DMA done interrupt//! - \b AES_INT_DMA_DATA_IN - Data input DMA done interrupt//!   interrupt//! - \b AES_INT_DMA_CONTEXT_OUT - Authentication tag (and IV) DMA done//! - \b AES_INT_DMA_CONTEXT_IN - Context DMA done interrupt//! \e ui32IntFlags parameter is the logical OR of any of the following://! This function clears the interrupt sources in the AES module.  The//! \param ui32IntFlags is a bit mask of the interrupt sources to disable.//! Clears AES module interrupts.// Clear the flags.//! The remaining interrupts can be disabled instead using AESIntDisable().//! \note The DMA done interrupts are the only interrupts that can be cleared.//! - \b AES_INT_DATA_OUT - Data output interrupt//! - \b AES_INT_DATA_IN - Data input interrupt//! - \b AES_INT_CONTEXT_OUT - Authentication tag (and IV) interrupt//! - \b AES_INT_CONTEXT_IN - Context interrupt//! This function disables the interrupt sources in the AES module.  The//! Disables AES module interrupts.// Set the flags.//! when this function is called.//! \note Interrupts that have been previously been enabled are not disabled//! This function enables the interrupts in the AES module.  The//! \param ui32IntFlags is a bit mask of the interrupt sources to enable.//! Enables AES module interrupts.// Read the IRQ status register and return the value.//! - \b AES_INT_CONTEXT_OUT - Authentication tag (and IV) interrupt.//! of any of the following://! \return Returns a bit mask of the interrupt sources, which is a logical OR//! \b true if the masked interrupt status is required.//! \param bMasked is \b false if the raw interrupt status is required and//! Returns the current AES module interrupt status.// Return true to indicate successful completion of the function.// Read the hash tag value.// Read the data registers.// Write the data registers.// Now loop until the data blocks are written.// Now loop until the authentication data blocks are written.// Set the additional authentication data length.// Set the data length.//! if data processing failed.//! \return Returns true if data was processed successfully.  Returns false//! data size, mode, etc.  Only CCM and GCM modes should be used.//! function, ensure that the AES module is properly configured the key,//! authentication data.  A hash tag is also produced.  Before calling this//! This function encrypts or decrypts blocks of data in addition to//! written.//! \param pui32Tag is a pointer to a 4-word array where the hash tag is//! data in bytes.//! \param ui32AuthLength is the length of the additional authentication//! 16-byte boundary.//! additional authentication data is stored.  The data must be padded to the//! \param pui32AuthSrc is a pointer to the memory location where the//! \param ui32Length is the length of the cryptographic data in bytes.//! The space for written data must be rounded up to the 16-byte boundary.//! \param pui32Dest is a pointer to the memory location output is written.//! is stored.  The data must be padded to the 16-byte boundary.//! \param pui32Src is a pointer to the memory location where the input data//! \param ui32Base  is the base address of the AES module.//! it.//! Processes and authenticates blocks of data, either encrypt it or decrypts// Now loop until the blocks are written.// using this context.// Write the length register first, which triggers the engine to start//! CBC-MAC and F9 modes should be used.//! module is properly configured the key, data size, mode, etc.  Only//! authentication.   Before calling this function, ensure that the AES//! This function processes data to produce a hash tag that can be used tor//! \param ui32Length  is the length of the cryptographic data in bytes.//! Used to authenticate blocks of data by generating a hash tag.//! because the memory size is restricted to between 0 to 2^32 bytes.//! \note This function only supports values of \e ui32Length less than 2^32,//! is processed in 4-word (16-byte) blocks.//! CBC, CTR, ICM, CFB, XTS and F8 operating modes should be used.  The data//! module is properly configured the key, data size, mode, etc.  Only ECB,//! the data length.  Before calling this function, ensure that the AES//! This function iterates the encryption or decryption mechanism number over//! Used to process(transform) blocks of data, either encrypt or decrypt it.// Write a block of data into the data registers.// Wait for input ready.//! ready before performing the write.  A block is 16 bytes or 4 words.//! AES module.  If the input is not ready, the function waits until it is//! This function writes a block of either plaintext or ciphertext into the//! \param pui32Src is a pointer to an array of bytes.//! Writes plaintext/ciphertext to data registers with blocking.// Write successful, return true.// Check if the input is ready.  If not, then return false.//! \return True or false.//! bytes or 4 words.//! write completed successfully, the function returns true.  A block is 16//! AES module.  If the input is not ready, the function returns false.  If the//! \param pui32Src is a pointer to an array of words of data.//! Writes plaintext/ciphertext to data registers without blocking.// Read a block of data from the data registers// Wait for the output to be ready before reading the data.//! ready.  A block is 16 bytes or 4 words.//! AES module.  If the output is not ready, the function waits until it is//! This function reads a block of either plaintext or ciphertext out of the//! \param pui32Dest is a pointer to an array of words.//! Reads plaintext/ciphertext from data registers with blocking.// Read successful, return true.// return false.// Check if the output is ready before reading the data.  If it not ready,//! \return true or false.//! A block is 16 bytes or 4 words.//! false.  If the read completed successfully, the function returns true.//! AES module.  If the output data is not ready, the function returns//! \param pui32Dest is a pointer to an array of words of data.//! Reads plaintext/ciphertext from data registers without blocking.// Write the length into the register.//! \return None//! this context for GCM and CCM.//! When this function is called, the engine is triggered to start using//! bits [31:4] of the register.//! when passed to this function, thereby placing the block number in//! blocks inside the data unit.  Consequently, j must be multiplied by 16//! only required if j != 0.  j represents the sequential number of the 128-bit//! be used.  For XTS mode, this register is used to load j.  Loading of j is//! are from 0 to (2^16 - 28) bytes.  For GCM, any value up to (2^32 - 1) can//! combined modes (GCM or CCM) and XTS mode.  Supported AAD lengths for CCM//! This function is only used to write the authentication data length in the//! \param ui32Length is the length in bytes.//! Sets the authentication data length in the AES module.// Write the length register by shifting the 64-bit ui64Length.//! authentication data length.//! some modes.  Use the AESAuthLengthSet() function to specify the//! \note This length does not include the authentication-only data used in//! this context.//! length field, indicating that the length is infinite.//! For basic modes (ECB/CBC/CTR/ICM/CFB128), zero can be programmed into the//! to (2^36 - 2) bytes are allowed because a 32-bit block counter is used.//! Data lengths up to (2^61 - 1) bytes are allowed.  For GCM, any value up//! This function stores the cryptographic data length in blocks for all modes.//! \param ui64Length is the crypto data length in bytes.//! Used to set the write crypto data length in the AES module.// Read the tag data.// Wait for the output context to be ready.//! bit is set in the AES_CTRL register.//! decryption operations.  It is assumed that the AES_CTRL_SAVE_CONTEXT//! This function stores the tag data for use authenticated encryption and//! \param pui32TagData is pointer to the location that stores the tag data.//! Saves the tag registers to a user-defined location.//! This function stores the IV for use with authenticated encryption and//! \param pui32IVData is pointer to the location that stores the IV data.//! Saves the Initial Vector (IV) registers to a user-defined location.// Write the initial vector registers.//! This functions writes the initial vector registers in the AES module.//! value to be configured.  The least significant word is in the 0th index.//! \param pui32IVdata is an array of 4 words (128 bits), containing the IV//! Writes the Initial Vector (IV) register, needed in some of the AES Modes.// Write the key into the upper 4 key registers//! used in CBC-MAC and F8 modes.  This key is always 128 bits.//! This function writes the key 2 configuration registers with key 3 data//! the key to be configured.  The least significant word is in the 0th index.//! \param pui32Key is a pointer to an array of 4 words (128 bits), containing//! \param ui32Base is the base address for the AES module.//! decryption.//! Writes key 3 configuration registers, which are used for encryption or// The key is 256 bits.  Write the last 2 words.// The key is 192 or 256 bits.  Write the next 2 words.// With all key sizes, the first 4 words are written.//! size.  This function is used in the F8, F9, XTS, CCM, and CBC-MAC modes.//! This function writes the key 2 configuration registers based on the key//! \b AES_CFG_KEY_SIZE_256.//! following values:  \b AES_CFG_KEY_SIZE_128, \b AES_CFG_KEY_SIZE_192, or//! \param ui32Keysize is the size of the key, which must be one of the//! configured.  The least significant word in the 0th index.//! \param pui32Key is an array of 32-bit words, containing the key to be//! Writes the key 2 configuration registers, which are used for encryption or//! size.  This function is used in all modes.//! This function writes key 1 configuration registers based on the key//! Writes the key 1 configuration registers, which are used for encryption or// Write the CTRL register with the new value// Backup the save context field before updating the register.//! the \b AES_CFG_MODE_GCM_HLY0ZERO and do not specify a direction.//! \note When performing a basic GHASH operation for used with GCM mode, use//! - \b AES_CFG_CCM_M_16 - 16 bytes//! - \b AES_CFG_CCM_M_14 - 14 bytes//! - \b AES_CFG_CCM_M_12 - 12 bytes//! - \b AES_CFG_CCM_M_10 - 10 bytes//! - \b AES_CFG_CCM_M_8 - 8 bytes//! - \b AES_CFG_CCM_M_6 - 6 bytes//! - \b AES_CFG_CCM_M_4 - 4 bytes//! argument in the AESConfigSet() function://! authentication field for CCM operations (M) through the \e ui32Config//! Only one of the following defines must be used to specify the length of the//! - \b AES_CFG_CCM_L_8 - 8 bytes//! - \b AES_CFG_CCM_L_7 - 7 bytes//! - \b AES_CFG_CCM_L_6 - 6 bytes//! - \b AES_CFG_CCM_L_5 - 5 bytes//! - \b AES_CFG_CCM_L_4 - 4 bytes//! - \b AES_CFG_CCM_L_3 - 3 bytes//! - \b AES_CFG_CCM_L_2 - 2 bytes//! - \b AES_CFG_CCM_L_1 - 1 byte//! for CCM operations (L)://! Only one of the following defines must be used to specify the length field//! - \b AES_CFG_CTR_WIDTH_128 - Counter is 128 bits//! - \b AES_CFG_CTR_WIDTH_96 - Counter is 96 bits//! - \b AES_CFG_CTR_WIDTH_64 - Counter is 64 bits//! - \b AES_CFG_CTR_WIDTH_32 - Counter is 32 bits//! following defines must be used to specify the counter width length://! required to be defined when using CTR, CCM, or GCM modes, only one of the//! The following defines are used to specify the counter width.  It is only//! - \b AES_CFG_MODE_CCM - Counter with CBC-MAC mode//!   (both H and Y0-encrypted calculated internally) and counter is enabled.//! - \b AES_CFG_MODE_GCM_HY0CALC - Galois/Counter mode with autonomous GHASH//!   loaded, Y0-encrypted calculated internally and counter is enabled.//! - \b AES_CFG_MODE_GCM_HLY0CALC - Galois/counter mode with GHASH with H//!   loaded, Y0-encrypted forced to zero and counter is not enabled.//! - \b AES_CFG_MODE_GCM_HLY0ZERO - Galois/counter mode with GHASH with H//!   code mode//! - \b AES_CFG_MODE_CBCMAC - Cipher block chaining message authentication//! - \b AES_CFG_MODE_F9 - F9 mode//! - \b AES_CFG_MODE_F8 - F8 mode//!   ciphertext stealing with key2 and i loaded, j = 0//! - \b AES_CFG_MODE_XTS_K2ILJ0 - XEX-based tweaked-codebook mode with//!   ciphertext stealing with key2, i and j loaded//! - \b AES_CFG_MODE_XTS_K2IJL - XEX-based tweaked-codebook mode with//!   ciphertext stealing with previous/intermediate tweak value and j loaded//! - \b AES_CFG_MODE_XTS_TWEAKJL - XEX-based tweaked-codebook mode with//! - \b AES_CFG_MODE_XTS - Ciphertext stealing mode//! - \b AES_CFG_MODE_ICM - Integer counter mode//! - \b AES_CFG_MODE_CTR - Counter mode//! - \b AES_CFG_MODE_CFB - Cipher feedback mode//! - \b AES_CFG_MODE_CBC - Cipher-block chaining mode//! - \b AES_CFG_MODE_ECB - Electronic codebook mode//! The mode of operation is specified with only one of the following flags.//! - \b AES_CFG_KEY_SIZE_256BIT - Key size of 256 bits//! - \b AES_CFG_KEY_SIZE_192BIT - Key size of 192 bits//! - \b AES_CFG_KEY_SIZE_128BIT - Key size of 128 bits//! The key size is specified with only one of the following flags://! - \b AES_CFG_DIR_DECRYPT - Decryption mode//! - \b AES_CFG_DIR_ENCRYPT - Encryption mode//! The direction of the operation is specified with only of following flags://! flags.  The valid flags are grouped based on their function.//! The ui32Config parameter is a bit-wise OR of a number of configuration//! It does not change any DMA- or interrupt-related parameters.//! This function configures the AES module based on the specified parameters.//! \param ui32Config is the configuration of the AES module.//! Configures the AES module.// Wait for the reset to finish.// Trigger the reset.//! This function performs a softreset the AES module.//! Resets the AES module.//! \addtogroup aes_api// aes.c - Driver for the AES module.pui32IVData/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/inc/hw_can.hCAN_MSG2VAL_MSGVAL_SCAN_MSG2VAL_MSGVAL_MCAN_MSG1VAL_MSGVAL_SCAN_MSG1VAL_MSGVAL_MCAN_MSG2INT_INTPND_SCAN_MSG2INT_INTPND_MCAN_MSG1INT_INTPND_SCAN_MSG1INT_INTPND_MCAN_NWDA2_NEWDAT_SCAN_NWDA2_NEWDAT_MCAN_NWDA1_NEWDAT_SCAN_NWDA1_NEWDAT_MCAN_TXRQ2_TXRQST_SCAN_TXRQ2_TXRQST_MCAN_TXRQ1_TXRQST_SCAN_TXRQ1_TXRQST_MCAN_IF2DB2_DATA_SCAN_IF2DB2_DATA_MCAN_IF2DB1_DATA_SCAN_IF2DB1_DATA_MCAN_IF2DA2_DATA_SCAN_IF2DA2_DATA_MCAN_IF2DA1_DATA_SCAN_IF2DA1_DATA_MCAN_IF2MCTL_DLC_SCAN_IF2MCTL_DLC_MCAN_IF2MCTL_EOBCAN_IF2MCTL_TXRQSTCAN_IF2MCTL_RMTENCAN_IF2MCTL_RXIECAN_IF2MCTL_TXIECAN_IF2MCTL_UMASKCAN_IF2MCTL_INTPNDCAN_IF2MCTL_MSGLSTCAN_IF2MCTL_NEWDATCAN_IF2ARB2_ID_SCAN_IF2ARB2_ID_M0x00001FFFCAN_IF2ARB2_DIRCAN_IF2ARB2_XTDCAN_IF2ARB2_MSGVALCAN_IF2ARB1_ID_SCAN_IF2ARB1_ID_MCAN_IF2MSK2_IDMSK_SCAN_IF2MSK2_IDMSK_MCAN_IF2MSK2_MDIRCAN_IF2MSK2_MXTDCAN_IF2MSK1_IDMSK_SCAN_IF2MSK1_IDMSK_MCAN_IF2CMSK_DATABCAN_IF2CMSK_DATAACAN_IF2CMSK_TXRQSTCAN_IF2CMSK_NEWDATCAN_IF2CMSK_CLRINTPNDCAN_IF2CMSK_CONTROLCAN_IF2CMSK_ARBCAN_IF2CMSK_MASKCAN_IF2CMSK_WRNRDCAN_IF2CRQ_MNUM_SCAN_IF2CRQ_MNUM_MCAN_IF2CRQ_BUSYCAN_IF1DB2_DATA_SCAN_IF1DB2_DATA_MCAN_IF1DB1_DATA_SCAN_IF1DB1_DATA_MCAN_IF1DA2_DATA_SCAN_IF1DA2_DATA_MCAN_IF1DA1_DATA_SCAN_IF1DA1_DATA_MCAN_IF1MCTL_DLC_SCAN_IF1MCTL_DLC_MCAN_IF1MCTL_EOBCAN_IF1MCTL_TXRQSTCAN_IF1MCTL_RMTENCAN_IF1MCTL_RXIECAN_IF1MCTL_TXIECAN_IF1MCTL_UMASKCAN_IF1MCTL_INTPNDCAN_IF1MCTL_MSGLSTCAN_IF1MCTL_NEWDATCAN_IF1ARB2_ID_SCAN_IF1ARB2_ID_MCAN_IF1ARB2_DIRCAN_IF1ARB2_XTDCAN_IF1ARB2_MSGVALCAN_IF1ARB1_ID_SCAN_IF1ARB1_ID_MCAN_IF1MSK2_IDMSK_SCAN_IF1MSK2_IDMSK_MCAN_IF1MSK2_MDIRCAN_IF1MSK2_MXTDCAN_IF1MSK1_IDMSK_SCAN_IF1MSK1_IDMSK_MCAN_IF1CMSK_DATABCAN_IF1CMSK_DATAACAN_IF1CMSK_TXRQSTCAN_IF1CMSK_NEWDATCAN_IF1CMSK_CLRINTPNDCAN_IF1CMSK_CONTROLCAN_IF1CMSK_ARBCAN_IF1CMSK_MASKCAN_IF1CMSK_WRNRDCAN_IF1CRQ_MNUM_SCAN_IF1CRQ_MNUM_MCAN_IF1CRQ_BUSYCAN_BRPE_BRPE_SCAN_BRPE_BRPE_MCAN_TST_BASICCAN_TST_SILENTCAN_TST_LBACKCAN_TST_TX_RECESSIVECAN_TST_TX_DOMINANTCAN_TST_TX_SAMPLECAN_TST_TX_CANCTLCAN_TST_TX_MCAN_TST_RXCAN_INT_INTID_STATUSCAN_INT_INTID_NONECAN_INT_INTID_MCAN_BIT_BRP_SCAN_BIT_SJW_SCAN_BIT_TSEG1_SCAN_BIT_TSEG2_SCAN_BIT_BRP_MCAN_BIT_SJW_MCAN_BIT_TSEG1_MCAN_BIT_TSEG2_MCAN_ERR_TEC_SCAN_ERR_REC_SCAN_ERR_TEC_MCAN_ERR_REC_M0x00007F00CAN_ERR_RPCAN_STS_LEC_NOEVENTCAN_STS_LEC_CRCCAN_STS_LEC_BIT0CAN_STS_LEC_BIT1CAN_STS_LEC_ACKCAN_STS_LEC_FORMCAN_STS_LEC_STUFFCAN_STS_LEC_NONECAN_STS_LEC_MCAN_STS_TXOKCAN_STS_RXOKCAN_STS_EPASSCAN_STS_EWARNCAN_STS_BOFFCAN_CTL_INITCAN_CTL_IECAN_CTL_SIECAN_CTL_EIECAN_CTL_DARCAN_CTL_CCECAN_CTL_TESTCAN_O_MSG2VAL0x00000164CAN_O_MSG1VAL0x00000160CAN_O_MSG2INT0x00000144CAN_O_MSG1INTCAN_O_NWDA20x00000124CAN_O_NWDA10x00000120CAN_O_TXRQ2CAN_O_TXRQ1CAN_O_IF2DB2CAN_O_IF2DB1CAN_O_IF2DA2CAN_O_IF2DA1CAN_O_IF2MCTLCAN_O_IF2ARB2CAN_O_IF2ARB1CAN_O_IF2MSK2CAN_O_IF2MSK1CAN_O_IF2CMSKCAN_O_IF2CRQCAN_O_IF1DB2CAN_O_IF1DB1CAN_O_IF1DA2CAN_O_IF1DA1CAN_O_IF1MCTLCAN_O_IF1ARB2CAN_O_IF1ARB1CAN_O_IF1MSK2CAN_O_IF1MSK1CAN_O_IF1CMSKCAN_O_IF1CRQCAN_O_BRPECAN_O_TSTCAN_O_INTCAN_O_BITCAN_O_ERRCAN_O_STSCAN_O_CTL__HW_CAN_H__// __HW_CAN_H__// Message Valid Bits// The following are defines for the bit fields in the CAN_O_MSG2VAL register.// The following are defines for the bit fields in the CAN_O_MSG1VAL register.// Interrupt Pending Bits// The following are defines for the bit fields in the CAN_O_MSG2INT register.// The following are defines for the bit fields in the CAN_O_MSG1INT register.// New Data Bits// The following are defines for the bit fields in the CAN_O_NWDA2 register.// The following are defines for the bit fields in the CAN_O_NWDA1 register.// Transmission Request Bits// The following are defines for the bit fields in the CAN_O_TXRQ2 register.// The following are defines for the bit fields in the CAN_O_TXRQ1 register.// Data// The following are defines for the bit fields in the CAN_O_IF2DB2 register.// The following are defines for the bit fields in the CAN_O_IF2DB1 register.// The following are defines for the bit fields in the CAN_O_IF2DA2 register.// The following are defines for the bit fields in the CAN_O_IF2DA1 register.// Data Length Code// End of Buffer// Transmit Request// Remote Enable// Receive Interrupt Enable// Transmit Interrupt Enable// Use Acceptance Mask// Interrupt Pending// Message Lost// New Data// The following are defines for the bit fields in the CAN_O_IF2MCTL register.// Message Identifier// Message Direction// Extended Identifier// Message Valid// The following are defines for the bit fields in the CAN_O_IF2ARB2 register.// The following are defines for the bit fields in the CAN_O_IF2ARB1 register.// Identifier Mask// Mask Message Direction// Mask Extended Identifier// The following are defines for the bit fields in the CAN_O_IF2MSK2 register.// The following are defines for the bit fields in the CAN_O_IF2MSK1 register.// Access Data Byte 4 to 7// Access Data Byte 0 to 3// Access Transmission Request// Access New Data// Clear Interrupt Pending Bit// Access Control Bits// Access Arbitration Bits// Access Mask Bits// Write, Not Read// The following are defines for the bit fields in the CAN_O_IF2CMSK register.// Message Number// Busy Flag// The following are defines for the bit fields in the CAN_O_IF2CRQ register.// The following are defines for the bit fields in the CAN_O_IF1DB2 register.// The following are defines for the bit fields in the CAN_O_IF1DB1 register.// The following are defines for the bit fields in the CAN_O_IF1DA2 register.// The following are defines for the bit fields in the CAN_O_IF1DA1 register.// The following are defines for the bit fields in the CAN_O_IF1MCTL register.// The following are defines for the bit fields in the CAN_O_IF1ARB2 register.// The following are defines for the bit fields in the CAN_O_IF1ARB1 register.// The following are defines for the bit fields in the CAN_O_IF1MSK2 register.// The following are defines for the bit fields in the CAN_O_IF1MSK1 register.// The following are defines for the bit fields in the CAN_O_IF1CMSK register.// The following are defines for the bit fields in the CAN_O_IF1CRQ register.// Baud Rate Prescaler Extension// The following are defines for the bit fields in the CAN_O_BRPE register.// Basic Mode// Silent Mode// Loopback Mode// Driven High// Driven Low// Sample Point// CAN Module Control// Transmit Control// Receive Observation// The following are defines for the bit fields in the CAN_O_TST register.// Status Interrupt// No interrupt pending// Interrupt Identifier// The following are defines for the bit fields in the CAN_O_INT register.// Baud Rate Prescaler// (Re)Synchronization Jump Width// Time Segment Before Sample Point// Time Segment after Sample Point// The following are defines for the bit fields in the CAN_O_BIT register.// Transmit Error Counter// Receive Error Counter// Received Error Passive// The following are defines for the bit fields in the CAN_O_ERR register.// No Event// CRC Error// Bit 0 Error// Bit 1 Error// ACK Error// Format Error// Stuff Error// No Error// Last Error Code// Successfully// Transmitted a Message// Received a Message Successfully// Error Passive// Warning Status// Bus-Off Status// The following are defines for the bit fields in the CAN_O_STS register.// Initialization// CAN Interrupt Enable// Status Interrupt Enable// Error Interrupt Enable// Disable Automatic-Retransmission// Configuration Change Enable// Test Mode Enable// The following are defines for the bit fields in the CAN_O_CTL register.// CAN Message 2 Valid// CAN Message 1 Valid// CAN Message 2 Interrupt Pending// CAN Message 1 Interrupt Pending// CAN New Data 2// CAN New Data 1// CAN Transmission Request 2// CAN Transmission Request 1// CAN IF2 Data B2// CAN IF2 Data B1// CAN IF2 Data A2// CAN IF2 Data A1// CAN IF2 Message Control// CAN IF2 Arbitration 2// CAN IF2 Arbitration 1// CAN IF2 Mask 2// CAN IF2 Mask 1// CAN IF2 Command Mask// CAN IF2 Command Request// CAN IF1 Data B2// CAN IF1 Data B1// CAN IF1 Data A2// CAN IF1 Data A1// CAN IF1 Message Control// CAN IF1 Arbitration 2// CAN IF1 Arbitration 1// CAN IF1 Mask 2// CAN IF1 Mask 1// CAN IF1 Command Mask// CAN IF1 Command Request// Extension// CAN Baud Rate Prescaler// CAN Test// CAN Interrupt// CAN Bit Timing// CAN Error Counter// CAN Status// CAN Control// The following are defines for the CAN register offsets.// hw_can.h - Defines and macros used when accessing the CAN controllers./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/can.htMsgObjType(unnamed enum)MSG_OBJ_TYPE_TXMSG_OBJ_TYPE_TX_REMOTEMSG_OBJ_TYPE_RXMSG_OBJ_TYPE_RX_REMOTEMSG_OBJ_TYPE_RXTX_REMOTEtCANStsRegCAN_STS_CONTROLCAN_STS_TXREQUESTCAN_STS_NEWDATCAN_STS_MSGVALtCANIntStsRegCAN_INT_STS_CAUSECAN_INT_STS_OBJECTtCANBitClkParmsstruct <unnamed>tCANMsgObjectui32QuantumPrescalerui32SJWui32Phase2Segui32SyncPropPhase1Segpui8MsgDataui32MsgLenui32MsgIDMaskui32MsgIDCAN_STATUS_LEC_MASKCAN_STATUS_LEC_CRCCAN_STATUS_LEC_BIT0CAN_STATUS_LEC_BIT1CAN_STATUS_LEC_ACKCAN_STATUS_LEC_FORMCAN_STATUS_LEC_STUFFCAN_STATUS_LEC_NONECAN_STATUS_LEC_MSKCAN_STATUS_TXOKCAN_STATUS_RXOKCAN_STATUS_EPASSCAN_STATUS_EWARNCAN_STATUS_BUS_OFFCAN_INT_MASTERCAN_INT_STATUSCAN_INT_ERRORMSG_OBJ_STATUS_MASK(MSG_OBJ_NEW_DATA | MSG_OBJ_DATA_LOST)MSG_OBJ_NO_FLAGSMSG_OBJ_FIFOMSG_OBJ_REMOTE_FRAMEMSG_OBJ_USE_EXT_FILTER(0x00000020 | MSG_OBJ_USE_ID_FILTER)MSG_OBJ_USE_DIR_FILTER(0x00000010 | MSG_OBJ_USE_ID_FILTER)MSG_OBJ_DATA_LOSTMSG_OBJ_NEW_DATAMSG_OBJ_USE_ID_FILTERMSG_OBJ_EXTENDED_IDMSG_OBJ_RX_INT_ENABLEMSG_OBJ_TX_INT_ENABLE__DRIVERLIB_CAN_H__CANStatusGetCANRetrySetCANRetryGetCANMessageSettCANMsgObject *struct <unnamed> *CANMessageGetCANMessageClearCANIntUnregisterCANIntStatusCANIntRegisterCANIntEnableCANIntDisableCANIntClearCANInitCANErrCntrGetCANEnableCANDisableCANBitRateSetCANBitTimingSettCANBitClkParms *CANBitTimingGet// __DRIVERLIB_CAN_H__// API Function prototypes//! This is the mask for the CAN Last Error Code (LEC).//! A CRC error has occurred.//! The bus remained a bit level of 0 for longer than is allowed.//! The bus remained a bit level of 1 for longer than is allowed.//! An acknowledge error has occurred.//! A formatting error has occurred.//! A bit stuffing error has occurred.//! There was no error.//! This is the mask for the last error code field.//! status.//! A message was transmitted successfully since the last read of this//! A message was received successfully since the last read of this status.//! CAN controller error level has reached error passive level.//! CAN controller error level has reached warning level.//! CAN controller has entered a Bus Off state.// be returned when calling the CANStatusGet() function.// The following enumeration contains all error or status indicators that can//! Remote frame receive remote, with auto-transmit message object.//! Receive remote request message object.//! Receive message object.//! Transmit remote request message object//! Transmit message object.//! set up via a call to the CANMessageSet() API.//! This definition is used to determine the type of message object that is//! by the CAN controller.//! interrupts.  If this is not set, then no interrupts are generated//! This flag is used to allow a CAN controller to generate any CAN//! interrupts.//! This flag is used to allow a CAN controller to generate status//! This flag is used to allow a CAN controller to generate error// and CANIntDisable().// These definitions are used to specify interrupt sources to CANIntEnable()//! Read the full 32-bit mask of message objects that are enabled.//! Read the full 32-bit mask of message objects with new data available.//! set.//! Read the full 32-bit mask of message objects with a transmit request//! Read the full CAN controller status.//! read when calling the CANStatusGet() function.//! This data type is used to identify which of several status registers to//! Read a message object's interrupt status.//! Read the CAN interrupt status information.//! used when calling the CANIntStatus() function.//! This data type is used to identify the interrupt status register.  This is//! The valid values for this setting range from 1 to 1023.//! This value holds the CAN_CLK divider used to determine time quanta.//! valid values for this setting range from 1 to 4.//! This value holds the Resynchronization Jump Width in time quanta.  The//! values for this setting range from 1 to 8.//! This value holds the Phase Buffer 2 segment in time quanta.  The valid//! setting range from 2 to 16.//! Buffer 1 segments, measured in time quanta.  The valid values for this//! This value holds the sum of the Synchronization, Propagation, and Phase//! the CANGetBitTiming and CANSetBitTiming functions.//! up the bit timing for a CAN controller.  The structure is used when calling//! This structure is used for encapsulating the values associated with setting//! This is a pointer to the message object's data.//! This value is the number of bytes of data in the message object.//! tCANObjFlags.//! This value holds various status flags and settings specified by//! The message identifier mask used when identifier filtering is enabled.//! The CAN message identifier used for 11 or 29 bit identifiers.//! message object in the CAN controller.//! The structure used for encapsulating all the items associated with a CAN//! flags and not configuration flags.//! This define is used with the flag values to allow checking only status//! This indicates that a message object has no flags set.//! not the final message object in a FIFO.//! This indicates that this message object is part of a FIFO structure and//! This indicates that a message object is a remote frame.//! identifier filtering is used, then ID filtering must also be enabled.//! identifier filtering based on the extended identifier.  If the extended//! This indicates that a message object uses or is using message//! used, then ID filtering must also be enabled.//! based on the direction of the transfer.  If the direction filtering is//! This indicates that a message object uses or is using filtering//! read.//! This indicates that data was lost since this message object was last//! This indicates that new data was available in the message object.//! object's message identifier.//! This indicates that a message object is using filtering based on the//! This indicates that a message object is using an extended identifier.//! This indicates that receive interrupts are enabled.//! This indicates that transmit interrupts are enabled.// the CANMessageSet() and CANMessageGet() functions.// These are the flags used by the tCANMsgObject.ui32Flags value when calling// Miscellaneous defines for Message ID Types//! \addtogroup can_api// can.h - Defines and Macros for the CAN controller.eStatusRegbAutoRetryui32ObjIDpsMsgObjecteMsgTypebClrPendingInteIntStsRegui32IntClrpui32RxCountpui32TxCountui32SourceClockui32BitRatepsClkParms/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/can.c"driverlib/can.h""inc/hw_can.h"ui32Base + CAN_O_IF1CRQ32768ui32Base + CAN_O_IF1CMSK160ui32Base + CAN_O_IF1ARB1ui32Base + CAN_O_IF1ARB2_CANBaseValid(ui32Base)(ui32ObjID >= 1) && (ui32ObjID <= 32)ui16CmdMaskRegui16MaskReg0ui16MaskReg1ui16ArbReg0ui16ArbReg1ui16MsgCtrl(CAN_IF1CMSK_DATAA | CAN_IF1CMSK_DATAB |
                      CAN_IF1CMSK_CONTROL | CAN_IF1CMSK_MASK |
                      CAN_IF1CMSK_ARB)ui32Base + CAN_O_IF2CMSKui32Base + CAN_O_IF2CRQui32Base + 0x00000080ui32Base + CAN_O_IF2MSK1ui32Base + CAN_O_IF2MSK2ui32Base + CAN_O_IF2ARB1ui32Base + CAN_O_IF2ARB2ui32Base + 0x00000094148ui32Base + CAN_O_IF2MCTLui32Base + 0x00000098819216384819140965368709110x1fffffff20470x7ff20481024156(ui32ObjID <= 32) && (ui32ObjID != 0)bTransferDatabUseExtendedIDCAN_MAX_11BIT_MSG_ID130131(CAN_IF1CMSK_WRNRD | CAN_IF1CMSK_DATAA |
                      CAN_IF1CMSK_DATAB | CAN_IF1CMSK_CONTROL)0xffff0x1fff5124608(MSG_OBJ_USE_ID_FILTER | MSG_OBJ_USE_DIR_FILTER |
        MSG_OBJ_USE_EXT_FILTER)49152ui32Base + CAN_O_IF1MSK1ui32Base + CAN_O_IF1MSK2ui32Base + CAN_O_IF1MCTL(eMsgType == MSG_OBJ_TYPE_TX) || (eMsgType == MSG_OBJ_TYPE_TX_REMOTE) || (eMsgType == MSG_OBJ_TYPE_RX) || (eMsgType == MSG_OBJ_TYPE_RX_REMOTE) || (eMsgType == MSG_OBJ_TYPE_TX_REMOTE) || (eMsgType == MSG_OBJ_TYPE_RXTX_REMOTE)ui32CANErrorui32Base + CAN_O_ERR32512255ui32Base + CAN_O_STSui32Base + CAN_O_TXRQ1ui32Base + 0x00000100ui32Base + CAN_O_TXRQ2ui32Base + 0x00000104ui32Base + CAN_O_NWDA1ui32Base + 0x00000120ui32Base + CAN_O_NWDA2ui32Base + 0x00000124ui32Base + CAN_O_MSG1VALui32Base + 0x00000160ui32Base + CAN_O_MSG2VALui32Base + 0x00000164(CAN_STS_RXOK | CAN_STS_TXOK |
                                            CAN_STS_LEC_M)4294967264~(CAN_STS_RXOK | CAN_STS_TXOK |
                                            CAN_STS_LEC_M)260288292352356ui32Base + CAN_O_CTLui32CtlReg4294967263~CAN_CTL_DAR(ui32IntClr == CAN_INT_INTID_STATUS) || ((ui32IntClr >= 1) && (ui32IntClr <= 32))ui32Base + CAN_O_INTui32Base + CAN_O_MSG1INTui32Base + 0x00000140ui32Base + CAN_O_MSG2INTui32Base + 0x00000144320324(ui32IntFlags & ~(CAN_CTL_EIE | CAN_CTL_SIE | CAN_CTL_IE)) == 0ui8IntNumberui8IntNumber != 0ui32BitRegui32SavedInit28672192ui32Base + CAN_O_BITui32Base + CAN_O_BRPE4294967231~CAN_CTL_CCE4294967294~CAN_CTL_INIT(psClkParms->ui32SyncPropPhase1Seg >= 2) && (psClkParms->ui32SyncPropPhase1Seg <= 16)(psClkParms->ui32Phase2Seg >= 1) && (psClkParms->ui32Phase2Seg <= 8)(psClkParms->ui32SJW >= 1) && (psClkParms->ui32SJW <= 4)(psClkParms->ui32QuantumPrescaler <= 1024) && (psClkParms->ui32QuantumPrescaler >= 1)ui32DesiredRatioui32CANBitsui32PreDivideui32RegValueui16CANCTLCAN_MAX_PRE_DIVISORCAN_MAX_BIT_DIVISOR19456(CAN_MAX_PRE_DIVISOR * CAN_MAX_BIT_DIVISOR)CAN_MIN_BIT_DIVISORconst uint16_tconst uint16_t[16]unsigned short[16]const uint16_t *unsigned short *(0)ui32DesiredRatio <= (CAN_MAX_PRE_DIVISOR * CAN_MAX_BIT_DIVISOR)ui32DesiredRatio >= (CAN_MIN_PRE_DIVISOR * CAN_MIN_BIT_DIVISOR)ui32Msg176(CAN_IF1CMSK_WRNRD | CAN_IF1CMSK_ARB |
                                       CAN_IF1CMSK_CONTROL)(CAN_IF1CMSK_NEWDAT |
                                       CAN_IF1CMSK_CLRINTPND)_CANDataRegReadpui32Register++_CANDataRegWrite_CANIntNumberGet1074003968CAN0_BASE1074008064CAN1_BASE(ui32Base == CAN0_BASE) || (ui32Base == CAN1_BASE)const uint16_t[]unsigned short[]g_ui16CANBitValuesCAN_BIT_VALUE(2, 1, 1)CAN_BIT_VALUE(3, 1, 1)4672CAN_BIT_VALUE(3, 2, 2)76848644928CAN_BIT_VALUE(4, 2, 2)89609088CAN_BIT_VALUE(4, 3, 3)92169344CAN_BIT_VALUE(5, 3, 3)122881331213504CAN_BIT_VALUE(5, 4, 4)12801356813760CAN_BIT_VALUE(6, 4, 4)1766417856CAN_BIT_VALUE(6, 5, 4)15361792018112CAN_BIT_VALUE(7, 5, 4)204802201622208CAN_BIT_VALUE(7, 6, 4)17922227222464CAN_BIT_VALUE(8, 6, 4)245762636826560CAN_BIT_VALUE(8, 7, 4)pui8Datapui32Registerui32Size2662426816CAN_BIT_VALUE(9, 7, 4)3072030912CAN_BIT_VALUE(9, 8, 4)23043097631168CAN_BIT_VALUE(10, 8, 4)CAN_BIT_VALUE(seg1,seg2,sjw)((((seg1 - 1) << CAN_BIT_TSEG1_S) & CAN_BIT_TSEG1_M) | (((seg2 - 1) << CAN_BIT_TSEG2_S) & CAN_BIT_TSEG2_M) | (((sjw - 1) << CAN_BIT_SJW_S) & CAN_BIT_SJW_M))CAN_MIN_PRE_DIVISOR// Initiate programming the message object// the message is not valid.// Clear the message value bit in the arbitration register.  This indicates// Wait for busy bit to clear//! can be re-enabled immediately after the function call has returned.//! be disabled prior to the call for any of these functions.  The interrupt//! routine, then the corresponding interrupt for that interrupt routine should//! application code and if any of them are also used within an interrupt//! are not re-entrant.  If any of these functions are used in the main//! \note The functions CANIntClear(), CANMessageSet(), and CANMessageClear()//! messages, nor does it generate interrupts.//! object has been ``cleared,'' it no longer automatically sends or receives//! This function frees the specified message object from use.  Once a message//! \param ui32ObjID is the message object number to disable (1-32).//! \param ui32Base is the base address of the CAN controller.//! Clears a message object so that it is no longer used.// needs to be set to zero if none was available.// Along with the MSG_OBJ_NEW_DATA not being set the amount of data// Indicate that there is new data in this message.// ui32ObjID.// Transfer the message object to the message object specified by// Now clear out the new data flag.// Read out the data from the CAN registers.// that buffer anyway.// Don't read any data for a remote frame, there is nothing valid in// Get the amount of data needed to be read.// See if there is new data available.// Set the interrupt flags.// Indicate if direction filtering was enabled.// Indicate if the extended bit was used in filtering.// filtered.// set the MSG_OBJ_USE_ID_FILTER because the ID was not really// If this is a fully specified Mask and a remote frame then don't// The Identifier Mask is assumed to also be an 11 bit value.// The Identifier Mask is assumed to also be a 29 bit value.// Set the flag to indicate if ID masking was used.// Indicate that we lost some data.// The Identifier is an 11 bit value.// Set the 29 bit version of the Identifier for this message object.// the mask.// Get the identifier out of the register, the format depends on size of// Determine if this is a remote frame by checking the TXRQST and DIR bits.// Read out the IF Registers.// Set up the request for data from the message object.// Clear a pending interrupt and new data in a message object.// message object.// This is always a read to the Message object as this call is setting a//! The interrupt can be re-enabled immediately after the function call has//! interrupt should be disabled prior to the call for CANMessageGet().//! application code and in an interrupt routine, then the corresponding//! \note This function is not re-entrant.  If it is used in both main//!   this message object and not read by the host before being overwritten.//! - \b MSG_OBJ_DATA_LOST indicates that at least one message was received on//!   was read//! - \b MSG_OBJ_NEW_DATA indicates if this data is new since the last time it//! \e psMsgObject->ui32Flags://! with the following exceptions://! populated in the same way as when the CANMessageSet() function is used,//! When using CANMessageGet(), all of the same fields of the structure are//! be changed from a previous setting.//! load the fields of the structure in case only part of the structure must//! could also be used to read the contents of a message object in order to//! and stored a CAN message with a certain identifier.  However, this function//! Normally, this function is used to read a message object that has received//! plus some control and status information.//! \e psMsgObject.  The data consists of all of the parts of a CAN message,//! stored in the fields of the caller-supplied structure pointed to by//! in the CAN controller and return it to the caller.  The data returned is//! This function is used to read the contents of one of the 32 message objects//! cleared.//! \param bClrPendingInt indicates whether an associated interrupt should be//! \param psMsgObject points to a structure containing message object fields.//! \param ui32ObjID is the object number to read (1-32).//! Reads a CAN message from one of the message object buffers.// Write out the registers to program the message object.// Write the data out to the CAN Data registers if needed.// Enable receive interrupts if they should be enabled.// Enable transmit interrupts if they should be enabled.// Mark this as the last entry if this is not the last entry in a FIFO.// single transfer and not a FIFO transfer so set EOB bit.// Set the data length since this is set for all transfers.  This is also a// Mark the message as valid.// The lower 18 bits are set to zero.// Set the 11 bit version of the Identifier for this message object.// Mark the message as valid and set the extended ID bit.// Configure the Arbitration registers.// Set the Arb bit so that this gets transferred to the Message object.// Object.// Set the MASK bit so that this gets transferred to the Message// Set the UMASK bit to enable using the mask register.// The caller wants to filter on the message direction field.// If the caller wants to filter on the extended ID bit then set it.// in the register.// Put the 11 bit Mask Identifier into the upper bits of the field// Lower 16 bit are unused so set them to zero.// Set the 29 bits of Identifier mask that were requested.// Configure the Mask Registers.// beginning of this function.// This case never happens due to the ASSERT statement at the// The data to be returned needs to be filled in.// Set this object to auto answer if a matching identifier is seen.// Oddly the DIR bit is set to one for remote receivers.// Remote frame receive remote, with auto-transmit message object.// Make sure to send the mask to the message object.// Use the full Identifier by default.// a data frame.// was received and allow for software to handle it by sending back// Set this object so that it only indicates that a remote frame// was cleared by defaulting ui16MsgCtrl to 0.// The DIR bit is set to one for remote receivers.  The TXRQST bit// Receive remote request message object.// bit was cleared by defaulting ui16MsgCtrl to 0.// This clears the DIR bit along with everything else.  The TXRQST// Receive message object.// Set the TXRQST bit and the reset the rest of the register.// Transmit remote request message object// Transmit message object.// the type of message object that is being configured.// Initialize the values to a known state before filling them in based on// bits so this bit needs to be set as well.// both data bits.  The call uses the CONTROL register to set control// message object.  This call always sets all size bits so it sets// This is always a write to the Message object as this call is setting a// See if we need to use an extended identifier or not.//! definition, it is overwritten.//! If you specify a message object buffer that already contains a message//!    buffers.//! -# Call this function with \e ui32ObjID set to one of the 32 object//!    call as no data is present at the time of the call.//! -# The buffer pointed to by \e psMsgObject->pui8MsgData is not used by this//!    data frame.//! -# Set \e psMsgObject->ui32MsgLen to the number of bytes in the expected//!      filtering.//!    - Set \b MSG_OBJ_USE_ID_FILTER flag to enable identifier-based//!      frame is received.//!    - Set \b MSG_OBJ_RX_INT_ENABLE flag to be interrupted when the data//! -# Set \e psMsgObject->ui32Flags as follows://!    during comparison.//! -# Set \e psMsgObject->ui32MsgIDMask bits that are used for masking//!    to use partial ID matching.//! -# Set \e psMsgObject->ui32MsgID to the full message ID, or a partial mask//! -# Set \e eMsgObjType to \b MSG_OBJ_TYPE_RX.//! \b Example: To receive a specific data frame, take the following steps://!    bytes to send in the message.//! -# Set \e psMsgObject->pui8MsgData to point to an array containing the//! -# Set \e psMsgObject->ui32MsgLen to the number of bytes in the data frame.//!    message is sent.//!    \b MSG_OBJ_TX_INT_ENABLE to allow an interrupt to be generated when the//! -# Set \e psMsgObject->ui32Flags.  Make sure to set//! -# Set \e psMsgObject->ui32MsgID to the message ID.//! -# Set \e eMsgType to \b MSG_OBJ_TYPE_TX.//! request), take the following steps://! \b Example: To send a data frame or remote frame (in response to a remote//!   a data frame.//! - \e pui8MsgData - points to a buffer containing up to 8 bytes of data for//!   bytes of data in the responding data frame.//!   must be non-zero even for a remote frame; it must match the expected//! - \e ui32MsgLen - the number of bytes in the message data.  This parameter//!     identifier mask specified by \e ui32MsgIDMask.//!   - Set \b MSG_OBJ_USE_ID_FILTER flag to enable filtering based on the//!   - Set \b MSG_OBJ_RX_INT_ENABLE flag to enable interrupt on receipt.//!   - Set \b MSG_OBJ_TX_INT_ENABLE flag to enable interrupt on transmission.//! - \e ui32Flags//!   identifier filtering is enabled.//! - \e ui32MsgIDMask - mask of bits from \e ui32MsgID that must match if//! - \e ui32MsgID - contains the message ID, either 11 or 29 bits.//! caller, as follows://! The message object pointed to by \e psMsgObject must be populated by the//!   transmit message object.//! - \b MSG_OBJ_TYPE_RXTX_REMOTE - CAN remote frame receive remote, then//! - \b MSG_OBJ_TYPE_RX_REMOTE - CAN receive remote request message object.//! - \b MSG_OBJ_TYPE_RX - CAN receive message object.//! - \b MSG_OBJ_TYPE_TX_REMOTE - CAN transmit remote request message object.//! - \b MSG_OBJ_TYPE_TX - CAN transmit message object.//! The \e eMsgType parameter must be one of the following values://! CAN bus.//! are only taken when a message that meets certain parameters is seen on the//! message object can also be configured with a filter/mask so that actions//! interrupts on completion of message receipt or transmission.  The//! This call also allows the message object to be configured to generate//! message object as well as to use automatic transmission and reception.//! CAN controller.  A message object can be configured to be any type of CAN//! This function is used to configure any one of the 32 message objects in the//! \param eMsgType indicates the type of message for this object.//! settings.//! \param psMsgObject is a pointer to a structure containing message object//! \param ui32ObjID is the object number to configure (1-32).//! Configures a message object in the CAN controller.// Extract the error numbers from the register value.// Read the current count of transmit/receive errors.//! limit.//! passive limit, and \b false if the error count is below the error passive//! \return Returns \b true if the receive error count has reached the error//! and \e *pui32TxCount holds the current transmit error count.//! After this call, \e *pui32RxCount holds the current receive error count//! pointers provided as parameters.//! of the receive and transmit error counters are returned through the//! controller receive counter has reached the error passive limit.  The values//! receive error counts to the caller along with a flag indicating if the//! This function reads the error counter register and returns the transmit and//! \param pui32TxCount is a pointer to storage for the transmit error counter.//! \param pui32RxCount is a pointer to storage for the receive error counter.//! Reads the CAN controller error counter register.// Unknown CAN status requested so return 0.// Combine the Message valid status bits into one 32bit value.// Combine the New Data status bits into one 32bit value.// Combine the Transmit status bits into one 32bit value.// Just return the global CAN status register since that is what was//! \return Returns the value of the status register.//!   information to determine which message objects are empty/unused.//!   has a valid configuration programmed.  The host application can use this//! - \b CAN_STS_MSGVAL - if a message object's MSGVAL bit is set, the object//!   by the host application//!   message has been received in that object, and has not yet been picked up//! - \b CAN_STS_NEWDAT - if a message object's NEWDAT bit is set, a new//!   message.//!   information to determine which objects are still waiting to send a//!   transmission is pending on that object.  The application can use this//! - \b CAN_STS_TXREQUEST - if a message object's TXRQST bit is set, a//! contain the following information://! status of all the message objects without needing to query each one.  They//! message objects.  They can be used to quickly obtain information about the//! The remaining status registers consist of 32-bit-wide bit maps to the//! - \b CAN_STATUS_LEC_CRC - CRC error in received message//!   dominant mode//! - \b CAN_STATUS_LEC_BIT0 - recessive level detected when trying to send in//!   recessive mode//! - \b CAN_STATUS_LEC_BIT1 - dominant level detected when trying to send in//! - \b CAN_STATUS_LEC_ACK - a transmitted message was not acknowledged//!   of a message//! - \b CAN_STATUS_LEC_FORM - a format error occurred in the fixed format part//! - \b CAN_STATUS_LEC_STUFF - stuffing error detected//! - \b CAN_STATUS_LEC_NONE - no error//! - \b CAN_STATUS_LEC_MSK - mask of last error code bits (3 bits)//! - \b CAN_STATUS_TXOK - a message was successfully transmitted//!   any message filtering).//! - \b CAN_STATUS_RXOK - a message was received successfully (independent of//! - \b CAN_STATUS_EPASS - CAN controller is in the error passive state//! - \b CAN_STATUS_EWARN - an error counter has reached a limit of at least 96//! - \b CAN_STATUS_BUS_OFF - controller is in bus-off condition//! controller status register fields are as follows://! handler for the CAN controller if the cause is a status interrupt.  The//! interrupt is cleared.  This parameter is used in the interrupt//! When reading the main controller status register, a pending status//! - \b CAN_STS_MSGVAL - bit mask of objects with valid configuration//! - \b CAN_STS_NEWDAT - bit mask of objects with new data//! - \b CAN_STS_TXREQUEST - bit mask of objects pending transmission//! - \b CAN_STS_CONTROL - the main controller status//! The different status registers are://! to the caller.//! This function reads a status register of the CAN controller and returns it//! \param eStatusReg is the status register to read.//! Reads one of the controller status registers.// Automatic data retransmission is enabled.// Automatic data retransmission is not enabled.// Read the disable automatic retry setting from the CAN controller.//! otherwise.//! \return Returns \b true if automatic retransmission is enabled, \b false//! CAN controller and returns it to the caller.//! This function reads the current setting for automatic retransmission in the//! Returns the current setting for automatic retransmission.// of messages which were not transmitted or received correctly.// Setting the DAR bit tells the controller to disable the auto-retry// correctly.// auto-retry of messages which were not transmitted or received// Clearing the DAR bit tells the controller to not disable the// Conditionally set the DAR bit to enable/disable auto-retry.//! retransmission is enabled, otherwise it is disabled.//! detected errors.  If \e bAutoRetry is \b true, then automatic//! This function enables or disables automatic retransmission of messages with//! \param bAutoRetry enables automatic retransmission.//! Sets the CAN controller automatic retransmission behavior.// Wait to be sure that this interface is not busy.// Send the clear pending interrupt command to the CAN controller.// CAN_IF1CMSK_CLRINTPND bit.// Only change the interrupt pending state by setting only the// Simply read and discard the status to clear the interrupt.//! cleared by reading the message object using CANMessageGet().//! using CANStatusGet().  A specific message object interrupt is normally//! Normally, the status interrupt is cleared by reading the controller status//! source without taking the normal interrupt action.//! function is only used if the application wants to clear an interrupt//! It is not necessary to use this function to clear an interrupt.  This//! - 1-32 - Clears the specified message object interrupt//! - \b CAN_INT_INTID_STATUS - Clears a status interrupt.//! \e ui32IntClr parameter must be one of the following values://! This function can be used to clear a specific interrupt source.  The//! \param ui32IntClr is a value indicating which interrupt source to clear.//! Clears a CAN interrupt source.// Return the interrupt status value// Request was for unknown status so just return 0.// Read and combine both 16 bit values into one 32bit status.// messages.// The caller wants the current message status interrupt for all// specified by ui32Base.// The caller wants the global interrupt status for the CAN controller// See which status the caller is looking for.//! \return Returns the value of one of the interrupt status registers.//! register by using \b CAN_INT_STS_CAUSE.//! pending interrupts at once, as opposed to repeatedly reading the interrupt//! have pending interrupts.  This value can be used to discover all of the//! \b CAN_INT_STS_OBJECT returns a bit mask indicating which message objects//! cleared before returning from the interrupt.//! can read the interrupt status again to make sure all pending interrupts are//! CANMessageGet() in the case of a received message.  The interrupt handler//! using the CANIntClear() function, or by reading the message using//! has an interrupt pending.  The message object interrupt can be cleared by//! then this indicates the number of the highest priority message object that//! interrupt.  If the value of the interrupt register is in the range 1-32,//! Calling this function to read the status also clears the status//! the status register is read with the CANStatusGet() function.//! \b CAN_INT_INTID_STATUS if the cause is a status interrupt.  In this case,//! and indicates the cause of the interrupt.  The value returned is//! \b CAN_INT_STS_CAUSE returns the value of the controller interrupt register//! objects//! - \b CAN_INT_STS_OBJECT - indicates pending interrupts of all message//! - \b CAN_INT_STS_CAUSE - indicates the cause of the interrupt//! parameter, which can have one of the following values://! The interrupt status register read is determined by the \e eIntStsReg//! This function returns the value of one of two interrupt status registers.//! \param eIntStsReg indicates which interrupt status register to read//! Returns the current CAN controller interrupt status.// Disable the specified interrupts.//! CANIntEnable() function.//! The \e ui32IntFlags parameter has the same definition as in the//! interrupt sources can cause a processor interrupt.//! Disables the specified CAN controller interrupt sources.  Only enabled//! disabled.//! \param ui32IntFlags is the bit mask of the interrupt sources to be//! Disables individual CAN controller interrupt sources.// Enable the specified interrupts.//! the cause.//! needs to handle.  When an interrupt occurs, use CANIntStatus() to determine//! status conditions and may provide more interrupts than the application//! a limit.  \b CAN_INT_STATUS generates an interrupt under quite a few//! controller enters the ``bus off'' condition, or if the error counters reach//! CANMessageSet()).  \b CAN_INT_ERROR generates an interrupt if the//! an interrupt, that message object must have interrupts enabled (see//! Further, for any particular transaction from a message object to generate//! In order to generate any interrupts, \b CAN_INT_MASTER must be enabled.//! - \b CAN_INT_MASTER - allow CAN controller to generate interrupts//!   been detected//! - \b CAN_INT_STATUS - a message transfer has completed, or a bus error has//! - \b CAN_INT_ERROR - a controller error condition has occurred//! Only enabled sources cause a processor interrupt.//! This function enables specific interrupt sources of the CAN controller.//! \param ui32IntFlags is the bit mask of the interrupt sources to be enabled.//! Enables individual CAN controller interrupt sources.// Disable the CAN interrupt.// Get the actual interrupt number for this CAN controller.//! \param ui32Base is the base address of the controller.//! Unregisters an interrupt handler for the CAN controller.// Enable the CAN interrupt.//! Instead, IntEnable() is used to enable CAN interrupts on the//! CANIntClear().//! interrupt sources must be enabled using CANIntEnable().  The interrupt//! table, and enables CAN interrupts on the interrupt controller; specific CAN//! enabled CAN interrupts occur.//! Registers an interrupt handler for the CAN controller.// If Init was not set before, then clear it.// Clear the config change bit, and restore the init bit.// Set the divider upper bits in the extension register.// Set the bit fields of the bit timing register according to the parms.// of the init bit must be saved so it can be restored at the end.// mode (if not already), and also configuration change bit enabled.  State// To set the bit timing register, the controller must be placed in init// The CAN clock pre-divider must be in the range from 1 to 1024.// The synchronous jump windows must be in the range from 1 to 4.// The phase 2 segment must be in the range from 1 to 8.// The phase 1 segment must be in the range from 2 to 16.//! (8 MHz) / ((5 + 2 + 1) * 2) or 500 Kbit/sec.//! \e ui32QuantumPrescaler = 2 and an 8 MHz CAN clock, the bit rate is//! Thus with \e ui32SyncPropPhase1Seg = 4, \e ui32Phase2Seg = 1,//! (\e ui32QuantumPrescaler))//! ((\e ui32SyncPropPhase1Seg + \e ui32Phase2Seg + 1) *//! CAN Clock ///! The equation to determine the actual bit rate is as follows://! to derive the correct duration of Prop_Seg and Phase1_Seg.//! Note that the Sync_Seg is always one quantum in duration, and is added//! bit_time_q = ui32SyncPropPhase1Seg + ui32Phase2Seg + 1//! as follows://! The total bit time, in quanta, is the sum of the two Seg parameters,//! the CAN module clock.//! \e psClkParms->ui32QuantumPrescaler value, which specifies the divisor for//! time quanta.  The actual quantum time is determined by the//! parameters, along with \e psClkParms->ui32SJW are based in units of bit//! determined from the \e psClkParms->ui32Phase2Seg parameter.  These two//! \e psClkParms->ui32SyncPropPhase1Seg parameter.  Phase Buffer 2 is//! Buffer 1 segments are derived from the combination//! the Synchronization Jump Width.  The values for Propagation and Phase//! Propagation segment, Phase Buffer 1 segment, Phase Buffer 2 segment, and//! Configures the various timing parameters for the CAN bus bit timing://! \param psClkParms points to the structure with the clock parameters.//! Configures the CAN controller bit timing.// bit rate was not changed.// A valid combination could not be found, so return 0 to indicate that the// more than 2 loops required to find the value.// Move the divisor up one and look again.  Only in rare cases are// Return the computed bit rate.// Restore the saved CAN Control register.// pre-scalar.// Set the clock bits in the and the lower bits of the// Now add in the pre-scalar on the bit rate.// saved so it can be restored.// change bit enabled.  The state of the register must be// placed in init mode (if not already), and also configuration// To set the bit timing register, the controller must be// in time quanta.// Start building the bit timing value by adding the bit timing// return these bit rate and set the CAN bit timing.// If the calculated divisors match the desired clock ratio then// For a given CAN bit divisor save the pre divisor.// Loop through all possible CAN bit divisors.// Check all possible values to find a matching value.// requirement that the bit rate is larger than requested.// Make sure that the Desired Ratio is not too large.  This enforces the// small or too large.// Make sure that the ratio of CAN bit rate to processor clock is not too// Calculate the desired clock rate.//! changed because the requested bit rate was not valid.//! configured to use or it returns 0 to indicate that the bit rate was not//! \return This function returns the bit rate that the CAN controller was//! \e ui32SourceClock must be set to 8000000.//! \note On some devices the source clock is fixed at 8MHz so the//! without being higher than the \e ui32BitRate value.//! exactly, the bit rate is set to the value closest to the desired bit rate//! the CAN bit timing values.  Because not all bit rates can be matched//! CANBitTimingSet() function is available for full customization of all of//! requirements or longer network lengths are needed, then the//! most cases where the network length is short.  If tighter timing//! calculated assuming a minimal amount of propagation delay, which works for//! SysCtlClockGet() or using a specific value in Hz.  The CAN bit timing is//! function must pass in the source clock rate either by retrieving it from//! Because the CAN clock is based off of the system clock, the calling//! \e ui32BitRate parameter based on the \e ui32SourceClock parameter.//! This function sets the CAN bit timing for the bit rate passed in the//! \param ui32BitRate is the desired bit rate.//! \param ui32SourceClock is the system clock for the device in Hz.//! bit rate.//! Sets the CAN bit timing values to a nominal setting based on a desired// Set the pre-divider for the CAN bus bit clock.// Set the synchronous jump width.// Set the phase 1 segment.// Set the phase 2 segment.// Read out all the bit timing values from the CAN controller registers.//! values that are returned in the structure pointed to by \e psClkParms.//! supplied by the caller.  Refer to CANBitTimingSet() for the meaning of the//! clock timing and stores the resulting information in the structure//! This function reads the current configuration of the CAN controller bit//! parameters.//! \param psClkParms is a pointer to a structure to hold the timing//! Reads the current settings for the CAN controller bit timing.// Set the init bit in the control register.//! before this call was made.//! controller and the message objects in the controller are left as they were//! controller can be restarted by calling CANEnable().  The state of the CAN//! controller no longer automatically processes data on the CAN bus.  The//! Disables the CAN controller for message processing.  When disabled, the//! \param ui32Base is the base address of the CAN controller to disable.//! Disables the CAN controller.// Clear the init bit in the control register.//! calling CANBitTimingSet().//! initialize the controller and the CAN bus clock must be configured by//! Prior to calling CANEnable(), CANInit() must have been called to//! received frames.  The controller can be stopped by calling CANDisable().//! controller automatically transmits any pending frames, and processes any//! Enables the CAN controller for message processing.  Once enabled, the//! \param ui32Base is the base address of the CAN controller to enable.//! Enables the CAN controller.// Acknowledge any pending status interrupts.// Wait for busy bit to clear.// Loop through to program all 32 message objects// message objects.// Make sure that the interrupt and new data flags are updated for the// object.  The same arb reg is used to program all the message objects.// the message is not valid and is a "safe" condition to leave the message// programmed.// puts controller in idle, and allow the message object RAM to be// Place CAN controller in init state, regardless of previous state.  This//! the first time.//! configured.  This function must be called before enabling the controller//! unwanted transmission or reception of data before the message objects are//! cleared prior to enabling the CAN controller the first time.  This prevents//! the memory used for message objects contains undefined values and must be//! After reset, the CAN controller is left in the disabled state.  However,//! Initializes the CAN controller after reset.// Only read the second byte if needed.// Store the first byte.// are aligned in memory.// Read out the data 16 bits at a time since this is how the registers// Loop always copies 1 or 2 bytes per iteration.//! function.//! controller.  This function is rarely used outside of the CANMessageGet()//! in memory from the non-contiguous data registers used by the CAN//! This function takes the steps necessary to copy data to a contiguous buffer//! \param iSize is the number of bytes to copy from the CAN controller.//! \b CAN_O_IF1DA1.//! register set on CAN controller 1, the value would be: \b CAN0_BASE \b +//! CAN controller's data registers.  For example, in order to use the IF1//! \param pui32Register is an uint32_t pointer to the first register of the//! the CAN controller's data registers.//! \param pui8Data is a pointer to the location to store the data read from//! Copies data from a buffer to the CAN Data registers.//! \internal// Only write the second byte if needed otherwise the value is zero.// Write out the data 16 bits at a time since this is how the registers//! controller.  This function is rarely used outside of the CANMessageSet()//! buffer in memory into the non-contiguous data registers used by the CAN//! This function takes the steps necessary to copy data from a contiguous//! \param iSize is the number of bytes to copy into the CAN controller.//! register set on CAN controller 0, the value would be: \b CAN0_BASE \b +//! controller's data registers.//! \param pui8Data is a pointer to the data to be written out to the CAN// Find the valid interrupt number for this CAN controller.//! exist.//! \return Returns a CAN interrupt number or 0 if the interrupt does not//! address passed in the \e ui32Base parameter.//! This function returns the interrupt number for the CAN module with the base//! \param ui32Base is the base address of the selected CAN controller//! Returns the CAN controller interrupt number.//! \return Returns \b true if the base address is valid and \b false//! This function determines if a CAN controller base address is valid.//! Checks a CAN base address.// 19 clocks/bit// 18 clocks/bit// 17 clocks/bit// 16 clocks/bit// 15 clocks/bit// 14 clocks/bit// 13 clocks/bit// 12 clocks/bit// 11 clocks/bit// 10 clocks/bit// 9 clocks/bit// 8 clocks/bit// 7 clocks/bit// 6 clocks/bit// 5 clocks/bit// 4 clocks/bit// the bit timing values.// This table is used by the CANBitRateSet() API as the register defaults for// programmed into the CAN_BIT register to achieve those timings.// Converts a set of CAN bit timing values into the value that needs to be// The minimum CAN pre-divisor is 1.// The maximum CAN pre-divisor is 1024.// The minimum CAN bit timing divisor is 4.// The maximum CAN bit timing divisor is 19.// identifier.// This is the maximum number that can be stored as an 11bit Message// can.c - Driver for the CAN module./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/inc/hw_comp.hCOMP_PP_CMP0COMP_PP_CMP1COMP_PP_CMP2COMP_PP_C0OCOMP_PP_C1OCOMP_PP_C2OCOMP_ACCTL2_CINVCOMP_ACCTL2_ISEN_BOTHCOMP_ACCTL2_ISEN_RISECOMP_ACCTL2_ISEN_FALLCOMP_ACCTL2_ISEN_LEVELCOMP_ACCTL2_ISEN_MCOMP_ACCTL2_ISLVALCOMP_ACCTL2_TSEN_BOTHCOMP_ACCTL2_TSEN_RISECOMP_ACCTL2_TSEN_FALLCOMP_ACCTL2_TSEN_LEVELCOMP_ACCTL2_TSEN_MCOMP_ACCTL2_TSLVALCOMP_ACCTL2_ASRCP_REFCOMP_ACCTL2_ASRCP_PIN0COMP_ACCTL2_ASRCP_PINCOMP_ACCTL2_ASRCP_MCOMP_ACCTL2_TOENCOMP_ACSTAT2_OVALCOMP_ACCTL1_CINVCOMP_ACCTL1_ISEN_BOTHCOMP_ACCTL1_ISEN_RISECOMP_ACCTL1_ISEN_FALLCOMP_ACCTL1_ISEN_LEVELCOMP_ACCTL1_ISEN_MCOMP_ACCTL1_ISLVALCOMP_ACCTL1_TSEN_BOTHCOMP_ACCTL1_TSEN_RISECOMP_ACCTL1_TSEN_FALLCOMP_ACCTL1_TSEN_LEVELCOMP_ACCTL1_TSEN_MCOMP_ACCTL1_TSLVALCOMP_ACCTL1_ASRCP_REFCOMP_ACCTL1_ASRCP_PIN0COMP_ACCTL1_ASRCP_PINCOMP_ACCTL1_ASRCP_MCOMP_ACCTL1_TOENCOMP_ACSTAT1_OVALCOMP_ACCTL0_CINVCOMP_ACCTL0_ISEN_BOTHCOMP_ACCTL0_ISEN_RISECOMP_ACCTL0_ISEN_FALLCOMP_ACCTL0_ISEN_LEVELCOMP_ACCTL0_ISEN_MCOMP_ACCTL0_ISLVALCOMP_ACCTL0_TSEN_BOTHCOMP_ACCTL0_TSEN_RISECOMP_ACCTL0_TSEN_FALLCOMP_ACCTL0_TSEN_LEVELCOMP_ACCTL0_TSEN_MCOMP_ACCTL0_TSLVALCOMP_ACCTL0_ASRCP_REFCOMP_ACCTL0_ASRCP_PIN0COMP_ACCTL0_ASRCP_PINCOMP_ACCTL0_ASRCP_MCOMP_ACCTL0_TOENCOMP_ACSTAT0_OVALCOMP_ACREFCTL_VREF_SCOMP_ACREFCTL_VREF_MCOMP_ACREFCTL_RNGCOMP_ACREFCTL_ENCOMP_ACINTEN_IN0COMP_ACINTEN_IN1COMP_ACINTEN_IN2COMP_ACRIS_IN0COMP_ACRIS_IN1COMP_ACRIS_IN2COMP_ACMIS_IN0COMP_ACMIS_IN1COMP_ACMIS_IN2COMP_O_PPCOMP_O_ACCTL2COMP_O_ACSTAT2COMP_O_ACCTL1COMP_O_ACSTAT1COMP_O_ACCTL0COMP_O_ACSTAT0COMP_O_ACREFCTLCOMP_O_ACINTENCOMP_O_ACRISCOMP_O_ACMIS__HW_COMP_H__// __HW_COMP_H__// Comparator 0 Present// Comparator 1 Present// Comparator 2 Present// Comparator Output 0 Present// Comparator Output 1 Present// Comparator Output 2 Present// The following are defines for the bit fields in the COMP_O_PP register.// Comparator Output Invert// Either edge// Rising edge// Falling edge// Level sense, see ISLVAL// Interrupt Sense// Interrupt Sense Level Value// Level sense, see TSLVAL// Trigger Sense// Trigger Sense Level Value// Internal voltage reference// Pin value of C0+// Pin value of Cn+// Analog Source Positive// Trigger Output Enable// The following are defines for the bit fields in the COMP_O_ACCTL2 register.// Comparator Output Value// The following are defines for the bit fields in the COMP_O_ACSTAT2 register.// The following are defines for the bit fields in the COMP_O_ACCTL1 register.// The following are defines for the bit fields in the COMP_O_ACSTAT1 register.// The following are defines for the bit fields in the COMP_O_ACCTL0 register.// The following are defines for the bit fields in the COMP_O_ACSTAT0 register.// Resistor Ladder Voltage Ref// Resistor Ladder Range// Resistor Ladder Enable// The following are defines for the bit fields in the COMP_O_ACREFCTL// Comparator 0 Interrupt Enable// Comparator 1 Interrupt Enable// Comparator 2 Interrupt Enable// The following are defines for the bit fields in the COMP_O_ACINTEN register.// Comparator 0 Interrupt Status// Comparator 1 Interrupt Status// Comparator 2 Interrupt Status// The following are defines for the bit fields in the COMP_O_ACRIS register.// Comparator 0 Masked Interrupt// Comparator 1 Masked Interrupt// Comparator 2 Masked Interrupt// The following are defines for the bit fields in the COMP_O_ACMIS register.// Properties// Analog Comparator Control 2// Analog Comparator Status 2// Analog Comparator Control 1// Analog Comparator Status 1// Analog Comparator Control 0// Analog Comparator Status 0// Voltage Control// Analog Comparator Reference// Analog Comparator Interrupt// Analog Comparator Raw Interrupt// Analog Comparator Masked// The following are defines for the Comparator register offsets.// hw_comp.h - Macros used when accessing the comparator hardware./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/comp.hCOMP_REF_2_371875V0x0000020FCOMP_REF_2_26875V0x0000020ECOMP_REF_2_165625V0x0000020DCOMP_REF_2_0625V0x0000030FCOMP_REF_1_959375V0x0000020BCOMP_REF_1_925V0x0000030ECOMP_REF_1_85625V0x0000020ACOMP_REF_1_7875V0x0000030DCOMP_REF_1_753125V0x00000209COMP_REF_1_65V0x0000030CCOMP_REF_1_546875V0x00000207COMP_REF_1_5125V0x0000030BCOMP_REF_1_44375V0x00000206COMP_REF_1_375V0x0000030ACOMP_REF_1_340625V0x00000205COMP_REF_1_2375V0x00000309COMP_REF_1_1V0x00000308COMP_REF_1_134375V0x00000203COMP_REF_1_03125V0x00000202COMP_REF_0_9625V0x00000307COMP_REF_0_928125V0x00000201COMP_REF_0_825V0x00000306COMP_REF_0_6875V0x00000305COMP_REF_0_55V0x00000304COMP_REF_0_4125V0x00000303COMP_REF_0_275V0x00000302COMP_REF_0_1375V0x00000301COMP_REF_0VCOMP_REF_OFFCOMP_OUTPUT_INVERTCOMP_OUTPUT_NORMALCOMP_ASRCP_REFCOMP_ASRCP_PIN0COMP_ASRCP_PINCOMP_INT_BOTHCOMP_INT_RISECOMP_INT_FALLCOMP_INT_LOWCOMP_INT_HIGHCOMP_TRIG_BOTH0x00000860COMP_TRIG_RISE0x00000840COMP_TRIG_FALL0x00000820COMP_TRIG_LOWCOMP_TRIG_HIGH0x00000880COMP_TRIG_NONE__DRIVERLIB_COMP_H__ComparatorIntClearComparatorIntStatusComparatorIntDisableComparatorIntEnableComparatorIntUnregisterComparatorIntRegisterComparatorValueGetComparatorRefSetComparatorConfigure// __DRIVERLIB_COMP_H__// Internal reference of 2.371875V// Internal reference of 2.26875V// Internal reference of 2.165625V// Internal reference of 2.0625V// Internal reference of 1.959375V// Internal reference of 1.925V// Internal reference of 1.85625V// Internal reference of 1.7875V// Internal reference of 1.753125V// Internal reference of 1.65V// Internal reference of 1.546875V// Internal reference of 1.5125V// Internal reference of 1.44375V// Internal reference of 1.375V// Internal reference of 1.340625V// Internal reference of 1.2375V// Internal reference of 1.1V// Internal reference of 1.134375V// Internal reference of 1.03125V// Internal reference of 0.9625V// Internal reference of 0.928125V// Internal reference of 0.825V// Internal reference of 0.6875V// Internal reference of 0.55V// Internal reference of 0.4125V// Internal reference of 0.275V// Internal reference of 0.1375V// Internal reference of 0V// Turn off the internal reference// Values that can be passed to ComparatorSetRef() as the ui32Ref parameter.// Comparator output inverted// Comparator output normal// Comp0+ pin// Dedicated Comp+ pin// Interrupt on both edges// Interrupt on rising edge// Interrupt on falling edge// Interrupt when low// Interrupt when high// Trigger on both edges// Trigger on rising edge// Trigger on falling edge// Trigger when low// Trigger when high// No ADC trigger// from the other groups via a logical OR.// so on), one of the values may be selected and combined together with values// parameter.  For each group (in other words, COMP_TRIG_xxx, COMP_INT_xxx, and// Values that can be passed to ComparatorConfigure() as the ui32Config// comp.h - Prototypes for the analog comparator driver./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/comp.c"driverlib/comp.h""inc/hw_comp.h"ui32Base + COMP_O_ACMISui32Base == COMP_BASEui32Comp < 3ui32Base + COMP_O_ACRISui32Base + COMP_O_ACINTENui32Base + (ui32Comp * 0x20) + COMP_O_ACSTAT0ui32Base + (ui32Comp * 0x20) + 0x00000020ui32Base + COMP_O_ACREFCTLui32Base + (ui32Comp * 0x20) + COMP_O_ACCTL0ui32Base + (ui32Comp * 0x20) + 0x00000024//! interrupt, the interrupt cannot be cleared until it stops asserting.//! being called again immediately upon exit.  Note that for a level-triggered//! function must be called in the interrupt handler to keep the handler from//! The comparator interrupt is cleared, so that it no longer asserts.  This//! \param ui32Base is the base address of the comparator module.//! Clears a comparator interrupt.//! asserted.//! \return \b true if the interrupt is asserted and \b false if it is not//! raw or the masked interrupt status can be returned.//! This function returns the interrupt status for the comparator.  Either the// Disable the comparator interrupt.//! to the processor.//! comparator.  Only enabled comparator interrupts can be reflected//! This function disables generation of an interrupt from the specified//! Disables the comparator interrupt.// Enable the comparator interrupt.//! This function enables generation of an interrupt from the specified//! Enables the comparator interrupt.// Disable the interrupt in the interrupt controller.//! controller so that the interrupt handler no longer is called.//! occurs.  This function also masks off the interrupt in the interrupt//! This function clears the handler to be called when a comparator interrupt//! Unregisters an interrupt handler for a comparator interrupt.// Enable the interrupt in the interrupt controller.// Register the interrupt handler, returning an error if an error occurs.//! ComparatorIntClear().//! interrupt handler's responsibility to clear the interrupt source via//! occurs and enables the interrupt in the interrupt controller.  It is the//! This function sets the handler to be called when the comparator interrupt//! comparator interrupt occurs.//! Registers an interrupt handler for the comparator interrupt.// value.// Return the appropriate value based on the comparator's present output//! the comparator output is low.//! \return Returns \b true if the comparator output is high and \b false if//! This function retrieves the current value of the comparator output.//! Gets the current comparator output value.// Set the voltage reference voltage as requested.//! - \b COMP_REF_2_371875V to set the reference voltage to 2.371875 V//! - \b COMP_REF_2_26875V to set the reference voltage to 2.26875 V//! - \b COMP_REF_2_165625V to set the reference voltage to 2.165625 V//! - \b COMP_REF_2_0625V to set the reference voltage to 2.0625 V//! - \b COMP_REF_1_959375V to set the reference voltage to 1.959375 V//! - \b COMP_REF_1_925V to set the reference voltage to 1.925 V//! - \b COMP_REF_1_85625V to set the reference voltage to 1.85625 V//! - \b COMP_REF_1_7875V to set the reference voltage to 1.7875 V//! - \b COMP_REF_1_753125V to set the reference voltage to 1.753125 V//! - \b COMP_REF_1_65V to set the reference voltage to 1.65 V//! - \b COMP_REF_1_546875V to set the reference voltage to 1.546875 V//! - \b COMP_REF_1_5125V to set the reference voltage to 1.5125 V//! - \b COMP_REF_1_44375V to set the reference voltage to 1.44375 V//! - \b COMP_REF_1_375V to set the reference voltage to 1.375 V//! - \b COMP_REF_1_340625V to set the reference voltage to 1.340625 V//! - \b COMP_REF_1_2375V to set the reference voltage to 1.2375 V//! - \b COMP_REF_1_1V to set the reference voltage to 1.1 V//! - \b COMP_REF_1_134375V to set the reference voltage to 1.134375 V//! - \b COMP_REF_1_03125V to set the reference voltage to 1.03125 V//! - \b COMP_REF_0_9625V to set the reference voltage to 0.9625 V//! - \b COMP_REF_0_928125V to set the reference voltage to 0.928125 V//! - \b COMP_REF_0_825V to set the reference voltage to 0.825 V//! - \b COMP_REF_0_6875V to set the reference voltage to 0.6875 V//! - \b COMP_REF_0_55V to set the reference voltage to 0.55 V//! - \b COMP_REF_0_4125V to set the reference voltage to 0.4125 V//! - \b COMP_REF_0_275V to set the reference voltage to 0.275 V//! - \b COMP_REF_0_1375V to set the reference voltage to 0.1375 V//! - \b COMP_REF_0V to set the reference voltage to 0 V//! - \b COMP_REF_OFF to turn off the reference voltage//! specified as one of the following values://! This function sets the internal reference voltage value.  The voltage is//! \param ui32Ref is the desired reference voltage.//! Sets the internal reference voltage.// Configure this comparator.//! a device pin.//! - \b COMP_OUTPUT_INVERT to enable an inverted output from the comparator to//! to a device pin.//! - \b COMP_OUTPUT_NORMAL to enable a non-inverted output from the comparator//! The \b COMP_OUTPUT_xxx term can take on the following values://! reference voltage.//! - \b COMP_ASRCP_REF to use the internally generated voltage as the//! the same as \b COMP_ASRCP_PIN for the comparator 0).//! - \b COMP_ASRCP_PIN0 to use the Comp0+ pin as the reference voltage (this//! voltage.//! - \b COMP_ASRCP_PIN to use the dedicated Comp+ pin as the reference//! The \b COMP_ASRCP_xxx term can take on the following values://! low or high.//! - \b COMP_INT_BOTH to generate an interrupt when the comparator output goes//! high.//! - \b COMP_INT_RISE to generate an interrupt when the comparator output goes//! low.//! - \b COMP_INT_FALL to generate an interrupt when the comparator output goes//! - \b COMP_INT_LOW to generate an interrupt when the comparator output is//! - \b COMP_INT_HIGH to generate an interrupt when the comparator output is//! The \b COMP_INT_xxx term can take on the following values://! or high.//! - \b COMP_TRIG_BOTH to trigger the ADC when the comparator output goes low//! - \b COMP_TRIG_RISE to trigger the ADC when the comparator output goes//! - \b COMP_TRIG_FALL to trigger the ADC when the comparator output goes low.//! - \b COMP_TRIG_LOW to trigger the ADC when the comparator output is low.//! - \b COMP_TRIG_HIGH to trigger the ADC when the comparator output is high.//! - \b COMP_TRIG_NONE to have no trigger to the ADC.//! The \b COMP_TRIG_xxx term can take on the following values://! \b COMP_INT_xxx, \b COMP_ASRCP_xxx, and \b COMP_OUTPUT_xxx values.//! result of a logical OR operation between the \b COMP_TRIG_xxx,//! This function configures a comparator.  The \e ui32Config parameter is the//! Configures a comparator.//! \addtogroup comp_api// comp.c - Driver for the analog comparator./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/cpu.h__DRIVERLIB_CPU_H__CPUbasepriSetnakedCPUbasepriGetvoid_param_listCPUwfiCPUprimaskCPUcpsieCPUcpsid// __DRIVERLIB_CPU_H__// Prototypes.// cpu.h - Prototypes for the CPU instruction wrapper functions.ui32NewBasepri/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/cpu.c"driverlib/cpu.h"ui32Retdefined(codered) || defined(gcc) || defined(sourcerygxx)defined(ewarm)defined(rvmdk) || defined(__ARMCC_VERSION)defined(ccs)gcc// you expect in R0.// return(0) is never executed and the function returns with the value// a zero.  However, the real return is the "bx lr" above, so the// return value from this function.  It will generate code to return// The following keeps the compiler happy, because it wants to see a// Read BASEPRI// above and a superfluous return statement here.// is suppressed here to avoid putting a "bx lr" in the inline assembly// "Warning[Pe940]: missing return statement at end of non-void function"// naked attribute).// that this does not result in any code being produced because of the// still complain if there is not an explicit return here (despite the fact// The return is handled in the inline assembly, but the compiler will// Wrapper function for reading the BASEPRI register.// Set the BASEPRI register// Wrapper function for writing the BASEPRI register.// Wait for the next interrupt.// Wrapper function for the WFI instruction.// Read PRIMASK and enable interrupts.// on entry.// Wrapper function for the CPSIE instruction.  Returns the state of PRIMASK// Read PRIMASK and disable interrupts.// interrupts are enabled or disabled).// Wrapper function returning the state of PRIMASK (indicating whether// Wrapper function for the CPSID instruction.  Returns the state of PRIMASK//         drivers.// cpu.c - Instruction wrappers for special CPU instructions needed by the/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/crc.hCRC_CFG_TYPE_TCPCHKSUMCRC_CFG_TYPE_P1EDC6F41CRC_CFG_TYPE_P4C11DB7CRC_CFG_TYPE_P1021CRC_CFG_TYPE_P8005CRC_CFG_ENDIAN_SHWCRC_CFG_ENDIAN_SBHWCRC_CFG_IBRCRC_CFG_OBRCRC_CFG_RESINVCRC_CFG_SIZE_32BITCRC_CFG_SIZE_8BITCRC_CFG_INIT_1CRC_CFG_INIT_0CRC_CFG_INIT_SEED__DRIVERLIB_CRC_H__CRCSeedSetCRCResultReadCRCDataWriteCRCDataProcessCRCConfigSet// __DRIVERLIB_CRC_H__// Swap half-word// Swap byte in half-word// Initialize with seed// ECConfig function.// The following defines are used in the ui32Config argument of the// crc.h - Defines and Macros for CRC module.ui32SeedbPPResultui32Datapui32DataInui32DataLengthui32CRCConfig/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/crc.c"driverlib/crc.h"pui8DataInui32Base + CCM_O_CRCCTRLui32Base + 0x00000400ui32Base + CCM_O_CRCDINui32Base + 0x000004141044ui32Base == CCM0_BASEui32Base + CCM_O_CRCRSLTPPui32Base + 0x00000418ui32Base + CCM_O_CRCSEEDui32Base + 0x0000041010481040(ui32CRCConfig & CRC_CFG_INIT_SEED) || (ui32CRCConfig & CRC_CFG_INIT_0) || (ui32CRCConfig & CRC_CFG_INIT_1) || (ui32CRCConfig & CRC_CFG_SIZE_8BIT) || (ui32CRCConfig & CRC_CFG_SIZE_32BIT) || (ui32CRCConfig & CRC_CFG_RESINV) || (ui32CRCConfig & CRC_CFG_OBR) || (ui32CRCConfig & CRC_CFG_IBR) || (ui32CRCConfig & CRC_CFG_ENDIAN_SBHW) || (ui32CRCConfig & CRC_CFG_ENDIAN_SHW) || (ui32CRCConfig & CRC_CFG_TYPE_P8005) || (ui32CRCConfig & CRC_CFG_TYPE_P1021) || (ui32CRCConfig & CRC_CFG_TYPE_P4C11DB7) || (ui32CRCConfig & CRC_CFG_TYPE_P1EDC6F41) || (ui32CRCConfig & CRC_CFG_TYPE_TCPCHKSUM)// Return the result.// Write the next data word.// The CRC is operating in 32-bit mode, so loop through the input data.// Write the next data byte.// Loop through the input data.// the data.// The CRC is operating in 8-bit mode, so create an 8-bit pointer to// See if the CRC is operating in 8-bit or 32-bit mode.//! \return The CRC result.//! \b CRC_CFG_OBR parameters.//! options are selectable through \b CRC_CFG_RESINV and//! post- processed CRC result from the EC module.  The post-processing//! This function returns either the unmodified CRC result or the//! \b CRC_CFG_SIZE_32BIT.//! data size options \b CRC_CFG_SIZE_8BIT and//! of bytes or an array or words depending on the selection of the input//! The data in the array pointed to be \e pui32DataIn is either an array//! This function processes an array of data to produce a CRC result.//! to read the unmodified result.//! \param bPPResult is \b true to read the post-processed result, or \b false//! to produce the CRC.//! \param ui32DataLength is the number of data items that are processed//! \param pui32DataIn is a pointer to an array of data that is processed.//! \param ui32Base is the base address of the EC module.//! Process data to generate a CRC with the EC module.// return value.// Depending on the value of bPPResult, read the appropriate register and//! parameters in the CRCConfigSet() function.//! are selectable through \b CRC_CFG_RESINV and \b CRC_CFG_OBR//! processed CRC result from the EC module.  The post-processing options//! This function reads either the unmodified CRC result or the post//! Reads the result of a CRC operation in the EC module.// Write the data//! example, when writing 0xAB, \e ui32Data should be 0x000000AB.//! byte position.  The remaining bytes should be written with zero.  For//! When writing 8 bits of data, ensure the data is in the least significant//! is set using the CRCConfigSet() function.//! when the \b CRC_CFG_SIZE_8BIT or \b CRC_CFG_SIZE_32BIT flag//! CRC operations.  The distinction between 8 and 32 bits of data is made//! This function writes either 8 or 32 bits of data into the EC module for//! \param ui32Data is the data to be written.//! Write data into the EC module for CRC operations.// Write the seed value to the seed register.//! set with the CRCConfigSet() function.//! \note The seed must be written only if \b CRC_CFG_INIT_SEED is//! is used as the starting value.//! value is not written, then the residual seed from the previous operation//! EC module.  This value is the start value for CRC operations.  If this//! This function writes the seed value for use with CRC operations in the//! \param ui32Seed is the seed value.//! Write the seed value for CRC operations in the EC module.// Write the control register with the configuration.//! - \b CRC_CFG_TYPE_TCPCHKSUM - TCP checksum//! - \b CRC_CFG_TYPE_P1EDC6F41 - Polynomial 0x1EDC6F41//! - \b CRC_CFG_TYPE_P4C11DB7 - Polynomial 0x4C11DB7//! - \b CRC_CFG_TYPE_P1021 - Polynomial 0x1021//! - \b CRC_CFG_TYPE_P8005 - Polynomial 0x8005//! Operation Type//! - \b CRC_CFG_ENDIAN_SHW - Swap half-word//! - \b CRC_CFG_ENDIAN_SBHW - Swap byte in half-word//! Endian Control//! - \b CRC_CFG_IBR - Bit reverse enable//! Input Bit Reverse//! - \b CRC_CFG_OBR - Output reverse enable//! - \b CRC_CFG_RESINV - Result inverse enable//! Post Process Reverse/Inverse//! - \b CRC_CFG_SIZE_32BIT - Input data size of 32 bits//! - \b CRC_CFG_SIZE_8BIT - Input data size of 8 bits//! Input Data Size//! - \b CRC_CFG_INIT_1 - Initialize to all '1s'//! - \b CRC_CFG_INIT_0 - Initialize to all '0s'//! - \b CRC_CFG_INIT_SEED - Initialize with seed value//! CRC Initialization Value//! It is the logical OR of any of the following options://! module.  The configuration is specified with the \e ui32CRCConfig argument.//! This function configures the operation of the CRC engine within the EC//! \param ui32CRCConfig is the configuration of the CRC engine.//! Set the configuration of CRC functionality with the EC module.//! \addtogroup crc_api// crc.c - Driver for the CRC module./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/inc/hw_des.hDES_DMAIC_CINDES_DMAIC_DINDES_DMAIC_DOUTDES_DMAMIS_CINDES_DMAMIS_DINDES_DMAMIS_DOUTDES_DMARIS_CINDES_DMARIS_DINDES_DMARIS_DOUTDES_DMAIM_CINDES_DMAIM_DINDES_DMAIM_DOUTDES_DIRTYBITS_S_ACCESSDES_DIRTYBITS_S_DIRTYDES_IRQENABLE_M_CONTEX_INDES_IRQENABLE_M_DATA_INDES_IRQENABLE_M_DATA_OUTDES_IRQSTATUS_CONTEX_INDES_IRQSTATUS_DATA_INDES_IRQSTATUS_DATA_OUTDES_SYSSTATUS_RESETDONEDES_SYSCONFIG_SOFTRESETDES_SYSCONFIG_SIDLE_FORCEDES_SYSCONFIG_SIDLE_MDES_SYSCONFIG_DMA_REQ_DATA_IN_ENDES_SYSCONFIG_DMA_REQ_DATA_OUT_ENDES_SYSCONFIG_DMA_REQ_CONTEXT_IN_ENDES_REVISION_SDES_REVISION_MDES_DATA_H_SDES_DATA_H_MDES_DATA_L_SDES_DATA_L_MDES_LENGTH_SDES_LENGTH_MDES_CTRL_MODE_SDES_CTRL_OUTPUT_READYDES_CTRL_INPUT_READYDES_CTRL_DIRECTIONDES_CTRL_TDESDES_CTRL_MODE_MDES_CTRL_CONTEXTDES_IV_H_SDES_IV_H_MDES_IV_L_SDES_IV_L_MDES_KEY1_H_KEY_SDES_KEY1_H_KEY_MDES_KEY1_L_KEY_SDES_KEY1_L_KEY_MDES_KEY2_H_KEY_SDES_KEY2_H_KEY_MDES_KEY2_L_KEY_SDES_KEY2_L_KEY_MDES_KEY3_H_KEY_SDES_KEY3_H_KEY_MDES_KEY3_L_KEY_SDES_KEY3_L_KEY_MDES_O_DMAIC0xFFFF803CDES_O_DMAMIS0xFFFF8038DES_O_DMARIS0xFFFF8034DES_O_DMAIM0xFFFF8030DES_O_DIRTYBITSDES_O_IRQENABLEDES_O_IRQSTATUSDES_O_SYSSTATUSDES_O_SYSCONFIGDES_O_REVISIONDES_O_DATA_HDES_O_DATA_LDES_O_LENGTHDES_O_CTRLDES_O_IV_HDES_O_IV_LDES_O_KEY1_HDES_O_KEY1_LDES_O_KEY2_HDES_O_KEY2_LDES_O_KEY3_HDES_O_KEY3_L__HW_DES_H__// __HW_DES_H__// The following are defines for the bit fields in the DES_O_DMAIC register.// The following are defines for the bit fields in the DES_O_DMAMIS register.// The following are defines for the bit fields in the DES_O_DMARIS register.// The following are defines for the bit fields in the DES_O_DMAIM register.// registers is read// module if any of the DES_*// This bit is set to 1 by the// registers is written// The following are defines for the bit fields in the DES_O_DIRTYBITS// context interrupt is enabled// If this bit is set to 1 the// input interrupt is enabled// If this bit is set to 1 the data// output interrupt is enabled// The following are defines for the bit fields in the DES_O_IRQENABLE// the interrupt output// interrupt is active and triggers// This bit indicates context// This bit indicates data input// This bit indicates data output// The following are defines for the bit fields in the DES_O_IRQSTATUS// The following are defines for the bit fields in the DES_O_SYSSTATUS// Force-idle mode// Sidle mode// The following are defines for the bit fields in the DES_O_SYSCONFIG// The following are defines for the bit fields in the DES_O_REVISION register.// MSW// Data for encryption/decryption,// The following are defines for the bit fields in the DES_O_DATA_H register.// LSW// The following are defines for the bit fields in the DES_O_DATA_L register.// bytes for all modes// Cryptographic data length in// The following are defines for the bit fields in the DES_O_LENGTH register.// ready// When 1, Data decrypted/encrypted// data// When 1, ready to encrypt/decrypt// Encryption is selected// 0x0: decryption is selected0x1:// Select encryption/decryption// encryption/decryption// Select DES or triple DES// mode0x3: reserved// ECB mode0x1: CBC mode0x2: CFB// Select CBC, ECB or CFB mode0x0:// the next context// the host is permitted to write// registers can be overwritten and// indicates that the context data// If 1, this read-only status bit// The following are defines for the bit fields in the DES_O_CTRL register.// CFB modes (MSW)// Initialization vector for CBC,// The following are defines for the bit fields in the DES_O_IV_H register.// CFB modes (LSW)// The following are defines for the bit fields in the DES_O_IV_L register.// The following are defines for the bit fields in the DES_O_KEY1_H register.// The following are defines for the bit fields in the DES_O_KEY1_L register.// The following are defines for the bit fields in the DES_O_KEY2_H register.// The following are defines for the bit fields in the DES_O_KEY2_L register.// The following are defines for the bit fields in the DES_O_KEY3_H register.// The following are defines for the bit fields in the DES_O_KEY3_L register.// DES DMA Interrupt Clear// DES DMA Masked Interrupt Status// DES DMA Raw Interrupt Status// DES DMA Interrupt Mask// DES Dirty Bits// DES Interrupt Enable// DES Interrupt Status// DES System Status// DES System Configuration// DES Revision Number// DES MSW Data RW// DES LSW Data RW// DES Cryptographic Data Length// DES Control// DES Initialization Vector// DES Key 1 MSW for 64-Bit Key// DES Key 1 LSW for 64-Bit Key// DES Key 2 MSW for 128-Bit Key// DES Key 2 LSW for 128-Bit Key// DES Key 3 MSW for 192-Bit Key// DES Key 3 LSW for 192-Bit Key// The following are defines for the DES register offsets.// hw_des.h - Macros used when accessing the DES hardware./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/des.hDES_DMA_DATA_INDES_DMA_DATA_OUTDES_DMA_CONTEXT_INDES_INT_DMA_DATA_OUTDES_INT_DMA_DATA_INDES_INT_DMA_CONTEXT_INDES_INT_DATA_OUTDES_INT_DATA_INDES_INT_CONTEXT_INDES_CFG_TRIPLEDES_CFG_SINGLEDES_CFG_MODE_CFBDES_CFG_MODE_CBCDES_CFG_MODE_ECBDES_CFG_DIR_ENCRYPTDES_CFG_DIR_DECRYPT__DRIVERLIB_DES_H__DESResetDESLengthSetDESKeySetDESIVSetDESIntUnregisterDESIntStatusDESIntRegisterDESIntEnableDESIntDisableDESIntClearDESDMAEnableDESDMADisableDESDataWriteNonBlockingDESDataWriteDESDataProcessDESDataReadNonBlockingDESDataReadDESConfigSet// __DRIVERLIB_DES_H__// functions.// The following defines are used with the DESEnableDMA() and DESDisableDMA()// DESIntStatus() functions.// The following defines are used with the DESIntEnable(), DESIntDisable() and// permitted.// with the ui32Config argument in the DESConfig() function.  Only one is// The following defines are used to select between single DES and triple DES// ui32Config argument in the DESConfig() function.  Only one is permitted.// The following defines are used to specify the operational with the// The following defines are used to specify the direction with the// des.h - Defines and Macros for the DES module./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/des.c"driverlib/des.h""inc/hw_des.h"ui32Base + DES_O_SYSCONFIGui32Base == DES_BASE(ui32Flags & DES_DMA_CONTEXT_IN) || (ui32Flags & DES_DMA_DATA_OUT) || (ui32Flags & DES_DMA_DATA_IN)ui32Base + DES_O_DMAICui32Base + 0xFFFF803C4294934588(ui32IntFlags & DES_INT_DMA_CONTEXT_IN) || (ui32IntFlags & DES_INT_DMA_DATA_IN) || (ui32IntFlags & DES_INT_DMA_DATA_OUT)ui32Base + DES_O_DMAIMui32Base + 0xFFFF80304294934576ui32Base + DES_O_IRQENABLE(ui32IntFlags & DES_INT_CONTEXT_IN) || (ui32IntFlags & DES_INT_DATA_IN) || (ui32IntFlags & DES_INT_DATA_OUT) || (ui32IntFlags & DES_INT_DMA_CONTEXT_IN) || (ui32IntFlags & DES_INT_DMA_DATA_IN) || (ui32IntFlags & DES_INT_DMA_DATA_OUT)ui32Base + DES_O_IRQSTATUSui32Base + DES_O_DMAMISui32Base + 0xFFFF8038ui32Base + DES_O_DMARISui32Base + 0xFFFF803442949345844294934580ui32Base + DES_O_LENGTHui32Base + DES_O_CTRL(ui32Length % 8) == 0DES_BASE + DES_O_DATA_L0x44038000 + 0x0000002811410800641141080104DES_BASE + DES_O_DATA_H0x44038000 + 0x0000002C11410801082147483648ui32Base + DES_O_IV_Lui32Base + DES_O_IV_Hui32Base + DES_O_KEY1_Lui32Base + DES_O_KEY1_Hui32Base + DES_O_KEY2_Lui32Base + DES_O_KEY2_Hui32Base + DES_O_KEY3_Lui32Base + DES_O_KEY3_Hui32Base + DES_O_SYSSTATUS// Disable the DMA sources.//! - \b DES_DMA_DATA_IN - Data In//! - \b DES_DMA_DATA_OUT - Data Out//! - \b DES_DMA_CONTEXT_IN - Context In//! \e ui32Flags parameter should be the logical OR of any of the following://! This function disables DMA request sources in the DES module.  The//! \param ui32Flags is a bit mask of the DMA requests to be disabled.//! \param ui32Base is the base address of the DES module.//! Disables DMA request sources in the DES module.// Set the data in and data out DMA request enable bits.//! This function enables DMA request sources in the DES module.  The//! \param ui32Flags is a bit mask of the DMA requests to be enabled.//! Enables DMA request sources in the DES module.//! Unregisters an interrupt handler for the DES module.// Enable the interrupt.//! Instead, IntEnable() should be used to enable DES interrupts on the//! DESIntClear().//! interrupt sources must be enabled using DESIntEnable().  The interrupt//! table, and enables DES interrupts on the interrupt controller; specific DES//! enabled DES interrupts occur.//! Registers an interrupt handler for the DES module.//! The remaining interrupts can be disabled instead using DESIntDisable().//! - \b DES_INT_DMA_DATA_OUT - Data output interrupt//! - \b DES_INT_DMA_DATA_IN - Data input interrupt//! - \b DES_INT_DMA_CONTEXT_IN - Context interrupt//! values://! \e ui32IntFlags should be a logical OR of one or more of the following//! This function disables interrupt sources in the DES module.//! \param ui32IntFlags is a bit mask of the interrupts to be disabled.//! Clears interrupts in the DES module.// Clear the interrupts from the flags.//! - \b DES_INT_DMA_DATA_OUT - Data output DMA done interrupt//! - \b DES_INT_DMA_DATA_IN - Data input DMA done interrupt//! - \b DES_INT_DMA_CONTEXT_IN - Context DMA done interrupt//! - \b DES_INT_DATA_OUT - Data output interrupt//! - \b DES_INT_DATA_IN - Data input interrupt//! - \b DES_INT_CONTEXT_IN - Context interrupt//! Disables interrupts in the DES module.// Enable the interrupts from the flags.//! \param ui32IntFlags is a bit mask of the interrupts to be enabled.//! Enables interrupts in the DES module.// Read the status register and return the value.//! \return A bit mask of the current interrupt status.//! - \b DES_INT_DATA_OUT_INT - Data output interrupt//! The value returned is a logical OR of the following values://! This function gets the current interrupt status of the DES module.//! Returns the current interrupt status of the DES module.// Return true to indicate the process was successful.// Read the processed data block.// Wait for the output ready// Write the block data.// Check if the input ready is fine// Write the length register first.  This triggers the engine to start//! and initialization values and keys have been written.//! \note This functions assumes that the DES module has been configured,//! processed.  If processing is successful, the function returns true.//! pui32Dest array.  The function blocks until all of the data has been//! it using the DES engine.  The resulting data is stored in the//! This function takes the data contained in the pui32Src array and processes//! It must be a multiple of eight.//! processed data.//! \param pui32Dest is a pointer to an array of words consisting of the//! source data for processing.//! \param pui32Src is a pointer to an array of words that contains the//! Processes blocks of data through the DES module.// Write the data.// Wait for the input ready bit to go high.//! data contained in the pui32Src array.//! This function waits until the DES module is ready before writing the//! Writes plaintext/ciphertext to data registers without blocking// Return true to indicate a successful write.// is not, return false.// Check if the DES module is ready to encrypt or decrypt data.  If it//! data.  It returns true if the data was written successfully.//! This function returns false if the DES module is not ready to accept//! \param pui32Src is a pointer to an array of 2 words.// Read two words of data from the data registers.// Wait for data output to be ready.//! array.//! decrypted data is ready.  The output data is then stored in the pui32Dest//! This function waits until the DES module is finished and encrypted or//! \param pui32Dest is a pointer to an array of bytes.// Check to see if the data is ready to be read.//! called.  If the data was not ready, false is returned.//! This function returns true if the data was ready when the function was//! \param pui32Dest is a pointer to an array of 2 words.//! Reads plaintext/ciphertext from data registers without blocking// Write the length register.//! \note Data lengths up to (2^32 - 1) bytes are allowed.//! context.//! When this register is written, the engine is triggered to start using this//! This function writes the cryptographic data length into the DES module.//! \param ui32Length is the length of the data in bytes.//! Sets the crytographic data length in the DES module.// Return true to indicate the write was successful.// Write the initialization vector registers.// false.// Check to see if context registers can be overwritten.  If not, return//! cannot be written at the time the function was called, then false is//! true if the registers were successfully written.  If the context registers//! This function sets the initialization vector in the DES module.  It returns//! be written into the initialization vectors registers.//! \param pui32IVdata is a pointer to an array of 64 bits (2 words) of data to//! Sets the initialization vector in the DES module.// the second and third rounds.// If we are performing tripe DES, then write the key registers for// Write the first part of the key.//! 192 bits (6 words) if triple DES is being used.//! \e pui32Key should be 64 bits long (2 words) if single DES is being used or//! This function sets the key used for DES operations.//! \param pui32Key is a pointer to an array that holds the key//! Sets the key used for DES operations.// Write the control register.// Backup the save context field.//! - \b DES_CFG_TRIPLE - Triple DES//! - \b DES_CFG_SINGLE - Single DES//! following two flags.  Only one is permitted.//! The selection of single DES or triple DES is specified with one of the//! - \b DES_CFG_MODE_CFB - Cipher Feedback Mode//! - \b DES_CFG_MODE_CBC - Cipher-Block Chaining Mode//! - \b DES_CFG_MODE_ECB - Electronic Codebook Mode//! following flags.  Only one is permitted.//! The operational mode of the DES engine is specified with one of the//! - \b DES_CFG_DIR_DECRYPT - Decryption//! - \b DES_CFG_DIR_ENCRYPT - Encryption//! flags.  Only one is permitted.//! The direction of the operation is specified with one of the following two//! flags.  The valid flags are grouped below based on their function.//! The \e ui32Config parameter is a bit-wise OR of a number of configuration//! This function configures the DES module for operation.//! \param ui32Config is the configuration of the DES module.//! Configures the DES module for operation.// Trigger the soft reset.//! This function performs a soft-reset sequence of the DES module.//! Resets the DES Module.//! \addtogroup des_api// des.c - Driver for the DES data transformation./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/inc/hw_eeprom.hEEPROM_PP_SIZE_SEEPROM_PP_SIZE_6K0x000001FFEEPROM_PP_SIZE_5KEEPROM_PP_SIZE_4KEEPROM_PP_SIZE_3KEEPROM_PP_SIZE_2KEEPROM_PP_SIZE_1KEEPROM_PP_SIZE_512EEPROM_PP_SIZE_256EEPROM_PP_SIZE_128EEPROM_PP_SIZE_64EEPROM_PP_SIZE_MEEPROM_EEDBGME_KEY_SEEPROM_EEDBGME_KEY_MEEPROM_EEDBGME_MEEEPROM_EEHIDE2_HN_MEEPROM_EEHIDE1_HN_MEEPROM_EEHIDE_HN_M0xFFFFFFFEEEPROM_EEHIDE0_HN_MEEPROM_EEINT_INTEEPROM_EEPASS2_PASS_SEEPROM_EEPASS2_PASS_MEEPROM_EEPASS1_PASS_SEEPROM_EEPASS1_PASS_MEEPROM_EEPASS0_PASS_SEEPROM_EEPASS0_PASS_MEEPROM_EEPROT_ACCEEPROM_EEPROT_PROT_RONPWEEPROM_EEPROT_PROT_RWPWEEPROM_EEPROT_PROT_RWNPWEEPROM_EEPROT_PROT_MEEPROM_EEUNLOCK_UNLOCK_MEEPROM_EESUPP_PRETRYEEPROM_EESUPP_ERETRYEEPROM_EEDONE_WRBUSYEEPROM_EEDONE_NOPERMEEPROM_EEDONE_WKCOPYEEPROM_EEDONE_WKERASEEEPROM_EEDONE_WORKINGEEPROM_EERDWRINC_VALUE_SEEPROM_EERDWRINC_VALUE_MEEPROM_EERDWR_VALUE_SEEPROM_EERDWR_VALUE_MEEPROM_EEOFFSET_OFFSET_SEEPROM_EEOFFSET_OFFSET_MEEPROM_EEBLOCK_BLOCK_SEEPROM_EEBLOCK_BLOCK_MEEPROM_EESIZE_BLKCNT_SEEPROM_EESIZE_WORDCNT_SEEPROM_EESIZE_BLKCNT_M0x07FF0000EEPROM_EESIZE_WORDCNT_MEEPROM_PP0x400AFFC0EEPROM_EEDBGME0x400AF080EEPROM_EEHIDE20x400AF058EEPROM_EEHIDE10x400AF054EEPROM_EEHIDE0x400AF050EEPROM_EEHIDE0EEPROM_EEINT0x400AF040EEPROM_EEPASS20x400AF03CEEPROM_EEPASS10x400AF038EEPROM_EEPASS00x400AF034EEPROM_EEPROT0x400AF030EEPROM_EEUNLOCK0x400AF020EEPROM_EESUPP0x400AF01CEEPROM_EEDONE0x400AF018EEPROM_EERDWRINC0x400AF014EEPROM_EERDWR0x400AF010EEPROM_EEOFFSET0x400AF008EEPROM_EEBLOCK0x400AF004EEPROM_EESIZE0x400AF000__HW_EEPROM_H__// __HW_EEPROM_H__// 6 KB of EEPROM// 5 KB of EEPROM// 4 KB of EEPROM// 3 KB of EEPROM// 2 KB of EEPROM// 1 KB of EEPROM// 512 bytes of EEPROM// 256 bytes of EEPROM// 128 bytes of EEPROM// 64 bytes of EEPROM// EEPROM Size// The following are defines for the bit fields in the EEPROM_PP register.// Erase Key// Mass Erase// The following are defines for the bit fields in the EEPROM_EEDBGME register.// Hide Block// The following are defines for the bit fields in the EEPROM_EEHIDE2 register.// The following are defines for the bit fields in the EEPROM_EEHIDE1 register.// The following are defines for the bit fields in the EEPROM_EEHIDE register.// The following are defines for the bit fields in the EEPROM_EEHIDE0 register.// Interrupt Enable// The following are defines for the bit fields in the EEPROM_EEINT register.// Password// The following are defines for the bit fields in the EEPROM_EEPASS2 register.// The following are defines for the bit fields in the EEPROM_EEPASS1 register.// The following are defines for the bit fields in the EEPROM_EEPASS0 register.// Access Control// block is readable, not writable// If there is no password, the// only when unlocked// block is readable or writable// If there is a password, the// and writable// is not protected and is readable// there is no password, the block// This setting is the default. If// Protection Control// The following are defines for the bit fields in the EEPROM_EEPROT register.// EEPROM Unlock// The following are defines for the bit fields in the EEPROM_EEUNLOCK// Programming Must Be Retried// Erase Must Be Retried// The following are defines for the bit fields in the EEPROM_EESUPP register.// Write Busy// Write Without Permission// Working on a Copy// Working on an Erase// EEPROM Working// The following are defines for the bit fields in the EEPROM_EEDONE register.// Increment// EEPROM Read or Write Data with// The following are defines for the bit fields in the EEPROM_EERDWRINC// EEPROM Read or Write Data// The following are defines for the bit fields in the EEPROM_EERDWR register.// Current Address Offset// The following are defines for the bit fields in the EEPROM_EEOFFSET// Current Block// The following are defines for the bit fields in the EEPROM_EEBLOCK register.// Number of 16-Word Blocks// Number of 32-Bit Words// The following are defines for the bit fields in the EEPROM_EESIZE register.// EEPROM Peripheral Properties// EEPROM Debug Mass Erase// EEPROM Block Hide 2// EEPROM Block Hide 1// EEPROM Block Hide// EEPROM Block Hide 0// EEPROM Interrupt// EEPROM Password// EEPROM Protection// EEPROM Support Control and// EEPROM Done Status// EEPROM Read-Write with Increment// EEPROM Read-Write// EEPROM Current Offset// EEPROM Current Block// EEPROM Size Information// The following are defines for the EEPROM register offsets.// Copyright (c) 2011-2020 Texas Instruments Incorporated.  All rights reserved.// hw_eeprom.h - Macros used when accessing the EEPROM controller./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/inc/hw_flash.hFLASH_ERASE_SIZEFLASH_PROTECT_SIZEFLASH_FMPPE15_PROG_ENABLE_SFLASH_FMPPE15_PROG_ENABLE_MFLASH_FMPPE14_PROG_ENABLE_SFLASH_FMPPE14_PROG_ENABLE_MFLASH_FMPPE13_PROG_ENABLE_SFLASH_FMPPE13_PROG_ENABLE_MFLASH_FMPPE12_PROG_ENABLE_SFLASH_FMPPE12_PROG_ENABLE_MFLASH_FMPPE11_PROG_ENABLE_SFLASH_FMPPE11_PROG_ENABLE_MFLASH_FMPPE10_PROG_ENABLE_SFLASH_FMPPE10_PROG_ENABLE_MFLASH_FMPPE9_PROG_ENABLE_SFLASH_FMPPE9_PROG_ENABLE_MFLASH_FMPPE8_PROG_ENABLE_SFLASH_FMPPE8_PROG_ENABLE_MFLASH_FMPRE15_READ_ENABLE_SFLASH_FMPRE15_READ_ENABLE_MFLASH_FMPRE14_READ_ENABLE_SFLASH_FMPRE14_READ_ENABLE_MFLASH_FMPRE13_READ_ENABLE_SFLASH_FMPRE13_READ_ENABLE_MFLASH_FMPRE12_READ_ENABLE_SFLASH_FMPRE12_READ_ENABLE_MFLASH_FMPRE11_READ_ENABLE_SFLASH_FMPRE11_READ_ENABLE_MFLASH_FMPRE10_READ_ENABLE_SFLASH_FMPRE10_READ_ENABLE_MFLASH_FMPRE9_READ_ENABLE_SFLASH_FMPRE9_READ_ENABLE_MFLASH_FMPRE8_READ_ENABLE_SFLASH_FMPRE8_READ_ENABLE_MFLASH_USERREG3_DATA_SFLASH_USERREG3_DATA_MFLASH_USERREG2_DATA_SFLASH_USERREG2_DATA_MFLASH_USERREG1_DATA_SFLASH_USERREG1_DATA_MFLASH_USERREG0_DATA_SFLASH_USERREG0_DATA_MFLASH_BOOTCFG_DBG0FLASH_BOOTCFG_DBG1FLASH_BOOTCFG_KEYFLASH_BOOTCFG_ENFLASH_BOOTCFG_POLFLASH_BOOTCFG_PIN_7FLASH_BOOTCFG_PIN_6FLASH_BOOTCFG_PIN_5FLASH_BOOTCFG_PIN_4FLASH_BOOTCFG_PIN_3FLASH_BOOTCFG_PIN_2FLASH_BOOTCFG_PIN_1FLASH_BOOTCFG_PIN_0FLASH_BOOTCFG_PIN_MFLASH_BOOTCFG_PORT_HFLASH_BOOTCFG_PORT_GFLASH_BOOTCFG_PORT_FFLASH_BOOTCFG_PORT_EFLASH_BOOTCFG_PORT_DFLASH_BOOTCFG_PORT_CFLASH_BOOTCFG_PORT_BFLASH_BOOTCFG_PORT_AFLASH_BOOTCFG_PORT_MFLASH_BOOTCFG_NWFLASH_RMCTL_BAFLASH_RVP_RV_SFLASH_RVP_RV_MFLASH_DMAST_ADDR_SFLASH_DMAST_ADDR_M0x1FFFF800FLASH_DMASZ_SIZE_SFLASH_DMASZ_SIZE_M0x0003FFFFFLASH_ROMSWMAP_SW7EN_COREFLASH_ROMSWMAP_SW7EN_NOTVISFLASH_ROMSWMAP_SW7EN_MFLASH_ROMSWMAP_SW6EN_COREFLASH_ROMSWMAP_SW6EN_NOTVISFLASH_ROMSWMAP_SW6EN_MFLASH_ROMSWMAP_SW5EN_COREFLASH_ROMSWMAP_SW5EN_NOTVISFLASH_ROMSWMAP_SW5EN_MFLASH_ROMSWMAP_SW4EN_COREFLASH_ROMSWMAP_SW4EN_NOTVISFLASH_ROMSWMAP_SW4EN_MFLASH_ROMSWMAP_SW3EN_COREFLASH_ROMSWMAP_SW3EN_NOTVISFLASH_ROMSWMAP_SW3EN_MFLASH_ROMSWMAP_SW2EN_COREFLASH_ROMSWMAP_SW2EN_NOTVISFLASH_ROMSWMAP_SW2EN_MFLASH_ROMSWMAP_SW1EN_COREFLASH_ROMSWMAP_SW1EN_NOTVISFLASH_ROMSWMAP_SW1EN_MFLASH_ROMSWMAP_SW0EN_COREFLASH_ROMSWMAP_SW0EN_NOTVISFLASH_ROMSWMAP_SW0EN_MFLASH_ROMSWMAP_SAFERTOSFLASH_CONF_FPFOFFFLASH_CONF_FPFONFLASH_CONF_CLRTVFLASH_CONF_SPFEFLASH_CONF_FMMEFLASH_SSIZE_SIZE_256KBFLASH_SSIZE_SIZE_32KBFLASH_SSIZE_SIZE_24KBFLASH_SSIZE_SIZE_12KBFLASH_SSIZE_SIZE_MFLASH_FSIZE_SIZE_256KBFLASH_FSIZE_SIZE_128KBFLASH_FSIZE_SIZE_64KBFLASH_FSIZE_SIZE_32KBFLASH_FSIZE_SIZE_MFLASH_PP_SIZE_1MBFLASH_PP_SIZE_512KBFLASH_PP_SIZE_MFLASH_PP_MAINSS_16KBFLASH_PP_MAINSS_8KBFLASH_PP_MAINSS_4KBFLASH_PP_MAINSS_2KBFLASH_PP_MAINSS_1KBFLASH_PP_MAINSS_MFLASH_PP_EESS_8KBFLASH_PP_EESS_4KBFLASH_PP_EESS_2KBFLASH_PP_EESS_1KBFLASH_PP_EESS_M0x00780000FLASH_PP_DFAFLASH_PP_FMMFLASH_PP_PFCFLASH_FWBN_DATA_MFLASH_FLPEKEY_PEKEY_SFLASH_FLPEKEY_PEKEY_MFLASH_FWBVAL_FWB_MFLASH_FMC2_WRBUFFLASH_FMC2_WRKEY0xA4420000FLASH_FCMISC_AMISCFLASH_FCMISC_PMISCFLASH_FCMISC_EMISCFLASH_FCMISC_VOLTMISCFLASH_FCMISC_INVDMISCFLASH_FCMISC_ERMISCFLASH_FCMISC_PROGMISCFLASH_FCIM_AMASKFLASH_FCIM_PMASKFLASH_FCIM_EMASKFLASH_FCIM_VOLTMASKFLASH_FCIM_INVDMASKFLASH_FCIM_ERMASKFLASH_FCIM_PROGMASKFLASH_FCRIS_ARISFLASH_FCRIS_PRISFLASH_FCRIS_ERISFLASH_FCRIS_VOLTRISFLASH_FCRIS_INVDRISFLASH_FCRIS_ERRISFLASH_FCRIS_PROGRISFLASH_FMC_WRITEFLASH_FMC_ERASEFLASH_FMC_MERASEFLASH_FMC_COMTFLASH_FMC_WRKEYFLASH_FMD_DATA_SFLASH_FMD_DATA_MFLASH_FMA_OFFSET_SFLASH_FMA_OFFSET_M0x000FFFFFFLASH_FMPPE150x400FE43CFLASH_FMPPE140x400FE438FLASH_FMPPE130x400FE434FLASH_FMPPE120x400FE430FLASH_FMPPE110x400FE42CFLASH_FMPPE100x400FE428FLASH_FMPPE90x400FE424FLASH_FMPPE80x400FE420FLASH_FMPPE70x400FE41CFLASH_FMPPE60x400FE418FLASH_FMPPE50x400FE414FLASH_FMPPE40x400FE410FLASH_FMPPE30x400FE40CFLASH_FMPPE20x400FE408FLASH_FMPPE10x400FE404FLASH_FMPPE00x400FE400FLASH_FMPRE150x400FE23CFLASH_FMPRE140x400FE238FLASH_FMPRE130x400FE234FLASH_FMPRE120x400FE230FLASH_FMPRE110x400FE22CFLASH_FMPRE100x400FE228FLASH_FMPRE90x400FE224FLASH_FMPRE80x400FE220FLASH_FMPRE70x400FE21CFLASH_FMPRE60x400FE218FLASH_FMPRE50x400FE214FLASH_FMPRE40x400FE210FLASH_FMPRE30x400FE20CFLASH_FMPRE20x400FE208FLASH_FMPRE10x400FE204FLASH_FMPRE00x400FE200FLASH_USERREG30x400FE1ECFLASH_USERREG20x400FE1E8FLASH_USERREG10x400FE1E4FLASH_USERREG00x400FE1E0FLASH_BOOTCFG0x400FE1D0FLASH_RMCTL0x400FE0F0FLASH_RVP0x400FE0D4FLASH_DMAST0x400FDFD4FLASH_DMASZ0x400FDFD0FLASH_ROMSWMAP0x400FDFCCFLASH_CONF0x400FDFC8FLASH_SSIZE0x400FDFC4FLASH_FSIZE0x400FDFC0FLASH_PPFLASH_FWBN0x400FD100FLASH_FLPEKEY0x400FD03CFLASH_FWBVAL0x400FD030FLASH_FMC20x400FD020FLASH_FCMISC0x400FD014FLASH_FCIM0x400FD010FLASH_FCRIS0x400FD00CFLASH_FMC0x400FD008FLASH_FMD0x400FD004FLASH_FMA0x400FD000__HW_FLASH_H__// __HW_FLASH_H__// block that is protected by each protection register.// erased by an erase operation, and the protect size is the size of the FLASH// The following are defines for the erase size of the FLASH block that is// Flash Programming Enable// The following are defines for the bit fields in the FLASH_FMPPE15 register.// The following are defines for the bit fields in the FLASH_FMPPE14 register.// The following are defines for the bit fields in the FLASH_FMPPE13 register.// The following are defines for the bit fields in the FLASH_FMPPE12 register.// The following are defines for the bit fields in the FLASH_FMPPE11 register.// The following are defines for the bit fields in the FLASH_FMPPE10 register.// The following are defines for the bit fields in the FLASH_FMPPE9 register.// The following are defines for the bit fields in the FLASH_FMPPE8 register.// Flash Read Enable// The following are defines for the bit fields in the FLASH_FMPRE15 register.// The following are defines for the bit fields in the FLASH_FMPRE14 register.// The following are defines for the bit fields in the FLASH_FMPRE13 register.// The following are defines for the bit fields in the FLASH_FMPRE12 register.// The following are defines for the bit fields in the FLASH_FMPRE11 register.// The following are defines for the bit fields in the FLASH_FMPRE10 register.// The following are defines for the bit fields in the FLASH_FMPRE9 register.// The following are defines for the bit fields in the FLASH_FMPRE8 register.// User Data// The following are defines for the bit fields in the FLASH_USERREG3 register.// The following are defines for the bit fields in the FLASH_USERREG2 register.// The following are defines for the bit fields in the FLASH_USERREG1 register.// The following are defines for the bit fields in the FLASH_USERREG0 register.// Debug Control 0// Debug Control 1// KEY Select// Boot GPIO Enable// Boot GPIO Polarity// Pin 7// Pin 6// Pin 5// Pin 4// Pin 3// Pin 2// Pin 1// Pin 0// Boot GPIO Pin// Port H// Port G// Port F// Port E// Port D// Port C// Port B// Port A// Boot GPIO Port// Not Written// The following are defines for the bit fields in the FLASH_BOOTCFG register.// Boot Alias// The following are defines for the bit fields in the FLASH_RMCTL register.// Reset Vector Pointer Address// The following are defines for the bit fields in the FLASH_RVP register.// bit is set// uDMA if the FLASHPP register DFA// the flash region accessible by// Contains the starting address of// The following are defines for the bit fields in the FLASH_DMAST register.// uDMA-accessible Memory Size// The following are defines for the bit fields in the FLASH_DMASZ register.// Region available to core// the core// Software region not available to// ROM SW Region 7 Availability// ROM SW Region 6 Availability// ROM SW Region 5 Availability// ROM SW Region 4 Availability// ROM SW Region 3 Availability// ROM SW Region 2 Availability// ROM SW Region 1 Availability// ROM SW Region 0 Availability// SafeRTOS Present// The following are defines for the bit fields in the FLASH_ROMSWMAP register.// Force Prefetch Off// Force Prefetch On// Clear Valid Tags// Single Prefetch Mode Enable// Flash Mirror Mode Enable// The following are defines for the bit fields in the FLASH_CONF register.// 256 KB of SRAM// The following are defines for the bit fields in the FLASH_SSIZE register.// The following are defines for the bit fields in the FLASH_FSIZE register.// 1024 KB of Flash// 512 KB of Flash// 16 KB// 8 KB// 4 KB// 2 KB// 1 KB// physical bank// Flash Sector Size of the// EEPROM Sector Size of the// DMA Flash Access// Flash Mirror Mode// Prefetch Buffer Mode// The following are defines for the bit fields in the FLASH_PP register.// The following are defines for the bit fields in the FLASH_FWBN register.// Key Value// The following are defines for the bit fields in the FLASH_FLPEKEY register.// Flash Memory Write Buffer// The following are defines for the bit fields in the FLASH_FWBVAL register.// Buffered Flash Memory Write// FLASH write key// The following are defines for the bit fields in the FLASH_FMC2 register.// and Clear// Access Masked Interrupt Status// Programming Masked Interrupt// EEPROM Masked Interrupt Status// VOLT Masked Interrupt Status and// Invalid Data Masked Interrupt// ERVER Masked Interrupt Status// PROGVER Masked Interrupt Status// The following are defines for the bit fields in the FLASH_FCMISC register.// Access Interrupt Mask// Programming Interrupt Mask// EEPROM Interrupt Mask// VOLT Interrupt Mask// Invalid Data Interrupt Mask// ERVER Interrupt Mask// PROGVER Interrupt Mask// The following are defines for the bit fields in the FLASH_FCIM register.// Access Raw Interrupt Status// Programming Raw Interrupt Status// EEPROM Raw Interrupt Status// Pump Voltage Raw Interrupt// Invalid Data Raw Interrupt// Erase Verify Error Raw Interrupt// Program Verify Error Raw// The following are defines for the bit fields in the FLASH_FCRIS register.// Write a Word into Flash Memory// Erase a Page of Flash Memory// Mass Erase Flash Memory// Commit Register Value// The following are defines for the bit fields in the FLASH_FMC register.// Data Value// The following are defines for the bit fields in the FLASH_FMD register.// Address Offset// The following are defines for the bit fields in the FLASH_FMA register.// Enable 15// Flash Memory Protection Program// Enable 14// Enable 13// Enable 12// Enable 11// Enable 10// Enable 9// Enable 8// Enable 7// Enable 6// Enable 5// Enable 4// Enable 3// Enable 2// Enable 1// Enable 0// Flash Memory Protection Read// User Register 3// User Register 2// User Register 1// User Register 0// Boot Configuration// ROM Control// Reset Vector Pointer// Flash DMA Starting Address// Flash DMA Address Size// ROM Software Map// Flash Configuration Register// Flash Peripheral Properties// Flash Write Buffer n// Flash Program/Erase Key// Flash Write Buffer Valid// Flash Memory Control 2// Interrupt Status and Clear// Flash Controller Masked// Flash Controller Interrupt Mask// Flash Controller Raw Interrupt// Flash Memory Data// Flash Memory Address// The following are defines for the FLASH register offsets.// hw_flash.h - Macros used when accessing the flash controller./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/flash.hFlashIntClearFlashIntStatusFlashIntDisableFlashIntEnableFlashIntUnregisterFlashIntRegisterFlashAllUserRegisterSaveFlashUserSaveFlashAllUserRegisterSetFlashAllUserRegisterGetFlashUserSetFlashUserGetFlashProtectSaveFlashProtectSetFlashProtectGetFlashProgramFlashErasetFlashProtectionFlashReadWriteFlashReadOnlyFlashExecuteOnlyFLASH_INT_PROGRAM_ERRFLASH_INT_ERASE_ERRFLASH_INT_DATA_ERRFLASH_INT_VOLTAGE_ERRFLASH_INT_EEPROMFLASH_INT_ACCESSFLASH_INT_PROGRAM__DRIVERLIB_FLASH_H__// __DRIVERLIB_FLASH_H__// Program Verify Error Interrupt Mask// Erase Error Interrupt Mask// Voltage Error Interrupt Mask// returned from FlashIntStatus().// Values passed to FlashIntEnable(), FlashIntDisable() and FlashIntClear() and// Flash can only be executed// Flash can only be read// Flash can be read and written// FlashProtectGet().// Values that can be passed to FlashProtectSet(), and returned by// flash.h - Prototypes for the flash driver.ui32User0ui32User1ui32User2ui32User3pui32User0pui32User1pui32User2pui32User3ui32AddresseProtectpui32Data/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/sysctl.h/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/eeprom.h/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/eeprom.c"driverlib/eeprom.h""driverlib/sysctl.h""driverlib/flash.h""inc/hw_flash.h""inc/hw_eeprom.h"EEPROMStatusGet1074458648EEPROMIntClear107477813265280EEPROMIntStatusEEPROM_INT_PROGRAMEEPROMIntDisable10747781284294967291~FLASH_FCIM_EMASK1074458688~EEPROM_EEINT_INTui32IntFlags == EEPROM_INT_PROGRAMEEPROMIntEnableEEPROMBlockHide1074458704!ui32Blockui32Block < BLOCKS_FROM_EESIZE(HWREG(EEPROM_EESIZE))EEPROMBlockUnlock107445862810744586564294967295pui32Passwordui32Count <= 3EEPROMBlockLockEEPROMBlockPasswordSetui32Reg1074458676EEPROMBlockProtectSet1074458672EEPROMBlockProtectGetEEPROMMassErase1074458752582353816488960EEPROM_MASS_ERASE_KEY38164889614026554368SYSCTL_PERIPH_EEPROM0EEPROMProgramNonBlocking10744586321074458644ui32Address < SIZE_FROM_EESIZE(HWREG(EEPROM_EESIZE))(ui32Address & 3) == 0EEPROMProgramui32Blockui32Protect(ui32Address + ui32Count) <= SIZE_FROM_EESIZE(HWREG(EEPROM_EESIZE))(ui32Count & 3) == 0EEPROMReadEEPROMBlockCountGetHWREG(EEPROM_EESIZE)(*((volatile uint32_t *)(0x400AF000)))1074458624134152192EEPROMSizeGetEEPROMInit1074458652(EEPROM_EESUPP_PRETRY | EEPROM_EESUPP_ERETRY)EEPROM_INIT_ERROR(EEPROM_INIT_ERROR)EEPROM_INIT_OK(EEPROM_INIT_OK)_EEPROMWaitForDone_EEPROMSectorMaskClear0x400FD0FC10747783640x400AE2C01074455232_EEPROMSectorMaskSetui32Mask((uint32_t)0xE37B << EEPROM_EEDBGME_KEY_S)OFFSET_FROM_ADDR(x)(((x) >> 2) & 0x0F)SIZE_FROM_EESIZE(x)((((x) & EEPROM_EESIZE_WORDCNT_M) >> EEPROM_EESIZE_WORDCNT_S) * 4)BLOCKS_FROM_EESIZE(x)(((x) & EEPROM_EESIZE_BLKCNT_M) >> EEPROM_EESIZE_BLKCNT_S)EEPROM_SIZE_LIMIT//! EEPROM_RC_WORKING.//! EEPROM_RC_NOPERM, \b EEPROM_RC_WKCOPY, \b EEPROM_RC_WKERASE, and \b//! value is a logical OR combination of \b EEPROM_RC_WRBUSY, \b//! any errors.  If an operation is ongoing or an error occurred, the return//! \return Returns 0 if the last program or erase operation completed without//! options under interrupt control.//! information to applications programming or setting EEPROM protection//! operation performed by the EEPROM.  It is intended to provide error//! This function returns the current status of the last program or erase//! Returns status on the last EEPROM program or erase operation.// programming the main flash array later.// Clear the sector protection bits to prevent possible problems when// Clear the flash interrupt.//! This function allows an application to clear the EEPROM interrupt.//! the only valid value is \b EEPROM_INT_PROGRAM.//! \param ui32IntFlags indicates which interrupt sources to clear.  Currently,//! Clears the EEPROM interrupt.// make do with this instead.// EEPROM because it's handled via the flash controller so we have to// but we don't have access to an unmasked interrupt status for the// actual interrupt fires on the high to low transition of this bit// is pending if the WORKING bit of the EEDONE register is clear.  The// If asked for the unmasked interrupt status, infer that an interrupt// the appropriate EEPROM flag if it is.// relevant interrupt is pending in the flash controller then return// If asked for the masked interrupt status, we check to see if the//! 0 otherwise.//! \return Returns \b EEPROM_INT_PROGRAM if an interrupt is being signaled or//! EEPROMIntClear().//! interrupt.  If active, the interrupt may be cleared by calling//! This function allows an application to query the state of the EEPROM//! returned, otherwise the unmasked state is returned.//! interrupt is to be returned.  If bMasked is \b true, the masked state is//! \param bMasked determines whether the masked or unmasked state of the//! Reports the state of the EEPROM interrupt.// Disable interrupts from the EEPROM module.// Disable the EEPROM interrupt in the flash controller module.// Look for valid interrupt sources.//! passing FLASH_INT_EEPROM in the \e ui32IntFlags parameter.//! the EEPROM interrupt can also be disabled using a call to FlashIntDisable()//! subsystem, \b INT_FLASH.  This function is provided as a convenience but//! EEPROM peripheral shares a single interrupt vector with the flash memory//! interrupt vector when any EEPROM write or erase operation completes.  The//! This function disables the EEPROM interrupt and prevents calls to the//! This must be \b EEPROM_INT_PROGRAM currently.//! \param ui32IntFlags indicates which EEPROM interrupt source to disable.//! Disables the EEPROM interrupt.// Enable the EEPROM interrupt in the flash controller module.// Enable interrupts from the EEPROM module.//! the EEPROM interrupt can also be enabled using a call to FlashIntEnable()//! is generated when any EEPROM write or erase operation completes.  The//! This function enables the EEPROM interrupt.  When enabled, an interrupt//! \param ui32IntFlags indicates which EEPROM interrupt source to enable.//! Enables the EEPROM interrupt.// Hide the requested block.// Check parameters in a debug build.//! passwords which could be found through disassembly.//! application making using of block hiding need not contain any embedded//! from the rest of the application.  Unlike applications using passwords, an//! allows initialization code to have access to data which is to be hidden//! block is completely inaccessible until the next reset.  This mechanism//! This function hides an EEPROM block other than block 0.  Once hidden, a//! \param ui32Block is the EEPROM block number which is to be hidden.//! Hides an EEPROM block until the next reset.// Let the caller know if their password worked.// Write the supplied password to unlock the block.// compared to locking so start at the end of the array.// We need to write the password words in the opposite order when unlocking// unlock the block.// sequence just in case a short password was previously used to try to// Write the unlock register with 0xFFFFFFFF to reset the unlock// Set the block that we are trying to unlock.//! locked.//! \return Returns the lock state for the block on exit, 1 if unlocked or 0 if//! 0 is locked, all other EEPROM blocks are inaccessible.//! accessible according to their own access protection settings.  When block//! Unlocking block 0 has the effect of making all other blocks in the device//! an incorrect password is provided, the block remains locked.//! the password provided on the original call to EEPROMBlockPasswordSet().  If//! To successfully unlock an EEPROM block, the password provided must match//! EEPROMBlockProtectSet() function.//! by the protection settings applied via a previous call to the//! writing a password.  Access to the block once it is unlocked is determined//! This function unlocks an EEPROM block that has previously been protected by//! EEPROMBlockPasswordSet().  Valid values are 1, 2 and 3.//! array and must match the value originally passed to//! \param ui32Count provides the number of elements in the \e pui32Password//! originally set via a call to EEPROMBlockPasswordSet().//! the password for the block.  Each element must match the password//! \param pui32Password points to an array of uint32_t values containing//! \param ui32Block is the EEPROM block number which is to be unlocked.//! Unlocks a password-protected EEPROM block.// Return the current lock state.// Lock the block.// Select the block we are going to lock.//! would be the case if no password was set) or 0 if locked.//! \return Returns the lock state for the block on exit, 1 if unlocked (as//! inaccessible.//! Locking block 0 has the effect of making all other blocks in the EEPROM//! for the block, this function has no effect.//! EEPROMBlockProtectSet() function.  If no password has previously been set//! writing a password.  Access to the block once it is locked is determined//! This function locks an EEPROM block that has previously been protected by//! \param ui32Block is the EEPROM block number which is to be locked.//! Locks a password-protected EEPROM block.// Return the final write status.// Still working.// Wait for the last word write to complete or an error to be reported.// Update values in preparation for writing the next word.// Start the process of writing the password.// Write the password.// Start with the first password word.// Set the block number whose password we are about to write.//! EEPROM_RC_WORKING to indicate status and error conditions.//! \return Returns a logical OR combination of \b EEPROM_RC_WRBUSY, \b//! protection set for that block via a call to EEPROMBlockProtectSet().//! become accessible according to any passwords set on those blocks and the//! until block 0 is unlocked.  Once block 0 is unlocked, other blocks//! a whole.  When block 0 is locked, all other EEPROM blocks are inaccessible//! If a password is set on block 0, this affects locking of the peripheral as//! called for that block or block 0, or a reset occurs.//! password is set, the block remains unlocked until EEPROMBlockLock() is//! Any further attempts to set the password result in an error.  Once the//! with any value other than 0xFFFFFFFF.  The password may only be set once.//! set.  Valid passwords may be either 32, 64 or 96 bits comprising words//! This function allows the password used to unlock an EEPROM block to be//! Valid values are 1, 2 and 3.//! \param ui32Count provides the number of uint32_ts in the \e ui32Password.//! \e ui32Count parameter.//! 0xFFFFFFFF.  This array must contain the number of elements given by the//! the password to set.  Each element may be any 32-bit value other than//! \param pui32Password points to an array of uint32_t values comprising//! \param ui32Block is the EEPROM block number for which the password is to be//! Sets the password used to protect an EEPROM block.// Pass any error codes back to the caller.// Wait for the write to complete.// Set the protection options for this block.// Set the current block.// Parameter validity check.//! password protected and locked, neither read nor write access is permitted.//! is set or if a password is set and the block is unlocked.  If the block is//! \b EEPROM_PROT_RO_LNA_URO provides read access to the block if no password//! both read and write access are permitted.//! a password is set and the block is unlocked.  If the block is unlocked,//! \b EEPROM_PROT_NA_LNA_URW provides neither read nor write access unless//! block is locked, only read access is permitted.//! password is set or if a password is set and the block is unlocked.  If the//! \b EEPROM_PROT_RW_LRO_URW provides read/write access to the block if no//! can access the block.//! running in supervisor mode.  If clear, both user and supervisor threads//! \b EEPROM_PROT_SUPERVISOR_ONLY restricts access to the block to threads//! The protection flags indicate access permissions as follow://! basis.//! 0 and more restrictive protection settings to be set on a block-by-block//! allows global protection options to be set for the whole device via block//! protection flags set for block 0 and for the target block.  This protocol//! such that the effective protection on each block is the logical OR of the//! blocks numbered 1 and above are layered above any protection set on block 0//! access to the EEPROM peripheral as a whole.  Protection settings applied to//! protection settings applied to block 0 have special meaning and control//! assuming no protection settings have previously been written.  Note that//! This function sets the protection settings for a given EEPROM block//! \b EEPROM_PROT_SUPERVISOR_ONLY.//! \b EEPROM_PROT_NA_LNA_URW or \b EEPROM_PROT_RO_LNA_URO optionally ORed with//! \param ui32Protect consists of one of the values \b EEPROM_PROT_RW_LRO_URW,//! to be set.//! \param ui32Block is the block number for which the protection options are//! Set the current protection options for an EEPROM block.// Return the protection flags for this block.//! or \b EEPROM_PROT_RO_LNA_URO optionally OR-ed with//! \return Returns one of \b EEPROM_PROT_RW_LRO_URW, \b EEPROM_PROT_NA_LNA_URW//! to calling this function to query the protection setting for other blocks.//! EEPROM block.  If block 0 is currently locked, it must be unlocked prior//! This function returns the current protection settings for a given//! be queried.//! \param ui32Block is the block number for which the protection level is to//! Returns the current protection level for an EEPROM block.// Wait for completion again.// scrubbed.// mechanisms and passwords are reset now that the EEPROM data has been// Reset the peripheral.  This is required so that all protection// Wait for completion.// Start the mass erase processing// This is a workaround for a silicon problem on Blizzard rev A.//! \b EEPROM_RC_WKCOPY, \b EEPROM_RC_WKERASE, and \b EEPROM_RC_WORKING.//! are logical OR combinations of \b EEPROM_RC_WRBUSY, \b EEPROM_RC_NOPERM,//! \return Returns 0 on success or non-zero values on failure.  Failure codes//! has completed.//! The function is synchronous and does not return until the erase operation//! operations in all CPU modes.  No passwords are active.//! value 0xFFFFFFFF and all blocks are accessible for both read and write//! default condition.  After this operation, all EEPROM words contain the//! all access protection on its blocks, leaving the device in the factory//! This function completely erases the EEPROM and removes any and//! Erases the EEPROM and returns it to the factory default condition.// Return the current status to the caller.// the caller wants to write follow-on words using direct register access// Write the new word using the auto-incrementing register just in case// Set the block and offset appropriately to program the desired word.//! expected in normal operation and do not indicate an error.//! \b EEPROM_RC_WKCOPY, \b EEPROM_RC_WKERASE, and \b EEPROM_RC_WORKING are//! \b EEPROM_RC_WKCOPY, \b EEPROM_RC_WKERASE and \b EEPROM_RC_WORKING.  Flags//! combinations of \b EEPROM_RC_WRBUSY, \b EEPROM_RC_NOPERM,//! \return Returns status and error information in the form of a logical OR//! interrupt vector with the flash memory subsystem, \b INT_FLASH.//! interrupt from the EEPROM module.  The EEPROM peripheral shares a single//! complete.  Completion of the operation is signaled by means of an//! asynchronous and returns immediately without waiting for the write to//! data into the EEPROM at a given word-aligned address.  The call is//! control.  It may be called to start the process of writing a single word of//! This function is intended to allow EEPROM programming under interrupt//! data is to be written.  This value must be a multiple of 4.//! \param ui32Address defines the byte address within the EEPROM to which the//! \param ui32Data is the word to write to the EEPROM.//! Writes a word to the EEPROM.// fail.// next.  If a mass erase is requested instead, the mass erase will// register is written, the hardware expects a read or write operation// write the block register if we have more data to read.  If this// offset register has just wrapped back to 0.  Note that we only// Do we need to move to the next block?  This is the case if the// Move on to the next word.// being written correctly.// An error was reported that would prevent the values from// block resulting in only a section of the write not being performed.// must check this per-word because write permission can be set per// Make sure we completed the write without errors.  Note that we// Read the status.// loop before the bit is set.// immediately and this prevents us from dropping through the polling// Wait a few cycles.  In some cases, the WRBUSY bit is not set// Write the next word through the autoincrementing register.// have problems in multi-word writes that span multiple flash sectors.// need to do this before every word write to ensure that we don't// This is a workaround for a silicon problem on Blizzard rev A.  We// Write each word in turn.// Convert the byte count to a word count.// Set the block and offset appropriately to program the first word.// Make sure the EEPROM is idle before we start.//! all data has been written or an error occurs.//! word-aligned address.  The call is synchronous and returns only after//! This function may be called to write data into the EEPROM at a given//! This value must be a multiple of 4.//! \param ui32Count defines the number of bytes of data that is to be written.//! is to be written to.  This value must be a multiple of 4.//! \param ui32Address defines the byte address within the EEPROM that the data//! \param pui32Data points to the first word of data to write to the EEPROM.//! Writes data to the EEPROM.// Read the next word through the autoincrementing register.// Read each word in turn.// Set the block and offset appropriately to read the first word.//! buffer pointed to by the \e pui32Data parameter.//! word-aligned address within the EEPROM.  Data read is copied into the//! This function may be called to read a number of words of data from a//! \param ui32Count is the number of bytes of data to read from the EEPROM.//! to be read.  This value must be a multiple of 4.//! \param ui32Address is the byte address within the EEPROM from which data is//! This pointer must point to at least \e ui32Count bytes of available memory.//! \param pui32Data is a pointer to storage for the data read from the EEPROM.//! Reads data from the EEPROM.// Return the actual number of blocks supported by the hardware.// If a size limit has been specified, fake the number of blocks to match.// Extract the number of blocks and return it to the caller.//! \return Returns the total number of blocks in the device EEPROM.//! blocks returned by this function.//! obtained via a call to the EEPROMSizeGet() function, by the number of//! contained in a block may be determined by dividing the size of the device,//! EEPROM.  Each block is the same size and the number of bytes of storage//! This function may be called to determine the number of blocks in the//! Determines the number of blocks in the EEPROM.// Return the size of the EEPROM in bytes.//! \return Returns the total number of bytes in the EEPROM.//! This function returns the size of the EEPROM in bytes.//! Determines the size of the EEPROM.// The EEPROM does not indicate that any error occurred.// Was an error reported following the second reset?// Read EESUPP once again to determine if any error occurred.// Wait for the EEPROM to complete its reset processing once again.// Perform a second EEPROM reset.// Did an error of some sort occur during initialization?// Read the EESUPP register to see if any errors have been reported.// Make sure the EEPROM has finished any ongoing processing.// compiler with a ridiculously good optimizer!// that the first EEPROM register read will fault if you are using a// peripheral is enabled.  Without this delay, there is a slight chance// possibility that this function is called immediately after the EEPROM// Insert a small delay (6 cycles + call overhead) to guard against the//! an interrupted write or erase operation.//! EEPROM_INIT_ERROR if the EEPROM peripheral cannot currently recover from//! \return Returns \b EEPROM_INIT_OK if no errors were detected or \b//! or permanent data loss if the EEPROM is later written.//! Failure to call this function after a reset may lead to incorrect operation//! voltage is stabilized may clear the error.//! unstable when this return code is observed, retrying the operation once the//! specified lifetime write/erase specification.  If the supply voltage is//! error and is likely an indication that the EEPROM memory has exceeded its//! state.  If power is stable when this occurs, this indicates a fatal//! If \b EEPROM_INIT_ERROR is returned, the EEPROM was unable to recover its//! detects these errors and performs as much recovery as possible.//! such as from power failure during a previous write operation.  The function//! the EEPROM is accessed.  It is used to check for errors in the EEPROM state//! This function \b must be called after SysCtlPeripheralEnable() and before//! Performs any necessary recovery in case of power failures during write.// Spin while EEPROM is busy.// Is the EEPROM still busy?// Block until the EEPROM peripheral is not busy.// flash erase operations operate as expected.// Clear the FSM sector erase mask to ensure that any following main array// values for 32 consecutive EEPROM words (or 128 bytes).// is implemented in 16KB of flash with each 1KB sector of flash holding// Determine which page contains the passed EEPROM address.  The 2KB EEPROM// EEPROM write.// is erased if an erase/copy operation is required as a result of a following// It ensures that only the 1KB flash sector containing a given EEPROM address// This function implements a workaround for a bug in Blizzard rev A silicon.// The key value required to initiate a mass erase.// Useful macro to extract the offset from a linear address.// device and the total EEPROM storage in bytes from the EESIZE register.// Useful macros to extract the number of EEPROM blocks available on the target//! \addtogroup eeprom_api// Copyright (c) 2010-2020 Texas Instruments Incorporated.  All rights reserved.// eeprom.c - Driver for programming the on-chip EEPROM./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/inc/hw_emac.hEMAC_CC_CS_PA7EMAC_PPSCTRL_PPSCTRL_32768HZEMAC_PPSCTRL_PPSCTRL_16384HZEMAC_PPSCTRL_PPSCTRL_8192HZEMAC_PPSCTRL_PPSCTRL_4096HZEMAC_PPSCTRL_PPSCTRL_2048HZEMAC_PPSCTRL_PPSCTRL_1024HZEMAC_PPSCTRL_PPSCTRL_512HZEMAC_PPSCTRL_PPSCTRL_256HZEMAC_PPSCTRL_PPSCTRL_128HZEMAC_PPSCTRL_PPSCTRL_64HZEMAC_PPSCTRL_PPSCTRL_32HZEMAC_PPSCTRL_PPSCTRL_16HZEMAC_PPSCTRL_PPSCTRL_8HZEMAC_PPSCTRL_PPSCTRL_4HZEMAC_PPSCTRL_PPSCTRL_2HZEMAC_PPSCTRL_PPSCTRL_1HZEPHY_LEDCFG_LED0_LINKTXRXEPHY_LEDCFG_LED0_FDEPHY_LEDCFG_LED0_10BTEPHY_LEDCFG_LED0_100BTEPHY_LEDCFG_LED0_COLEPHY_LEDCFG_LED0_RXEPHY_LEDCFG_LED0_TXEPHY_LEDCFG_LED0_RXTXEPHY_LEDCFG_LED0_LINKEPHY_LEDCFG_LED0_MEPHY_LEDCFG_LED1_LINKTXRXEPHY_LEDCFG_LED1_FDEPHY_LEDCFG_LED1_10BTEPHY_LEDCFG_LED1_100BTEPHY_LEDCFG_LED1_COLEPHY_LEDCFG_LED1_RXEPHY_LEDCFG_LED1_TXEPHY_LEDCFG_LED1_RXTXEPHY_LEDCFG_LED1_LINKEPHY_LEDCFG_LED1_MEPHY_LEDCFG_LED2_LINKTXRXEPHY_LEDCFG_LED2_FDEPHY_LEDCFG_LED2_10BTEPHY_LEDCFG_LED2_100BTEPHY_LEDCFG_LED2_COLEPHY_LEDCFG_LED2_RXEPHY_LEDCFG_LED2_TXEPHY_LEDCFG_LED2_RXTXEPHY_LEDCFG_LED2_LINKEPHY_LEDCFG_LED2_MEPHY_RCR_SWRESTARTEPHY_RCR_SWRSTEPHY_CDCR_FAILEPHY_CDCR_DONEEPHY_CDCR_LINKQUAL_POOREPHY_CDCR_LINKQUAL_MILDEPHY_CDCR_LINKQUAL_GOODEPHY_CDCR_LINKQUAL_MEPHY_CDCR_STARTEPHY_BICSR2_PKTLENGTH_SEPHY_BICSR2_PKTLENGTH_M0x000007FFEPHY_BICSR1_IPGLENGTH_SEPHY_BICSR1_ERRCNT_SEPHY_BICSR1_IPGLENGTH_MEPHY_BICSR1_ERRCNT_MEPHY_10BTSC_SQUELCH_SEPHY_10BTSC_JABBERDEPHY_10BTSC_POLSTATEPHY_10BTSC_NLPDISEPHY_10BTSC_SQUELCH_MEPHY_10BTSC_RXTHENEPHY_CTL_BYPLEDSTRCHEPHY_CTL_MIILNKSTATEPHY_CTL_PAUSETXEPHY_CTL_PAUSERXEPHY_CTL_FORCEMDIEPHY_CTL_AUTOMDIEPHY_LEDCR_BLINKRATE_2HZEPHY_LEDCR_BLINKRATE_5HZEPHY_LEDCR_BLINKRATE_10HZEPHY_LEDCR_BLINKRATE_20HZEPHY_LEDCR_BLINKRATE_MEPHY_BISTCR_LBMODE_FREVEPHY_BISTCR_LBMODE_NANAEPHY_BISTCR_LBMODE_NDIGEPHY_BISTCR_LBMODE_NPCSOUTEPHY_BISTCR_LBMODE_NPCSINEPHY_BISTCR_LBMODE_MEPHY_BISTCR_TXMIILBEPHY_BISTCR_PWRMODEEPHY_BISTCR_PKTGENSTATEPHY_BISTCR_PRBSCHKSYNCEPHY_BISTCR_PRBSCHKLKEPHY_BISTCR_PKTENEPHY_BISTCR_PRBSPKTEPHY_BISTCR_PRBSMEPHY_RXERCNT_RXERRCNT_SEPHY_RXERCNT_RXERRCNT_MEPHY_FCSCR_FCSCNT_SEPHY_FCSCR_FCSCNT_MEPHY_MISR2_JABBERENEPHY_MISR2_POLINTENEPHY_MISR2_SLEEPENEPHY_MISR2_MDICOENEPHY_MISR2_LBFIFOENEPHY_MISR2_PAGERXENEPHY_MISR2_ANERRENEPHY_MISR2_JABBEREPHY_MISR2_POLINTEPHY_MISR2_SLEEPEPHY_MISR2_MDICOEPHY_MISR2_LBFIFOEPHY_MISR2_PAGERXEPHY_MISR2_ANERREPHY_MISR1_RXHFENEPHY_MISR1_FCHFENEPHY_MISR1_ANCENEPHY_MISR1_DUPLEXMENEPHY_MISR1_SPEEDENEPHY_MISR1_LINKSTATENEPHY_MISR1_RXHFEPHY_MISR1_FCHFEPHY_MISR1_ANCEPHY_MISR1_DUPLEXMEPHY_MISR1_SPEEDEPHY_MISR1_LINKSTATEPHY_SCR_INTENEPHY_SCR_TINTEPHY_SCR_COLFDMEPHY_SCR_LBFIFO_8EPHY_SCR_LBFIFO_6EPHY_SCR_LBFIFO_5EPHY_SCR_LBFIFO_4EPHY_SCR_LBFIFO_MEPHY_SCR_SBPYASSEPHY_SCR_PSMODE_PASWOLEPHY_SCR_PSMODE_ACTWOLEPHY_SCR_PSMODE_LOWPWREPHY_SCR_PSMODE_NORMALEPHY_SCR_PSMODE_MEPHY_SCR_PSENEPHY_SCR_DISCLKEPHY_STS_LINKEPHY_STS_SPEEDEPHY_STS_DUPLEXEPHY_STS_MIILBEPHY_STS_ANSEPHY_STS_JDEPHY_STS_RFEPHY_STS_MIIREQEPHY_STS_PAGERXEPHY_STS_DLEPHY_STS_SDEPHY_STS_FCSLEPHY_STS_POLSTATEPHY_STS_RXLERREPHY_STS_MDIXMEPHY_ADDAR_ADDRDATA_SEPHY_ADDAR_ADDRDATA_MEPHY_REGCTL_DEVAD_SEPHY_REGCTL_DEVAD_MEPHY_REGCTL_FUNC_DATAPIWOEPHY_REGCTL_FUNC_DATAPIRWEPHY_REGCTL_FUNC_DATANIEPHY_REGCTL_FUNC_ADDREPHY_REGCTL_FUNC_MEPHY_CFG3_FLDWNM_SEPHY_CFG3_FLDWNM_MEPHY_CFG3_MDIMDIXSEPHY_CFG3_POLSWAPEPHY_CFG2_ODDNDETDISEPHY_CFG2_RXERRIDLEEPHY_CFG2_ISOMIILLEPHY_CFG2_ENLEDLINKEPHY_CFG2_EXTFDEPHY_CFG2_FLUPPDEPHY_CFG1_FRXDVDETEPHY_CFG1_FANSEL_BLT240EPHY_CFG1_FANSEL_BLT120EPHY_CFG1_FANSEL_BLT80EPHY_CFG1_FANSEL_MEPHY_CFG1_FASTANENEPHY_CFG1_RAMDIXEPHY_CFG1_FAMDIXEPHY_CFG1_LLREPHY_CFG1_TDRAREPHY_CFG1_DONEEPHY_ANLNPTR_CODE_SEPHY_ANLNPTR_CODE_MEPHY_ANLNPTR_TOGEPHY_ANLNPTR_ACK2EPHY_ANLNPTR_MPEPHY_ANLNPTR_ACKEPHY_ANLNPTR_NPEPHY_ANNPTR_CODE_SEPHY_ANNPTR_CODE_MEPHY_ANNPTR_TOGTXEPHY_ANNPTR_ACK2EPHY_ANNPTR_MPEPHY_ANNPTR_NPEPHY_ANER_LPANABLEEPHY_ANER_PAGERXEPHY_ANER_NPABLEEPHY_ANER_LPNPABLEEPHY_ANER_PDFEPHY_ANLPA_SELECT_SEPHY_ANLPA_SELECT_MEPHY_ANLPA_10BTEPHY_ANLPA_10BTFDEPHY_ANLPA_100BTXEPHY_ANLPA_100BTXFDEPHY_ANLPA_100BT4EPHY_ANLPA_PAUSEEPHY_ANLPA_ASMDUPEPHY_ANLPA_RFEPHY_ANLPA_ACKEPHY_ANLPA_NPEPHY_ANA_SELECT_SEPHY_ANA_SELECT_MEPHY_ANA_10BTEPHY_ANA_10BTFDEPHY_ANA_100BTXEPHY_ANA_100BTXFDEPHY_ANA_100BT4EPHY_ANA_PAUSEEPHY_ANA_ASMDUPEPHY_ANA_RFEPHY_ANA_NPEPHY_ID2_MDLREV_SEPHY_ID2_VNDRMDL_SEPHY_ID2_OUILSB_SEPHY_ID2_MDLREV_MEPHY_ID2_VNDRMDL_MEPHY_ID2_OUILSB_MEPHY_ID1_OUIMSB_SEPHY_ID1_OUIMSB_MEPHY_BMSR_EXTENEPHY_BMSR_JABBEREPHY_BMSR_LINKSTATEPHY_BMSR_ANENEPHY_BMSR_RFAULTEPHY_BMSR_ANCEPHY_BMSR_MFPRESUPEPHY_BMSR_10BTHDEPHY_BMSR_10BTFDEPHY_BMSR_100BTXHDEPHY_BMSR_100BTXFDEPHY_BMCR_COLLTSTEPHY_BMCR_DUPLEXMEPHY_BMCR_RESTARTANEPHY_BMCR_ISOLATEEPHY_BMCR_PWRDWNEPHY_BMCR_ANENEPHY_BMCR_SPEEDEPHY_BMCR_MIILOOPBKEPHY_BMCR_MIIRESETEPHY_LEDCFG0x00000025EPHY_RCREPHY_CDCREPHY_BICSR2EPHY_BICSR1EPHY_10BTSCEPHY_CTLEPHY_LEDCREPHY_BISTCREPHY_RXERCNTEPHY_FCSCREPHY_MISR2EPHY_MISR1EPHY_SCREPHY_STSEPHY_ADDAREPHY_REGCTLEPHY_CFG3EPHY_CFG2EPHY_CFG1EPHY_ANLNPTREPHY_ANNPTREPHY_ANEREPHY_ANLPAEPHY_ANAEPHY_ID2EPHY_ID1EPHY_BMSREPHY_BMCREMAC_EPHYMISC_INTEMAC_EPHYIM_INTEMAC_EPHYRIS_INTEMAC_CC_CLKENEMAC_CC_POLEMAC_CC_PTPCENEMAC_PC_FASTANSEL_SEMAC_PC_FASTLDMODE_SEMAC_PC_PHYHOLDEMAC_PC_ANMODE_100FDEMAC_PC_ANMODE_100HDEMAC_PC_ANMODE_10FDEMAC_PC_ANMODE_10HDEMAC_PC_ANMODE_MEMAC_PC_ANENEMAC_PC_FASTANSEL_MEMAC_PC_FASTANENEMAC_PC_EXTFDEMAC_PC_FASTLUPDEMAC_PC_FASTRXDVEMAC_PC_MDIXENEMAC_PC_FASTMDIXEMAC_PC_RBSTMDIXEMAC_PC_MDISWAPEMAC_PC_POLSWAPEMAC_PC_FASTLDMODE_M0x000F8000EMAC_PC_TDRRUNEMAC_PC_LRREMAC_PC_ISOMIILLEMAC_PC_RXERIDLEEMAC_PC_NIBDETDISEMAC_PC_DIGRESTARTEMAC_PC_PINTFS_RMIIEMAC_PC_PINTFS_IMIIEMAC_PC_PINTFS_MEMAC_PC_PHYEXTEMAC_PP_PHYTYPE_1EMAC_PP_PHYTYPE_NONEEMAC_PP_PHYTYPE_MEMAC_PP_MACTYPE_1EMAC_PP_MACTYPE_MEMAC_HOSRXBA_CURRXBUFA_SEMAC_HOSRXBA_CURRXBUFA_MEMAC_HOSTXBA_CURTXBUFA_SEMAC_HOSTXBA_CURTXBUFA_MEMAC_HOSRXDESC_CURRXDESC_SEMAC_HOSRXDESC_CURRXDESC_MEMAC_HOSTXDESC_CURTXDESC_SEMAC_HOSTXDESC_CURTXDESC_MEMAC_RXINTWDT_RIWT_SEMAC_RXINTWDT_RIWT_MEMAC_MFBOC_MISFRMCNT_SEMAC_MFBOC_OVFFRMCNT_SEMAC_MFBOC_MISFRMCNT_MEMAC_MFBOC_MISCNTOVFEMAC_MFBOC_OVFFRMCNT_M0x0FFE0000EMAC_MFBOC_OVFCNTOVFEMAC_DMAIM_TIEEMAC_DMAIM_TSEEMAC_DMAIM_TUEEMAC_DMAIM_TJEEMAC_DMAIM_OVEEMAC_DMAIM_UNEEMAC_DMAIM_RIEEMAC_DMAIM_RUEEMAC_DMAIM_RSEEMAC_DMAIM_RWEEMAC_DMAIM_ETEEMAC_DMAIM_FBEEMAC_DMAIM_EREEMAC_DMAIM_AIEEMAC_DMAIM_NIEEMAC_DMAOPMODE_SREMAC_DMAOPMODE_OSFEMAC_DMAOPMODE_RTC_128EMAC_DMAOPMODE_RTC_96EMAC_DMAOPMODE_RTC_32EMAC_DMAOPMODE_RTC_64EMAC_DMAOPMODE_RTC_MEMAC_DMAOPMODE_DGFEMAC_DMAOPMODE_FUFEMAC_DMAOPMODE_FEFEMAC_DMAOPMODE_STEMAC_DMAOPMODE_TTC_160x0001C000EMAC_DMAOPMODE_TTC_240x00018000EMAC_DMAOPMODE_TTC_320x00014000EMAC_DMAOPMODE_TTC_40EMAC_DMAOPMODE_TTC_256EMAC_DMAOPMODE_TTC_192EMAC_DMAOPMODE_TTC_128EMAC_DMAOPMODE_TTC_64EMAC_DMAOPMODE_TTC_MEMAC_DMAOPMODE_FTFEMAC_DMAOPMODE_TSFEMAC_DMAOPMODE_DFFEMAC_DMAOPMODE_RSFEMAC_DMAOPMODE_DTEMAC_DMARIS_TIEMAC_DMARIS_TPSEMAC_DMARIS_TUEMAC_DMARIS_TJTEMAC_DMARIS_OVFEMAC_DMARIS_UNFEMAC_DMARIS_RIEMAC_DMARIS_RUEMAC_DMARIS_RPSEMAC_DMARIS_RWTEMAC_DMARIS_ETIEMAC_DMARIS_FBIEMAC_DMARIS_ERIEMAC_DMARIS_AISEMAC_DMARIS_NISEMAC_DMARIS_RS_RUNTXDEMAC_DMARIS_RS_TSWSEMAC_DMARIS_RS_RUNCRDEMAC_DMARIS_RS_SUSPENDEMAC_DMARIS_RS_RUNRXDEMAC_DMARIS_RS_RUNRXTDEMAC_DMARIS_RS_STOPEMAC_DMARIS_RS_MEMAC_DMARIS_TS_RUNCTDEMAC_DMARIS_TS_SUSPENDEMAC_DMARIS_TS_TSTAMPEMAC_DMARIS_TS_RUNTXEMAC_DMARIS_TS_STATUSEMAC_DMARIS_TS_RUNTXTDEMAC_DMARIS_TS_STOPEMAC_DMARIS_TS_MEMAC_DMARIS_AE_TXDMADR0x03800000EMAC_DMARIS_AE_RXDMADREMAC_DMARIS_AE_TXDMADW0x02800000EMAC_DMARIS_AE_RXDMADWEMAC_DMARIS_AE_TXDMARDEMAC_DMARIS_AE_RXDMAWDEMAC_DMARIS_AE_MEMAC_DMARIS_MMCEMAC_DMARIS_PMTEMAC_DMARIS_TTEMAC_DMARIS_LPIEMAC_TXDLADDR_TXDLADDR_SEMAC_TXDLADDR_TXDLADDR_M0xFFFFFFFCEMAC_RXDLADDR_STRXLIST_SEMAC_RXDLADDR_STRXLIST_MEMAC_RXPOLLD_RPD_SEMAC_RXPOLLD_RPD_MEMAC_TXPOLLD_TPD_SEMAC_TXPOLLD_TPD_MEMAC_DMABUSMOD_DSL_SEMAC_DMABUSMOD_PBL_SEMAC_DMABUSMOD_PR_SEMAC_DMABUSMOD_RPBL_SEMAC_DMABUSMOD_SWREMAC_DMABUSMOD_DAEMAC_DMABUSMOD_DSL_MEMAC_DMABUSMOD_ATDSEMAC_DMABUSMOD_PBL_M0x00003F00EMAC_DMABUSMOD_PR_MEMAC_DMABUSMOD_FBEMAC_DMABUSMOD_RPBL_M0x007E0000EMAC_DMABUSMOD_USPEMAC_DMABUSMOD_8XPBLEMAC_DMABUSMOD_AALEMAC_DMABUSMOD_MBEMAC_DMABUSMOD_TXPREMAC_DMABUSMOD_RIBEMAC_PPS0WIDTH_SEMAC_PPS0WIDTH_MEMAC_PPS0INTVL_PPS0INT_SEMAC_PPS0INTVL_PPS0INT_MEMAC_PPSCTRL_PPSCTRL_MEMAC_PPSCTRL_PPSEN0EMAC_PPSCTRL_TRGMODS0_PPS0ONLYEMAC_PPSCTRL_TRGMODS0_INTPPS0EMAC_PPSCTRL_TRGMODS0_INTONLYEMAC_PPSCTRL_TRGMODS0_MEMAC_TIMSTAT_TSSOVFEMAC_TIMSTAT_TSTARGTEMAC_HWORDSEC_TSHWR_SEMAC_HWORDSEC_TSHWR_MEMAC_TARGNANO_TTSLO_SEMAC_TARGNANO_TTSLO_M0x7FFFFFFFEMAC_TARGNANO_TRGTBUSYEMAC_TARGSEC_TSTR_SEMAC_TARGSEC_TSTR_MEMAC_TIMADD_TSAR_SEMAC_TIMADD_TSAR_MEMAC_TIMNANOU_TSSS_SEMAC_TIMNANOU_TSSS_MEMAC_TIMNANOU_ADDSUBEMAC_TIMSECU_TSS_SEMAC_TIMSECU_TSS_MEMAC_TIMNANO_TSSS_SEMAC_TIMNANO_TSSS_MEMAC_TIMSEC_TSS_SEMAC_TIMSEC_TSS_MEMAC_SUBSECINC_SSINC_SEMAC_SUBSECINC_SSINC_MEMAC_TIMSTCTRL_SELPTP_SEMAC_TIMSTCTRL_TSENEMAC_TIMSTCTRL_TSFCUPDTEMAC_TIMSTCTRL_TSINITEMAC_TIMSTCTRL_TSUPDTEMAC_TIMSTCTRL_INTTRIGEMAC_TIMSTCTRL_ADDREGUPEMAC_TIMSTCTRL_ALLFEMAC_TIMSTCTRL_DGTLBINEMAC_TIMSTCTRL_PTPVER2EMAC_TIMSTCTRL_PTPETHEMAC_TIMSTCTRL_PTPIPV6EMAC_TIMSTCTRL_PTPIPV4EMAC_TIMSTCTRL_TSEVNTEMAC_TIMSTCTRL_TSMASTEMAC_TIMSTCTRL_SELPTP_MEMAC_TIMSTCTRL_PTPFLTREMAC_VLANHASH_VLHT_SEMAC_VLANHASH_VLHT_MEMAC_VLNINCREP_VLT_SEMAC_VLNINCREP_VLT_MEMAC_VLNINCREP_VLC_TAGREPEMAC_VLNINCREP_VLC_TAGINSEMAC_VLNINCREP_VLC_TAGDELEMAC_VLNINCREP_VLC_NONEEMAC_VLNINCREP_VLC_MEMAC_VLNINCREP_VLPEMAC_VLNINCREP_CSVLEMAC_RXCNTGUNI_RXUCASTG_SEMAC_RXCNTGUNI_RXUCASTG_MEMAC_RXCNTALGNERR_RXALGNERR_SEMAC_RXCNTALGNERR_RXALGNERR_MEMAC_RXCNTCRCERR_RXCRCERR_SEMAC_RXCNTCRCERR_RXCRCERR_MEMAC_RXCNTGB_RXFRMGB_SEMAC_RXCNTGB_RXFRMGB_MEMAC_TXOCTCNTG_TXOCTG_SEMAC_TXOCTCNTG_TXOCTG_MEMAC_TXCNTMCOL_TXMULTCOLG_SEMAC_TXCNTMCOL_TXMULTCOLG_MEMAC_TXCNTSCOL_TXSNGLCOLG_SEMAC_TXCNTSCOL_TXSNGLCOLG_MEMAC_TXCNTGB_TXFRMGB_SEMAC_TXCNTGB_TXFRMGB_MEMAC_MMCTXIM_GBFEMAC_MMCTXIM_SCOLLGFEMAC_MMCTXIM_MCOLLGFEMAC_MMCTXIM_OCTCNTEMAC_MMCRXIM_GBFEMAC_MMCRXIM_CRCERREMAC_MMCRXIM_ALGNERREMAC_MMCRXIM_UCGFEMAC_MMCTXRIS_GBFEMAC_MMCTXRIS_SCOLLGFEMAC_MMCTXRIS_MCOLLGFEMAC_MMCTXRIS_OCTCNTEMAC_MMCRXRIS_GBFEMAC_MMCRXRIS_CRCERREMAC_MMCRXRIS_ALGNERREMAC_MMCRXRIS_UCGFEMAC_MMCCTRL_CNTRSTEMAC_MMCCTRL_CNTSTPROEMAC_MMCCTRL_RSTONRDEMAC_MMCCTRL_CNTFREEZEMAC_MMCCTRL_CNTPRSTEMAC_MMCCTRL_CNTPRSTLVLEMAC_MMCCTRL_UCDBCEMAC_WDOGTO_WTO_SEMAC_WDOGTO_WTO_M0x00003FFFEMAC_WDOGTO_PWEEMAC_ADDR3L_ADDRLO_SEMAC_ADDR3L_ADDRLO_MEMAC_ADDR3H_ADDRHI_SEMAC_ADDR3H_MBC_SEMAC_ADDR3H_ADDRHI_MEMAC_ADDR3H_MBC_M0x3F000000EMAC_ADDR3H_SAEMAC_ADDR3H_AEEMAC_ADDR2L_ADDRLO_SEMAC_ADDR2L_ADDRLO_MEMAC_ADDR2H_ADDRHI_SEMAC_ADDR2H_MBC_SEMAC_ADDR2H_ADDRHI_MEMAC_ADDR2H_MBC_MEMAC_ADDR2H_SAEMAC_ADDR2H_AEEMAC_ADDR1L_ADDRLO_SEMAC_ADDR1L_ADDRLO_MEMAC_ADDR1H_ADDRHI_SEMAC_ADDR1H_MBC_SEMAC_ADDR1H_ADDRHI_MEMAC_ADDR1H_MBC_MEMAC_ADDR1H_SAEMAC_ADDR1H_AEEMAC_ADDR0L_ADDRLO_SEMAC_ADDR0L_ADDRLO_MEMAC_ADDR0H_ADDRHI_SEMAC_ADDR0H_ADDRHI_MEMAC_ADDR0H_AEEMAC_IM_PMTEMAC_IM_TSIEMAC_IM_LPIEMAC_RIS_PMTEMAC_RIS_MMCEMAC_RIS_MMCRXEMAC_RIS_MMCTXEMAC_RIS_TSEMAC_RIS_LPIEMAC_LPITIMERCTL_TWT_SEMAC_LPITIMERCTL_TWT_MEMAC_LPITIMERCTL_LST_SEMAC_LPITIMERCTL_LST_M0x03FF0000EMAC_LPICTLSTAT_TLPIENEMAC_LPICTLSTAT_TLPIEXEMAC_LPICTLSTAT_RLPIENEMAC_LPICTLSTAT_RLPIEXEMAC_LPICTLSTAT_TLPISTEMAC_LPICTLSTAT_RLPISTEMAC_LPICTLSTAT_LPIENEMAC_LPICTLSTAT_PLSEMAC_LPICTLSTAT_PLSENEMAC_LPICTLSTAT_LPITXAEMAC_PMTCTLSTAT_RWKPTR_SEMAC_PMTCTLSTAT_PWRDWNEMAC_PMTCTLSTAT_MGKPKTENEMAC_PMTCTLSTAT_WUPFRENEMAC_PMTCTLSTAT_MGKPRXEMAC_PMTCTLSTAT_WUPRXEMAC_PMTCTLSTAT_GLBLUCASTEMAC_PMTCTLSTAT_RWKPTR_M0x07000000EMAC_PMTCTLSTAT_WUPFRRSTEMAC_RWUFF_WAKEUPFIL_SEMAC_RWUFF_WAKEUPFIL_MEMAC_STATUS_RFCFC_SEMAC_STATUS_RPEEMAC_STATUS_RFCFC_MEMAC_STATUS_RWCEMAC_STATUS_RRC_FLUSHEMAC_STATUS_RRC_DATAEMAC_STATUS_RRC_STATUSEMAC_STATUS_RRC_IDLEEMAC_STATUS_RRC_MEMAC_STATUS_RXF_FULLEMAC_STATUS_RXF_ABOVEEMAC_STATUS_RXF_BELOWEMAC_STATUS_RXF_EMPTYEMAC_STATUS_RXF_MEMAC_STATUS_TPEEMAC_STATUS_TFC_INPUTEMAC_STATUS_TFC_PAUSEEMAC_STATUS_TFC_STATUSEMAC_STATUS_TFC_IDLEEMAC_STATUS_TFC_MEMAC_STATUS_TXPAUSEDEMAC_STATUS_TRC_WRFLUSHEMAC_STATUS_TRC_WAITEMAC_STATUS_TRC_READEMAC_STATUS_TRC_IDLEEMAC_STATUS_TRC_MEMAC_STATUS_TWCEMAC_STATUS_TXFEEMAC_STATUS_TXFFEMAC_VLANTG_VL_SEMAC_VLANTG_VL_MEMAC_VLANTG_ETVEMAC_VLANTG_VTIMEMAC_VLANTG_ESVLEMAC_VLANTG_VTHMEMAC_FLOWCTL_PT_SEMAC_FLOWCTL_FCBBPAEMAC_FLOWCTL_TFEEMAC_FLOWCTL_RFEEMAC_FLOWCTL_UPEMAC_FLOWCTL_DZQPEMAC_FLOWCTL_PT_MEMAC_MIIDATA_DATA_SEMAC_MIIDATA_DATA_MEMAC_MIIADDR_MII_SEMAC_MIIADDR_PLA_SEMAC_MIIADDR_MIIBEMAC_MIIADDR_MIIWEMAC_MIIADDR_CR_35_60EMAC_MIIADDR_CR_20_35EMAC_MIIADDR_CR_100_150EMAC_MIIADDR_CR_60_100EMAC_MIIADDR_CR_MEMAC_MIIADDR_MII_MEMAC_MIIADDR_PLA_M0x0000F800EMAC_HASHTBLL_HTL_SEMAC_HASHTBLL_HTL_MEMAC_HASHTBLH_HTH_SEMAC_HASHTBLH_HTH_MEMAC_FRAMEFLTR_PREMAC_FRAMEFLTR_HUCEMAC_FRAMEFLTR_HMCEMAC_FRAMEFLTR_DAIFEMAC_FRAMEFLTR_PMEMAC_FRAMEFLTR_DBFEMAC_FRAMEFLTR_PCF_ADDREMAC_FRAMEFLTR_PCF_NONEEMAC_FRAMEFLTR_PCF_PAUSEEMAC_FRAMEFLTR_PCF_ALLEMAC_FRAMEFLTR_PCF_MEMAC_FRAMEFLTR_SAIFEMAC_FRAMEFLTR_SAFEMAC_FRAMEFLTR_HPFEMAC_FRAMEFLTR_VTFEEMAC_FRAMEFLTR_RAEMAC_CFG_PRELEN_3EMAC_CFG_PRELEN_5EMAC_CFG_PRELEN_7EMAC_CFG_PRELEN_MEMAC_CFG_REEMAC_CFG_TEEMAC_CFG_DCEMAC_CFG_BL_2EMAC_CFG_BL_8EMAC_CFG_BL_256EMAC_CFG_BL_1024EMAC_CFG_BL_MEMAC_CFG_ACSEMAC_CFG_DREMAC_CFG_IPCEMAC_CFG_DUPMEMAC_CFG_LOOPBMEMAC_CFG_DROEMAC_CFG_FESEMAC_CFG_PSEMAC_CFG_DISCRSEMAC_CFG_IFG_40EMAC_CFG_IFG_48EMAC_CFG_IFG_56EMAC_CFG_IFG_64EMAC_CFG_IFG_72EMAC_CFG_IFG_80EMAC_CFG_IFG_88EMAC_CFG_IFG_96EMAC_CFG_IFG_MEMAC_CFG_JFENEMAC_CFG_JDEMAC_CFG_WDDISEMAC_CFG_CSTEMAC_CFG_TWOKPENEMAC_O_EPHYMISC0x00000FD8EMAC_O_EPHYIM0x00000FD4EMAC_O_EPHYRIS0x00000FD0EMAC_O_CCEMAC_O_PCEMAC_O_PPEMAC_O_HOSRXBA0x00000C54EMAC_O_HOSTXBA0x00000C50EMAC_O_HOSRXDESC0x00000C4CEMAC_O_HOSTXDESC0x00000C48EMAC_O_RXINTWDT0x00000C24EMAC_O_MFBOC0x00000C20EMAC_O_DMAIM0x00000C1CEMAC_O_DMAOPMODE0x00000C18EMAC_O_DMARIS0x00000C14EMAC_O_TXDLADDR0x00000C10EMAC_O_RXDLADDR0x00000C0CEMAC_O_RXPOLLD0x00000C08EMAC_O_TXPOLLD0x00000C04EMAC_O_DMABUSMODEMAC_O_PPS0WIDTH0x00000764EMAC_O_PPS0INTVL0x00000760EMAC_O_PPSCTRL0x0000072CEMAC_O_TIMSTAT0x00000728EMAC_O_HWORDSEC0x00000724EMAC_O_TARGNANO0x00000720EMAC_O_TARGSEC0x0000071CEMAC_O_TIMADD0x00000718EMAC_O_TIMNANOU0x00000714EMAC_O_TIMSECU0x00000710EMAC_O_TIMNANO0x0000070CEMAC_O_TIMSEC0x00000708EMAC_O_SUBSECINC0x00000704EMAC_O_TIMSTCTRLEMAC_O_VLANHASH0x00000588EMAC_O_VLNINCREP0x00000584EMAC_O_RXCNTGUNI0x000001C4EMAC_O_RXCNTALGNERR0x00000198EMAC_O_RXCNTCRCERR0x00000194EMAC_O_RXCNTGBEMAC_O_TXOCTCNTGEMAC_O_TXCNTMCOL0x00000150EMAC_O_TXCNTSCOL0x0000014CEMAC_O_TXCNTGB0x00000118EMAC_O_MMCTXIM0x00000110EMAC_O_MMCRXIM0x0000010CEMAC_O_MMCTXRIS0x00000108EMAC_O_MMCRXRISEMAC_O_MMCCTRLEMAC_O_WDOGTO0x000000DCEMAC_O_ADDR3LEMAC_O_ADDR3HEMAC_O_ADDR2LEMAC_O_ADDR2HEMAC_O_ADDR1LEMAC_O_ADDR1HEMAC_O_ADDR0LEMAC_O_ADDR0HEMAC_O_IMEMAC_O_RISEMAC_O_LPITIMERCTLEMAC_O_LPICTLSTATEMAC_O_PMTCTLSTATEMAC_O_RWUFFEMAC_O_STATUSEMAC_O_VLANTGEMAC_O_FLOWCTLEMAC_O_MIIDATAEMAC_O_MIIADDREMAC_O_HASHTBLLEMAC_O_HASHTBLHEMAC_O_FRAMEFLTREMAC_O_CFG__HW_EMAC_H__// __HW_EMAC_H__// GPIO// The following are deprecated defines for the bit fields in the EMAC_O_CC// 16.384 KHz// and the digital rollover is// binary rollover is 32.768 KHz,// When thePPSEN0 bit = 0x0, the// 8.092 kHz// binary rollover is 16.384 kHz,// 4.096 kHz// binary rollover is 8.192 kHz,// 2.048 kHz// binary rollover is 4.096 kHz,// 1.024 kHz// binary rollover is 2.048 kHz,// Hz// and the digital rollover is 512// binary rollover is 1.024 kHz,// When the PPSEN0 bit = 0x0, the// the digital rollover is 256 Hz// binary rollover is 512 Hz, and// the digital rollover is 128 Hz// binary rollover is 256 Hz, and// the digital rollover is 64 Hz// binary rollover is 128 Hz, and// the digital rollover is 32 Hz// binary rollover is 64 Hz, and// the digital rollover is 16 Hz// binary rollover is 32 Hz, and// the digital rollover is 8 Hz// binary rollover is 16 Hz, and// digital rollover is 4 Hz,// binary rollover is 8 Hz, and the// digital rollover is 2 Hz// binary rollover is 4 Hz, and the// digital rollover is 1 Hz// binary rollover is 2 Hz, and the// clk_ptp_i) every second// PTP reference clock.(of width// EN0PPS signal is 1 pulse of the// EMAC_O_PPSCTRL register.// The following are deprecated defines for the bit fields in the// Link OK/Blink on TX/RX Activity// Full Duplex// 10-Base TX// 100-Base TX// Collision// RX Activity// TX Activity// RX/TX Activity// Link OK// LED0 Configuration// LED1 Configuration// LED2 Configuration// The following are defines for the bit fields in the EPHY_LEDCFG register.// Software Restart// The following are defines for the bit fields in the EPHY_RCR register.// Cable Diagnostic Process Fail// Cable Diagnostic Process Done// Poor Quality Link Indication// Mid- Quality Link Indication// Good Quality Link Indication// Link Quality Indication// Cable Diagnostic Process Start// The following are defines for the bit fields in the EPHY_CDCR register.// BIST Packet Length// The following are defines for the bit fields in the EPHY_BICSR2 register.// BIST IPG Length// BIST Error Count// The following are defines for the bit fields in the EPHY_BICSR1 register.// Jabber Disable// 10 Mb Polarity Status// Transmission Control// Normal Link Pulse (NLP)// Squelch Configuration// Lower Receiver Threshold Enable// The following are defines for the bit fields in the EPHY_10BTSC register.// Bypass LED Stretching// MII Link Status// Pause Transmit Negotiated Status// Pause Receive Negotiated Status// Force MDIX// Auto-MDIX Enable// The following are defines for the bit fields in the EPHY_CTL register.// 2 Hz (500 ms)// 5 Hz (200 ms)// 10 Hz (100 ms)// 20 Hz (50 ms)// duration):// LED Blinking Rate (ON/OFF// The following are defines for the bit fields in the EPHY_LEDCR register.// Loopback// Far-end Loopback: Reverse// termination)// Loopback (requires 100 Ohm// Near-end loopback: Analog// Near-end loopback: Digital// Loopback (In 100Base-TX only)// Near-end loopback: PCS Output// Near-end loopback: PCS Input// Loopback Mode Select// Mode// Transmit Data in MII Loopback// Power Mode Indication// Indication// Packet Generator Status// PRBS Checker Lock Sync Loss// PRBS Checker Lock Indication// Packet Generation Enable// Generated PRBS Packets// PRBS Single/Continuous Mode// The following are defines for the bit fields in the EPHY_BISTCR register.// Receive Error Count// The following are defines for the bit fields in the EPHY_RXERCNT register.// False Carrier Event Counter// The following are defines for the bit fields in the EPHY_FCSCR register.// Jabber Detect Event Interrupt// Polarity Changed Interrupt// Sleep Mode Event Interrupt// Changed Interrupt Enable// MDI/MDIX Crossover Status// Loopback FIFO Overflow/Underflow// Page Receive Interrupt Enable// Auto-Negotiation Error Interrupt// Changed Interrupt// Event Interrupt// Page Receive Interrupt// The following are defines for the bit fields in the EPHY_MISR2 register.// Half-Full Event Interrupt// Receive Error Counter Register// half-full Interrupt Enable// False Carrier Counter Register// Auto-Negotiation Complete// Duplex Status Interrupt Enable// Speed Change Interrupt Enable// Link Status Interrupt Enable// Interrupt// Receive Error Counter Half-Full// False Carrier Counter Half-Full// Change of Duplex Status// Change of Speed Status Interrupt// Change of Link Status Interrupt// The following are defines for the bit fields in the EPHY_MISR1 register.// Test Interrupt// Collision in Full-Duplex Mode// Eight nibble FIFO// Six nibble FIFO// Five nibble FIFO// Four nibble FIFO// Loopback FIFO Depth// Scrambler Bypass// Passive Sleep// Active Sleep// IEEE Power Down// PHY is fully functional// Normal: Normal operation mode.// Power Saving Modes// Power Saving Modes Enable// Disable CLK// The following are defines for the bit fields in the EPHY_SCR register.// Link Status// Speed Status// Duplex Status// MII Loopback Status// Auto-Negotiation Status// Jabber Detect// Remote Fault// MII Interrupt Pending// Link Code Page Received// Descrambler Lock// Signal Detect// False Carrier Sense Latch// Polarity Status// Receive Error Latch// MDI-X Mode// The following are defines for the bit fields in the EPHY_STS register.// Address or Data// The following are defines for the bit fields in the EPHY_ADDAR register.// Device Address// only// Data, post increment on write// write// Data, post increment on read and// Data, no post increment// Address// Function// The following are defines for the bit fields in the EPHY_REGCTL register.// Fast Link Down Modes// MDI/MDIX Swap// Polarity Swap// The following are defines for the bit fields in the EPHY_CFG3 register.// Detection of Transmit Error// Error During IDLE State// Detection of Receive Symbol// Enhanced Link is not Achievable// Isolate MII outputs when// Enhanced LED Functionality// Extended Full-Duplex Ability// Fast Link-Up in Parallel Detect// The following are defines for the bit fields in the EPHY_CFG2 register.// FAST RXDV Detection// Break Link Timer: 240 ms// Break Link Timer: 120 ms// Break Link Timer: 80 ms// Fast Auto-Negotiation Select// Fast Auto Negotiation Enable// Robust Auto MDI/MDIX// Fast Auto MDI/MDIX// Link Loss Recovery// TDR Auto-Run at Link Down// Configuration Done// The following are defines for the bit fields in the EPHY_CFG1 register.// Code// Toggle// Acknowledge 2// Message Page// Acknowledge// Next Page Indication// The following are defines for the bit fields in the EPHY_ANLNPTR register.// The following are defines for the bit fields in the EPHY_ANNPTR register.// Able// Link Partner Auto-Negotiation// Link Code Word Page Received// Next Page Able// Link Partner Next Page Able// Parallel Detection Fault// The following are defines for the bit fields in the EPHY_ANER register.// Protocol Selection// 10Base-T Support// 10Base-T Full Duplex Support// 100Base-TX Support// 100Base-TX Full Duplex Support// 100Base-T4 Support// PAUSE// Asymmetric PAUSE// The following are defines for the bit fields in the EPHY_ANLPA register.// Links// PAUSE Support for Full Duplex// Full Duplex Links// Asymmetric PAUSE support for// The following are defines for the bit fields in the EPHY_ANA register.// Model Revision Number// Vendor Model Number// OUI Least Significant Bits// The following are defines for the bit fields in the EPHY_ID2 register.// OUI Most Significant Bits// The following are defines for the bit fields in the EPHY_ID1 register.// Extended Capability Enable// Auto Negotiation Enabled// Preamble Suppression Capable// 10 Base-T Half Duplex Capable// 10 Base-T Full Duplex Capable// 100Base-TX Half Duplex Capable// 100Base-TX Full Duplex Capable// The following are defines for the bit fields in the EPHY_BMSR register.// Collision Test// Duplex Mode// Restart Auto-Negotiation// Port Isolate// Auto-Negotiate Enable// Speed Select// MII Loopback// MII Register reset// The following are defines for the bit fields in the EPHY_BMCR register.// Ethernet PHY LED Configuration// Ethernet PHY Reset Control// Ethernet PHY Cable Diagnostic// Status 2// Ethernet PHY BIST Control and// Status 1// Status/Control - MR26// Ethernet PHY 10Base-T// Ethernet PHY Control// Ethernet PHY LED Control// Ethernet PHY BIST Control// Ethernet PHY Receive Error Count// Counter// Ethernet PHY False Carrier Sense// Ethernet PHY MII Interrupt// Ethernet PHY Specific Control// Ethernet PHY Status// Ethernet PHY Address or Data// Ethernet PHY Register Control// Ethernet PHY Configuration 3// Ethernet PHY Configuration 2// Ethernet PHY Configuration 1// Link Partner Ability Next Page// Ethernet PHY Auto-Negotiation// Next Page TX// Expansion// Link Partner Ability// Advertisement// Ethernet PHY Identifier Register// Ethernet PHY Basic Mode Status// Ethernet PHY Basic Mode Control// The following are defines for the EPHY register offsets.// register// Ethernet PHY Status and Clear// The following are defines for the bit fields in the EMAC_O_EPHYMISC// Ethernet PHY Interrupt Mask// The following are defines for the bit fields in the EMAC_O_EPHYIM register.// Ethernet PHY Raw Interrupt// The following are defines for the bit fields in the EMAC_O_EPHYRIS register.// EN0RREF_CLK Signal Enable// LED Polarity Control// PTP Clock Reference Enable// The following are defines for the bit fields in the EMAC_O_CC register.// Ethernet PHY Hold// 100Base-TX, Full-Duplex// When ANEN = 0x0, the mode is// 100Base-TX, Half-Duplex// 10Base-T, Full-Duplex// 10Base-T, Half-Duplex// Auto Negotiation Mode// Auto Negotiation Enable// Fast Auto Negotiation Select// Extended Full Duplex Ability// FAST Link-Up in Parallel Detect// Fast RXDV Detection// MDIX Enable// Fast Auto MDI-X// Robust Auto MDI-X// MDI Swap// Fast Link Down Mode// TDR Auto Run// Isolate MII in Link Loss// RXER Detection During Idle// Disable// Odd Nibble TXER Detection// PHY Soft Restart// connected via RMII// RMII: Used for external PHY// via MII// PHY or external PHY connected// MII (default) Used for internal// Ethernet Interface Select// PHY Select// The following are defines for the bit fields in the EMAC_O_PC register.// Snowflake class PHY// No PHY// Ethernet PHY Type// Tiva TM4E129x-class MAC// Ethernet MAC Type// The following are defines for the bit fields in the EMAC_O_PP register.// Pointer// Host Receive Buffer Address// The following are defines for the bit fields in the EMAC_O_HOSRXBA register.// Host Transmit Buffer Address// The following are defines for the bit fields in the EMAC_O_HOSTXBA register.// Host Receive Descriptor Address// The following are defines for the bit fields in the EMAC_O_HOSRXDESC// Host Transmit Descriptor Address// The following are defines for the bit fields in the EMAC_O_HOSTXDESC// Count// Receive Interrupt Watchdog Timer// The following are defines for the bit fields in the EMAC_O_RXINTWDT// Missed Frame Counter// Overflow bit for Missed Frame// Overflow Frame Counter// Overflow Bit for FIFO Overflow// The following are defines for the bit fields in the EMAC_O_MFBOC register.// Transmit Stopped Enable// Transmit Buffer Unvailable// Transmit Jabber Timeout Enable// Overflow Interrupt Enable// Underflow Interrupt Enable// Receive Buffer Unavailable// Receive Stopped Enable// Receive Watchdog Timeout Enable// Early Transmit Interrupt Enable// Fatal Bus Error Enable// Early Receive Interrupt Enable// Abnormal Interrupt Summary// Normal Interrupt Summary Enable// The following are defines for the bit fields in the EMAC_O_DMAIM register.// Start or Stop Receive// Operate on Second Frame// 128 bytes// 96 bytes// 32 bytes// 64 bytes// Receive Threshold Control// Drop Giant Frame Enable// Forward Undersized Good Frames// Forward Error Frames// Command// Start or Stop Transmission// 16 bytes// 24 bytes// 40 bytes// 256 bytes// 192 bytes// Transmit Threshold Control// Flush Transmit FIFO// Transmit Store and Forward// Frames// Disable Flushing of Received// Receive Store and Forward// Checksum Error Frames// Disable Dropping of TCP/IP// The following are defines for the bit fields in the EMAC_O_DMAOPMODE// Transmit Interrupt// Transmit Process Stopped// Transmit Buffer Unavailable// Transmit Jabber Timeout// Receive Overflow// Transmit Underflow// Receive Interrupt// Receive Process Stopped// Receive Watchdog Timeout// Early Transmit Interrupt// Fatal Bus Error Interrupt// Early Receive Interrupt// Normal Interrupt Summary// buffer to host memory// receive packet data from receive// Running: Transferring the// Writing Timestamp// descriptor// Running: Closing receive// unavailable// Suspended: Receive descriptor// packet// Running: Waiting for receive// transfer descriptor// Running: Fetching receive// command issued// Stopped: Reset or stop receive// Received Process State// Running; Closing transmit// underflow// unavailable or transmit buffer// Suspended; Transmit descriptor// transmit buffer (TX FIFO)// memory buffer and queuing it to// Running; Reading data from host// Running; Waiting for status// Running; Fetching transmit// command processed// Stopped; Reset or Stop transmit// Transmit Process State// Read Access// Error during TX DMA Descriptor// Error during RX DMA Descriptor// Write Access// Transfer// Error during TX DMA Read Data// Error during RX DMA Write Data// Access Error// MAC MMC Interrupt// MAC PMT Interrupt Status// Timestamp Trigger Interrupt// LPI Trigger Interrupt Status// The following are defines for the bit fields in the EMAC_O_DMARIS register.// Start of Transmit List Base// The following are defines for the bit fields in the EMAC_O_TXDLADDR// Start of Receive List// The following are defines for the bit fields in the EMAC_O_RXDLADDR// Receive Poll Demand// The following are defines for the bit fields in the EMAC_O_RXPOLLD register.// Transmit Poll Demand// The following are defines for the bit fields in the EMAC_O_TXPOLLD register.// DMA Software Reset// DMA Arbitration Scheme// Descriptor Skip Length// Alternate Descriptor Size// Programmable Burst Length// Priority Ratio// Fixed Burst// (PBL)// RX DMA Programmable Burst Length// Length (PBL)// Use Separate Programmable Burst// (PBL) Mode// 8 x Programmable Burst Length// Address Aligned Beats// Mixed Burst// Transmit Priority// Rebuild Burst// The following are defines for the bit fields in the EMAC_O_DMABUSMOD// EN0PPS Output Signal Width// The following are defines for the bit fields in the EMAC_O_PPS0WIDTH// PPS0 Output Signal Interval// The following are defines for the bit fields in the EMAC_O_PPS0INTVL// (PPSCMD)// (PPSCTRL) or Command Control// EN0PPS Output Frequency Control// Flexible PPS Output Mode Enable// signal. No interrupt is asserted// generation of the EN0PPS output// for starting or stopping the// registers are programmed only// Indicates that the Target Time// signal// and starting or stopping the// generating the interrupt event// registers are programmed for// event// for generating the interrupt// PPS0 Output// Target Time Register Mode for// The following are defines for the bit fields in the EMAC_O_PPSCTRL register.// Timestamp Seconds Overflow// Timestamp Target Time Reached// The following are defines for the bit fields in the EMAC_O_TIMSTAT register.// Target Timestamp Higher Word// The following are defines for the bit fields in the EMAC_O_HWORDSEC// Target Timestamp Low Register// Target Time Register Busy// The following are defines for the bit fields in the EMAC_O_TARGNANO// Target Time Seconds Register// The following are defines for the bit fields in the EMAC_O_TARGSEC register.// Timestamp Addend Register// The following are defines for the bit fields in the EMAC_O_TIMADD register.// Timestamp Sub-Second// Add or subtract time// The following are defines for the bit fields in the EMAC_O_TIMNANOU// Timestamp Second// The following are defines for the bit fields in the EMAC_O_TIMSECU register.// Timestamp Sub-Seconds// The following are defines for the bit fields in the EMAC_O_TIMNANO register.// The following are defines for the bit fields in the EMAC_O_TIMSEC register.// Sub-second Increment Value// The following are defines for the bit fields in the EMAC_O_SUBSECINC// Timestamp Enable// Timestamp Fine or Coarse Update// Timestamp Initialize// Timestamp Update// Timestamp Interrupt Trigger// Addend Register Update// Enable Timestamp For All Frames// Rollover Control// Timestamp Digital or Binary// Version 2 Format// Enable PTP Packet Processing For// Ethernet Frames// Enable Processing of PTP Over// Sent Over IPv6-UDP// Enable Processing of PTP Frames// Sent over IPv4-UDP// Event Messages// Enable Timestamp Snapshot for// Relevant to Master// Enable Snapshot for Messages// Snapshots// Select PTP packets for Taking// Filtering// Enable MAC address for PTP Frame// The following are defines for the bit fields in the EMAC_O_TIMSTCTRL// VLAN Hash Table// The following are defines for the bit fields in the EMAC_O_VLANHASH// VLAN Tag for Transmit Frames// VLAN tag replacement// VLAN tag insertion// VLAN tag deletion// or replacement// No VLAN tag deletion, insertion,// VLAN Tag Control in Transmit// VLAN Priority Control// C-VLAN or S-VLAN// The following are defines for the bit fields in the EMAC_O_VLNINCREP// of received good unicast frames// This field indicates the number// The following are defines for the bit fields in the EMAC_O_RXCNTGUNI// alignment (dribble) error// of frames received with// The following are defines for the bit fields in the EMAC_O_RXCNTALGNERR// error// of frames received with CRC// The following are defines for the bit fields in the EMAC_O_RXCNTCRCERR// of received good and bad frames// The following are defines for the bit fields in the EMAC_O_RXCNTGB register.// of preamble, in good frames// of bytes transmitted, exclusive// The following are defines for the bit fields in the EMAC_O_TXOCTCNTG// in the half-duplex mode// frames after multiple collisions// of successfully transmitted// The following are defines for the bit fields in the EMAC_O_TXCNTMCOL// frames after a single collision// The following are defines for the bit fields in the EMAC_O_TXCNTSCOL// retried frames// transmitted, exclusive of// of good and bad frames// The following are defines for the bit fields in the EMAC_O_TXCNTGB register.// Counter Interrupt Mask// MMC Transmit Good Bad Frame// Good Frame Counter Interrupt// MMC Transmit Single Collision// MMC Transmit Multiple Collision// MMC Transmit Good Octet Counter// The following are defines for the bit fields in the EMAC_O_MMCTXIM register.// MMC Receive Good Bad Frame// MMC Receive CRC Error Frame// Frame Counter Interrupt Mask// MMC Receive Alignment Error// MMC Receive Unicast Good Frame// The following are defines for the bit fields in the EMAC_O_MMCRXIM register.// Counter Interrupt Status// Octet Counter Interrupt Status// The following are defines for the bit fields in the EMAC_O_MMCTXRIS// Frame Counter Interrupt Status// The following are defines for the bit fields in the EMAC_O_MMCRXRIS// Counters Reset// Counters Stop Rollover// Reset on Read// MMC Counter Freeze// Counters Preset// Full/Half Preset Level Value// Broadcast Frames// Update MMC Counters for Dropped// The following are defines for the bit fields in the EMAC_O_MMCCTRL register.// Watchdog Timeout// Programmable Watchdog Enable// The following are defines for the bit fields in the EMAC_O_WDOGTO register.// MAC Address3 [31:0]// The following are defines for the bit fields in the EMAC_O_ADDR3L register.// MAC Address3 [47:32]// Mask Byte Control// Source Address// Address Enable// The following are defines for the bit fields in the EMAC_O_ADDR3H register.// MAC Address2 [31:0]// The following are defines for the bit fields in the EMAC_O_ADDR2L register.// MAC Address2 [47:32]// The following are defines for the bit fields in the EMAC_O_ADDR2H register.// MAC Address1 [31:0]// The following are defines for the bit fields in the EMAC_O_ADDR1L register.// MAC Address1 [47:32]// The following are defines for the bit fields in the EMAC_O_ADDR1H register.// MAC Address0 [31:0]// The following are defines for the bit fields in the EMAC_O_ADDR0L register.// MAC Address0 [47:32]// The following are defines for the bit fields in the EMAC_O_ADDR0H register.// PMT Interrupt Mask// Timestamp Interrupt Mask// LPI Interrupt Mask// The following are defines for the bit fields in the EMAC_O_IM register.// PMT Interrupt Status// MMC Interrupt Status// MMC Receive Interrupt Status// MMC Transmit Interrupt Status// Timestamp Interrupt Status// LPI Interrupt Status// The following are defines for the bit fields in the EMAC_O_RIS register.// Low Power Idle TW Timer// Low Power Idle LS Timer// The following are defines for the bit fields in the EMAC_O_LPITIMERCTL// Transmit LPI Entry// Transmit LPI Exit// Receive LPI Entry// Receive LPI Exit// Transmit LPI State// Receive LPI State// LPI Enable// PHY Link Status// PHY Link Status Enable// LPI TX Automate// The following are defines for the bit fields in the EMAC_O_LPICTLSTAT// Magic Packet Enable// Wake-Up Frame Enable// Magic Packet Received// Wake-Up Frame Received// Global Unicast// Remote Wake-Up FIFO Pointer// Pointer Reset// Wake-Up Frame Filter Register// The following are defines for the bit fields in the EMAC_O_PMTCTLSTAT// Remote Wake-Up Frame Filter// The following are defines for the bit fields in the EMAC_O_RWUFF register.// MAC MII Receive Protocol Engine// FIFO Status// MAC Receive Frame Controller// Controller Active Status// TX/RX Controller RX FIFO Write// status// Flushing the frame data and// timestamp)// Reading frame status (or// Reading frame data// IDLE state// State// TX/RX Controller Read Controller// RX FIFO Full// flow-control activate threshold// RX FIFO fill level is above the// threshold// flow-control deactivate// RX FIFO fill level is below the// RX FIFO Empty// Fill-level Status// TX/RX Controller RX FIFO// MAC MII Transmit Protocol Engine// transmission// Transferring input frame for// full-duplex mode)// PAUSE control frame (in the// Generating and transmitting a// to be over// frame or IFG or backoff period// Waiting for status of previous// MAC Transmit Frame Controller// MAC Transmitter PAUSE// or flushing the TX FIFO// Writing the received TX Status// transmitter// Waiting for TX Status from MAC// MAC transmitter)// READ state (transferring data to// Controller Status// TX/RX Controller's TX FIFO Read// TX/RX Controller TX FIFO Write// Empty Status// TX/RX Controller TX FIFO Not// TX/RX Controller TX FIFO Full// The following are defines for the bit fields in the EMAC_O_STATUS register.// VLAN Tag Identifier for Receive// Comparison// Enable 12-Bit VLAN Tag// VLAN Tag Inverse Match Enable// Enable S-VLAN// VLAN Tag Hash Table Match Enable// The following are defines for the bit fields in the EMAC_O_VLANTG register.// Back-pressure Activate// Flow Control Busy or// Transmit Flow Control Enable// Receive Flow Control Enable// Unicast Pause Frame Detect// Disable Zero-Quanta Pause// Pause Time// The following are defines for the bit fields in the EMAC_O_FLOWCTL register.// MII Data// The following are defines for the bit fields in the EMAC_O_MIIDATA register.// MII Busy// MII Write// a MDIO clock of System Clock/26// Clock is 35 to 60 MHz providing// The frequency of the System// MDIO clock of System Clock/16// Clock is 20-35 MHz providing a// SYSCLK/62// providing a MDIO clock of// Clock is 100 to 150 MHz// a MDIO clock of SYSCLK/42// Clock is 60 to 100 MHz providing// Selection// Clock Reference Frequency// MII Register// Physical Layer Address// The following are defines for the bit fields in the EMAC_O_MIIADDR register.// Hash Table Low// The following are defines for the bit fields in the EMAC_O_HASHTBLL// Hash Table High// The following are defines for the bit fields in the EMAC_O_HASHTBLH// Promiscuous Mode// Hash Unicast// Hash Multicast// Destination Address (DA) Inverse// Pass All Multicast// Disable Broadcast Frames// pass the address Filter// MAC forwards control frames that// the address Filter// to application even if they fail// MAC forwards all control frames// the address filter// application even if they fail// except PAUSE control frames to// frames from reaching application// The MAC filters all control// Pass Control Frames// Source Address (SA) Inverse// Source Address Filter Enable// Hash or Perfect Filter// VLAN Tag Filter Enable// Receive All// The following are defines for the bit fields in the EMAC_O_FRAMEFLTR// 3 bytes of preamble// 5 bytes of preamble// 7 bytes of preamble// Preamble Length for Transmit// Receiver Enable// Transmitter Enable// Deferral Check// k = min (n,1)// k = min (n,4)// k = min (n,8)// k = min (n,10)// Back-Off Limit// Automatic Pad or CRC Stripping// Disable Retry// Checksum Offload// Disable Receive Own// Speed// Port Select// Transmission// Disable Carrier Sense During// 40 bit times// 48 bit times// 56 bit times// 64 bit times// 72 bit times// 80 bit times// 88 bit times// 96 bit times// Inter-Frame Gap (IFG)// Jumbo Frame Enable// Watchdog Disable// CRC Stripping for Type Frames// IEEE 802// The following are defines for the bit fields in the EMAC_O_CFG register.// Ethernet PHY Masked Interrupt// Ethernet MAC Clock Configuration// Configuration Register// Ethernet MAC Peripheral// Ethernet MAC Peripheral Property// Receive Buffer Address// Ethernet MAC Current Host// Transmit Buffer Address// Receive Descriptor// Transmit Descriptor// Watchdog Timer// Ethernet MAC Receive Interrupt// Buffer Overflow Counter// Ethernet MAC Missed Frame and// Ethernet MAC DMA Interrupt Mask// Ethernet MAC DMA Operation Mode// Ethernet MAC DMA Interrupt// List Address// Ethernet MAC Transmit Descriptor// Ethernet MAC Receive Descriptor// Ethernet MAC Receive Poll Demand// Demand// Ethernet MAC Transmit Poll// Ethernet MAC DMA Bus Mode// Ethernet MAC PPS0 Width// Ethernet MAC PPS0 Interval// Ethernet MAC PPS Control// Ethernet MAC Timestamp Status// Word Seconds// Ethernet MAC System Time-Higher// Nanoseconds// Ethernet MAC Target Time// Ethernet MAC Target Time Seconds// Ethernet MAC Timestamp Addend// Nanoseconds Update// Ethernet MAC System Time -// Seconds Update// Seconds// Ethernet MAC Sub-Second// Ethernet MAC Timestamp Control// Ethernet MAC VLAN Hash Table// or Replacement// Ethernet MAC VLAN Tag Inclusion// for Good Unicast Frames// Ethernet MAC Receive Frame Count// for Alignment Error Frames// for CRC Error Frames// for Good and Bad Frames// Count Good// Ethernet MAC Transmit Octet// after Multiple Collisions// Count for Frames Transmitted// Ethernet MAC Transmit Frame// after Single Collision// Count for Good and Bad Frames// Ethernet MAC MMC Transmit// Ethernet MAC MMC Receive// Ethernet MAC MMC Transmit Raw// Ethernet MAC MMC Receive Raw// Ethernet MAC MMC Control// Ethernet MAC Watchdog Timeout// Ethernet MAC Address 3 Low// Ethernet MAC Address 3 High// Ethernet MAC Address 2 Low// Ethernet MAC Address 2 High// Ethernet MAC Address 1 Low// Ethernet MAC Address 1 High// Ethernet MAC Address 0 Low// Ethernet MAC Address 0 High// Ethernet MAC Interrupt Mask// Ethernet MAC Raw Interrupt// Timer Control Register// Ethernet MAC Low Power Idle// Control and Status Register// Status Register// Ethernet MAC PMT Control and// Frame Filter// Ethernet MAC Remote Wake-Up// Ethernet MAC Status// Ethernet MAC VLAN Tag// Ethernet MAC Flow Control// Ethernet MAC MII Data Register// Ethernet MAC MII Address// Ethernet MAC Hash Table Low// Ethernet MAC Hash Table High// Ethernet MAC Frame Filter// Ethernet MAC Configuration// The following are defines for the EMAC register offsets.// hw_emac.h - Macros used when accessing the EMAC hardware./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/emac.htEMACWakeUpFrameFilterpackedtEMACDMADescriptortEMACDES3union <unnamed>uint16_t[4]unsigned short[4]pui16CRCuint8_t[4]unsigned char[4]pui8Offsetpui8Commanduint32_t[4]unsigned long[4]pui32ByteMaskui32IEEE1588TimeHiui32IEEE1588TimeLoui32Reservedui32ExtRxStatusDES3void *pvBuffer2tEMACDMADescriptor *pLinkpvBuffer1ui32CtrlStatusEMAC_PMT_MAGIC_PACKET_RECEIVEDEMAC_PMT_WAKEUP_PACKET_RECEIVEDEMAC_PMT_POWER_DOWNEMAC_PMT_MAGIC_PACKET_ENABLEEMAC_PMT_WAKEUP_PACKET_ENABLEEMAC_PMT_GLOBAL_UNICAST_ENABLEEMAC_RWU_FILTER_UNICASTEMAC_RWU_FILTER_MULTICASTEMAC_RWU_FILTER_DISABLEEMAC_RWU_FILTER_ENABLEEMAC_VLAN_TX_VLC_MASKEMAC_VLAN_TX_VLC_REPLACEEMAC_VLAN_TX_VLC_INSERTEMAC_VLAN_TX_VLC_DELETEEMAC_VLAN_TX_VLC_NONEEMAC_VLAN_TX_USE_VLCEMAC_VLAN_TX_SVLANEMAC_VLAN_TX_CVLANEMAC_VLAN_RX_16BIT_TAGEMAC_VLAN_RX_12BIT_TAGEMAC_VLAN_RX_INVERSE_MATCHEMAC_VLAN_RX_NORMAL_MATCHEMAC_VLAN_RX_SVLAN_DISABLEEMAC_VLAN_RX_SVLAN_ENABLEEMAC_VLAN_RX_HASH_DISABLEEMAC_VLAN_RX_HASH_ENABLEEMAC_PPS_COMMAND_CANCEL_STOP0x06EMAC_PPS_COMMAND_STOP_NOW0x05EMAC_PPS_COMMAND_STOP_AT_TIME0x04EMAC_PPS_COMMAND_CANCEL_START0x03EMAC_PPS_COMMAND_START_TRAIN0x02EMAC_PPS_COMMAND_START_SINGLE0x01EMAC_PPS_COMMAND_NONE0x00EMAC_PPS_TARGET_BOTHEMAC_PPS_TARGET_PPSEMAC_PPS_TARGET_INTEMAC_PPS_32768HZEMAC_PPS_16384HZEMAC_PPS_8192HZEMAC_PPS_4096HZEMAC_PPS_2048HZEMAC_PPS_1024HZEMAC_PPS_512HZEMAC_PPS_256HZEMAC_PPS_128HZEMAC_PPS_64HZEMAC_PPS_32HZEMAC_PPS_16HZEMAC_PPS_8HZEMAC_PPS_4HZEMAC_PPS_2HZEMAC_PPS_1HZEMAC_PPS_SINGLE_PULSEEMAC_INT_POWER_MGMNTEMAC_TS_INT_TS_SEC_OVERFLOWEMAC_TS_INT_TARGET_REACHEDEMAC_INT_TIMESTAMPEMAC_INT_LPIEMAC_INT_ABNORMAL_INTEMAC_INT_NORMAL_INTEMAC_INT_TRANSMITEMAC_INT_TX_STOPPEDEMAC_INT_TX_NO_BUFFEREMAC_INT_TX_JABBEREMAC_INT_RX_OVERFLOWEMAC_INT_TX_UNDERFLOWEMAC_INT_RECEIVEEMAC_INT_RX_NO_BUFFEREMAC_INT_RX_STOPPEDEMAC_INT_RX_WATCHDOGEMAC_INT_EARLY_TRANSMITEMAC_INT_BUS_ERROREMAC_INT_EARLY_RECEIVEEMAC_INT_PHYEPHY_SCR_INTOE_EXTEPHY_SCR_INTEN_EXTEPHY_SCR_TINT_EXTEPHY_SCR_INPOL_EXTEMAC_TS_UPDATE_COARSEEMAC_TS_UPDATE_FINEEMAC_TS_ALL_RX_FRAMESEMAC_TS_BINARY_ROLLOVEREMAC_TS_DIGITAL_ROLLOVEREMAC_TS_PTP_VERSION_1EMAC_TS_PTP_VERSION_2EMAC_TS_PROCESS_ETHERNETEMAC_TS_PROCESS_IPV6_UDPEMAC_TS_PROCESS_IPV4_UDPEMAC_TS_PDREQ_PDRESPEMAC_TS_SYNC_DELAYREQEMAC_TS_DREQ_PDREQ_PDRESPEMAC_TS_SYNC_PDREQ_PDRESPEMAC_TS_ALLEMAC_TS_DELAYREQ_ONLYEMAC_TS_SYNC_ONLYEMAC_TS_SYNC_FOLLOW_DREQ_DRESPEMAC_TS_MAC_FILTER_DISABLEEMAC_TS_MAC_FILTER_ENABLEEMAC_FILTER_BYTE_MASK_SEMAC_FILTER_BYTE_MASK_MEMAC_FILTER_MASK_BYTE_1EMAC_FILTER_MASK_BYTE_2EMAC_FILTER_MASK_BYTE_3EMAC_FILTER_MASK_BYTE_4EMAC_FILTER_MASK_BYTE_5EMAC_FILTER_MASK_BYTE_6EMAC_FILTER_SOURCE_ADDREMAC_FILTER_ADDR_ENABLEEMAC_DMA_ERR_TX_DESC_READEMAC_DMA_ERR_RX_DESC_READEMAC_DMA_ERR_TX_DESC_WRITEEMAC_DMA_ERR_RX_DESC_WRITEEMAC_DMA_ERR_TX_DATA_READEMAC_DMA_ERR_RX_DATA_WRITEEMAC_DMA_ERR_MASKEMAC_DMA_ERROREMAC_RX_DMA_STATE(x)((x) & EMAC_DMA_RXSTAT_MASK)EMAC_TX_DMA_STATE(x)((x) & EMAC_DMA_TXSTAT_MASK)EMAC_DMA_RXSTAT_RUN_RECEIVING(0x07 << 17)EMAC_DMA_RXSTAT_TS_WRITE(0x06 << 17)EMAC_DMA_RXSTAT_RUN_CLOSE_DESC(0x05 << 17)EMAC_DMA_RXSTAT_SUSPENDED(0x04 << 17)EMAC_DMA_RXSTAT_RUN_WAIT_PACKET(0x03 << 17)EMAC_DMA_RXSTAT_RUN_FETCH_DESC(0x01 << 17)EMAC_DMA_RXSTAT_STOPPED(0x00 << 17)EMAC_DMA_RXSTAT_MASKEMAC_DMA_TXSTAT_SUSPENDED(0x06 << 20)EMAC_DMA_TXSTAT_TS_WRITE(0x04 << 20)EMAC_DMA_TXSTAT_RUN_CLOSE_DESC(0x07 << 20)EMAC_DMA_TXSTAT_RUN_READING(0x03 << 20)EMAC_DMA_TXSTAT_RUN_WAIT_STATUS(0x02 << 20)EMAC_DMA_TXSTAT_RUN_FETCH_DESC(0x01 << 20)EMAC_DMA_TXSTAT_STOPPED(0x00 << 20)EMAC_DMA_TXSTAT_MASKEMAC_STATUS_RPE_ACTIVEEMAC_STATUS_RWC_ACTIVEEMAC_STATUS_RX_FIFO_FLUSHING(0x03 << 5)EMAC_STATUS_RX_FIFO_STATUS(0x02 << 5)EMAC_STATUS_RX_FIFO_READING(0x01 << 5)EMAC_STATUS_RX_FIFO_IDLE(0x00 << 5)EMAC_STATUS_RX_FIFO_STATE_MASKEMAC_STATUS_RX_FIFO_FULL(0x03 << 8)EMAC_STATUS_RX_FIFO_ABOVE(0x02 << 8)EMAC_STATUS_RX_FIFO_BELOW(0x01 << 8)EMAC_STATUS_RX_FIFO_EMPTY(0x00 << 8)EMAC_STATUS_RX_FIFO_LEVEL_MASKEMAC_STATUS_MAC_NOT_IDLEEMAC_STATUS_TFC_STATE_WRITINGEMAC_STATUS_TFC_STATE_PAUSING(0x02 << 17)EMAC_STATUS_TFC_STATE_WAITINGEMAC_STATUS_TFC_STATE_IDLEEMAC_STATUS_TFC_STATE_MASKEMAC_STATUS_TX_PAUSEDEMAC_STATUS_TRC_STATE_STATUSEMAC_STATUS_TRC_STATE_WAITINGEMAC_STATUS_TRC_STATE_READINGEMAC_STATUS_TRC_STATE_IDLEEMAC_STATUS_TRC_STATE_MASKEMAC_STATUS_TX_WRITING_FIFOEMAC_STATUS_TX_NOT_EMPTYEMAC_FRMFILTER_PROMISCUOUSEMAC_FRMFILTER_HASH_UNICASTEMAC_FRMFILTER_HASH_MULTICASTEMAC_FRMFILTER_INV_DADDREMAC_FRMFILTER_PASS_MULTICASTEMAC_FRMFILTER_BROADCASTEMAC_FRMFILTER_PASS_ADDR_CTRL(0x03 << 6)EMAC_FRMFILTER_PASS_ALL_CTRL(0x02 << 6)EMAC_FRMFILTER_PASS_NO_PAUSE(0x01 << 6)EMAC_FRMFILTER_PASS_NO_CTRL(0x00 << 6)EMAC_FRMFILTER_PASS_MASKEMAC_FRMFILTER_INV_SADDREMAC_FRMFILTER_SADDREMAC_FRMFILTER_HASH_AND_PERFECTEMAC_FRMFILTER_VLANEMAC_FRMFILTER_RX_ALLEMAC_MODE_RX_DMA_ENABLEDEMAC_MODE_TX_DMA_ENABLEDEMAC_CONFIG_RX_ENABLEDEMAC_CONFIG_TX_ENABLEDEMAC_MODE_OPERATE_2ND_FRAMEEMAC_MODE_RX_THRESHOLD_128_BYTES(3 << 3)EMAC_MODE_RX_THRESHOLD_96_BYTES(2 << 3)EMAC_MODE_RX_THRESHOLD_32_BYTES(1 << 3)EMAC_MODE_RX_THRESHOLD_64_BYTES(0 << 3)EMAC_MODE_RX_UNDERSIZED_FRAMESEMAC_MODE_RX_ERROR_FRAMESEMAC_MODE_TX_THRESHOLD_256_BYTES(3 << 14)EMAC_MODE_TX_THRESHOLD_192_BYTES(2 << 14)EMAC_MODE_TX_THRESHOLD_128_BYTES(1 << 14)EMAC_MODE_TX_THRESHOLD_64_BYTES(0 << 14)EMAC_MODE_TX_THRESHOLD_40_BYTES(4 << 14)EMAC_MODE_TX_THRESHOLD_32_BYTES(5 << 14)EMAC_MODE_TX_THRESHOLD_24_BYTES(6 << 14)EMAC_MODE_TX_THRESHOLD_16_BYTES(7 << 14)EMAC_MODE_TX_STORE_FORWARDEMAC_MODE_RX_FLUSH_DISABLEEMAC_MODE_RX_STORE_FORWARDEMAC_MODE_KEEP_BAD_CRCEMAC_CONFIG_3BYTE_PREAMBLEEMAC_CONFIG_5BYTE_PREAMBLEEMAC_CONFIG_7BYTE_PREAMBLEEMAC_CONFIG_PREAMBLE_MASKEMAC_CONFIG_DEFERRAL_CHK_ENABLEEMAC_CONFIG_BO_LIMIT_2(0x3 << 5)EMAC_CONFIG_BO_LIMIT_16(0x2 << 5)EMAC_CONFIG_BO_LIMIT_256(0x1 << 5)EMAC_CONFIG_BO_LIMIT_1024(0x0 << 5)EMAC_CONFIG_BO_MASKEMAC_CONFIG_AUTO_CRC_STRIPPINGEMAC_CONFIG_RETRY_DISABLEEMAC_CONFIG_CHECKSUM_OFFLOADEMAC_CONFIG_HALF_DUPLEXEMAC_CONFIG_FULL_DUPLEXEMAC_CONFIG_LOOPBACKEMAC_CONFIG_RX_OWN_DISABLEEMAC_CONFIG_10MBPSEMAC_CONFIG_100MBPSEMAC_CONFIG_CS_DISABLEEMAC_CONFIG_IF_GAP_40BITS(0x7 << 17)EMAC_CONFIG_IF_GAP_48BITS(0x6 << 17)EMAC_CONFIG_IF_GAP_56BITS(0x5 << 17)EMAC_CONFIG_IF_GAP_64BITS(0x4 << 17)EMAC_CONFIG_IF_GAP_72BITS(0x3 << 17)EMAC_CONFIG_IF_GAP_80BITS(0x2 << 17)EMAC_CONFIG_IF_GAP_88BITS(0x1 << 17)EMAC_CONFIG_IF_GAP_96BITS(0x0 << 17)EMAC_CONFIG_IF_GAP_MASKEMAC_CONFIG_JUMBO_ENABLEEMAC_CONFIG_JABBER_DISABLEEMAC_CONFIG_STRIP_CRCEMAC_CONFIG_2K_PACKETSEMAC_CONFIG_SA_REPLACEEMAC_CONFIG_SA_INSERTEMAC_CONFIG_SA_FROM_DESCRIPTOREMAC_CONFIG_USE_MACADDR0EMAC_CONFIG_USE_MACADDR1EMAC_PHY_TYPE_MASK0xC0000000EMAC_PHY_INT_HOLDEMAC_PHY_AN_100B_T_FULL_DUPLEXEMAC_PHY_AN_100B_T_HALF_DUPLEXEMAC_PHY_AN_10B_T_FULL_DUPLEXEMAC_PHY_AN_10B_T_HALF_DUPLEXEMAC_PHY_FORCE_100B_T_FULL_DUPLEXEMAC_PHY_FORCE_100B_T_HALF_DUPLEXEMAC_PHY_FORCE_10B_T_FULL_DUPLEXEMAC_PHY_FORCE_10B_T_HALF_DUPLEXEMAC_PHY_INT_FAST_AN_140_150_100EMAC_PHY_INT_FAST_AN_120_75_50EMAC_PHY_INT_FAST_AN_80_50_35EMAC_PHY_INT_EXT_FULL_DUPLEXEMAC_PHY_INT_FAST_L_UP_DETECTEMAC_PHY_INT_FAST_RXDV_DETECTEMAC_PHY_INT_MDIX_ENEMAC_PHY_INT_FAST_MDIXEMAC_PHY_INT_ROBUST_MDIXEMAC_PHY_INT_MDI_SWAPEMAC_PHY_INT_POLARITY_SWAPEMAC_PHY_INT_LD_ON_SIGNAL_ENERGYEMAC_PHY_INT_LD_ON_LOW_SNREMAC_PHY_INT_LD_ON_MTL3_ERR_COUNTEMAC_PHY_INT_LD_ON_RX_ERR_COUNTEMAC_PHY_INT_TDRRUNEMAC_PHY_INT_LINK_LOSS_RECOVERYEMAC_PHY_INT_ISOLATE_MII_LLOSSEMAC_PHY_INT_RX_ER_DURING_IDLEEMAC_PHY_INT_NIB_TXERR_DET_DISEMAC_PHY_TYPE_EXTERNAL_RMIIEMAC_PHY_TYPE_EXTERNAL_MIIEMAC_PHY_TYPE_INTERNALEMAC_BCONFIG_MIXED_BURSTEMAC_BCONFIG_FIXED_BURSTEMAC_BCONFIG_PRIORITY_FIXEDEMAC_BCONFIG_PRIORITY_4_1EMAC_BCONFIG_PRIORITY_3_1EMAC_BCONFIG_PRIORITY_2_1EMAC_BCONFIG_PRIORITY_1_1EMAC_BCONFIG_PRIORITY_MEMAC_BCONFIG_ADDR_ALIGNEDEMAC_BCONFIG_TX_PRIORITYEMAC_BCONFIG_DMA_PRIO_WEIGHT_4EMAC_BCONFIG_DMA_PRIO_WEIGHT_3EMAC_BCONFIG_DMA_PRIO_WEIGHT_2EMAC_BCONFIG_DMA_PRIO_WEIGHT_1EMAC_BCONFIG_DMA_PRIO_WEIGHT_MDES4_RX_STAT_PAYLOAD_ICMPDES4_RX_STAT_PAYLOAD_TCPDES4_RX_STAT_PAYLOAD_UDPDES4_RX_STAT_PAYLOAD_UNKNOWNDES4_RX_STAT_PAYLOAD_MDES4_RX_STAT_IP_HEADER_ERRDES4_RX_STAT_IP_PAYLOAD_ERRDES4_RX_STAT_IP_CHK_BYPASSEDDES4_RX_STAT_IPV4DES4_RX_STAT_IPV6DES4_RX_STAT_PTP_MT_RESERVEDDES4_RX_STAT_PTP_MT_SIGNALLING0x00000A00DES4_RX_STAT_PTP_MT_ANNOUNCEDES4_RX_STAT_PTP_MT_PDELAY_RFUDES4_RX_STAT_PTP_MT_PDELAY_RESPDES4_RX_STAT_PTP_MT_PDELAY_REQDES4_RX_STAT_PTP_MT_DELAY_RESPDES4_RX_STAT_PTP_MT_DELAY_REQDES4_RX_STAT_PTP_MT_FOLLOW_UPDES4_RX_STAT_PTP_MT_SYNCDES4_RX_STAT_PTP_MT_NONEDES4_RX_STAT_PTP_MT_MDES4_RX_STAT_PTP_TYPE_UDPDES4_RX_STAT_PTP_TYPE_ETHDES4_RX_STAT_PTP_VERSION2DES4_RX_STAT_TS_DROPPEDDES1_RX_CTRL_BUFF1_SIZE_SDES1_RX_CTRL_BUFF1_SIZE_MDES1_RX_CTRL_CHAINEDDES1_RX_CTRL_END_OF_RINGDES1_RX_CTRL_BUFF2_SIZE_SDES1_RX_CTRL_BUFF2_SIZE_M0x1FFF0000DES1_RX_CTRL_DISABLE_INTDES0_RX_STAT_EXT_AVAILABLEDES0_RX_STAT_MAC_ADDRDES0_RX_STAT_CRC_ERRDES0_RX_STAT_DRIBBLE_ERRDES0_RX_STAT_RX_ERRDES0_RX_STAT_WDOG_TIMEOUTDES0_RX_STAT_FRAME_TYPEDES0_RX_STAT_RX_L_COLLISIONDES0_RX_STAT_TS_AVAILABLEDES0_RX_STAT_LAST_DESCDES0_RX_STAT_FIRST_DESCDES0_RX_STAT_VLAN_TAGDES0_RX_STAT_OVERFLOWDES0_RX_STAT_LENGTH_ERRDES0_RX_STAT_SRC_ADDR_FAILDES0_RX_STAT_DESCRIPTOR_ERRDES0_RX_STAT_ERRDES0_RX_STAT_FRAME_LENGTH_SDES0_RX_STAT_FRAME_LENGTH_M0x3FFF0000DES0_RX_STAT_DEST_ADDR_FAILDES0_RX_CTRL_OWNDES1_TX_CTRL_BUFF1_SIZE_SDES1_TX_CTRL_BUFF2_SIZE_SDES1_TX_CTRL_BUFF1_SIZE_MDES1_TX_CTRL_BUFF2_SIZE_MDES1_TX_CTRL_SADDR_REPLACEDES1_TX_CTRL_SADDR_INSERTDES1_TX_CTRL_SADDR_NONEDES1_TX_CTRL_SADDR_M0x60000000DES1_TX_CTRL_SADDR_MAC1DES0_TX_STAT_DEFERREDDES0_TX_STAT_UNDERFLOWDES0_TX_STAT_E_DEFERRALDES0_TX_STAT_COL_COUNT_SDES0_TX_STAT_COL_COUNT_MDES0_TX_STAT_VLAN_FRAMEDES0_TX_STAT_E_COLLISIONDES0_TX_STAT_TX_L_COLLISIONDES0_TX_STAT_NO_CARRIERDES0_TX_STAT_CARRIER_LOSTDES0_TX_STAT_PAYLOAD_ERRDES0_TX_STAT_FLUSHEDDES0_TX_STAT_JABBER_TODES0_TX_STAT_ERRDES0_TX_STAT_IPH_ERRDES0_TX_STAT_TS_CAPTUREDDES0_TX_CTRL_VLAN_REPLACEDES0_TX_CTRL_VLAN_INSERTDES0_TX_CTRL_VLAN_REMOVEDES0_TX_CTRL_VLAN_NONEDES0_TX_CTRL_VLAN_MDES0_TX_CTRL_CHAINEDDES0_TX_CTRL_END_OF_RINGDES0_TX_CTRL_IP_ALL_CKHSUMSDES0_TX_CTRL_IP_HDR_PAY_CHKSUMDES0_TX_CTRL_IP_HDR_CHKSUMDES0_TX_CTRL_NO_CHKSUMDES0_TX_CTRL_CHKSUM_MDES0_TX_CTRL_REPLACE_CRCDES0_TX_CTRL_ENABLE_TSDES0_TX_CTRL_DISABLE_PADDINGDES0_TX_CTRL_DISABLE_CRCDES0_TX_CTRL_FIRST_SEGDES0_TX_CTRL_LAST_SEGDES0_TX_CTRL_INTERRUPTDES0_TX_CTRL_OWNntohs(a)htons((a))htons(a)((((a) >> 8) & 0x00ff) | (((a) << 8) & 0xff00))ntohl(a)htonl((a))htonl(a)((((a) >> 24) & 0x000000ff) | (((a) >> 8) & 0x0000ff00) | (((a) << 8) & 0x00ff0000) | (((a) << 24) & 0xff000000))EMAC_PHY_ADDR__DRIVERLIB_EMAC_H__htonlntohlhtonsntohsewarmdefined(ccs) ||             \EMACPHYMMDReadEMACPHYMMDWriteEMACLPILinkClearEMACLPILinkSetEMACLPIStatusEMACLPIEnterEMACLPIConfigEMACWoLEnterEMACPowerManagementStatusGetEMACPowerManagementControlGetEMACPowerManagementControlSetEMACRemoteWakeUpFrameFilterGettEMACWakeUpFrameFilter *EMACRemoteWakeUpFrameFilterSetconst tEMACWakeUpFrameFilterconst tEMACWakeUpFrameFilter *EMACVLANHashFilterGetEMACVLANHashFilterSetEMACVLANHashFilterBitCalculateEMACVLANTxConfigGetuint16_t *EMACVLANTxConfigSetEMACVLANRxConfigGetEMACVLANRxConfigSetEMACTimestampPPSPeriodSetEMACTimestampPPSCommandEMACTimestampPPSCommandModeSetEMACTimestampPPSSimpleModeSetEMACTimestampIntStatusEMACTimestampTargetIntDisableEMACTimestampTargetIntEnableEMACTimestampTargetSetEMACTimestampSysTimeUpdateEMACTimestampSysTimeGetEMACTimestampSysTimeSetEMACTimestampDisableEMACTimestampEnableEMACTimestampAddendSetEMACTimestampConfigGetEMACTimestampConfigSetEMACPHYPowerOnEMACPHYPowerOffEMACPHYExtendedReadEMACPHYReadEMACPHYExtendedWriteEMACPHYWriteEMACIntUnregisterEMACIntRegisterEMACIntClearEMACIntStatusEMACIntDisableEMACIntEnableEMACRxDisableEMACRxEnableEMACTxDisableEMACTxEnableEMACTxFlushEMACDMAStateGetEMACStatusGetEMACRxWatchdogTimerSetEMACAddrFilterGetEMACAddrFilterSetEMACNumAddrGetEMACAddrGetEMACAddrSetconst uint8_tconst uint8_t *EMACConfigGetEMACTxDMACurrentBufferGetEMACTxDMACurrentDescriptorGetEMACTxDMADescriptorListGetEMACTxDMADescriptorListSetEMACRxDMACurrentBufferGetEMACRxDMACurrentDescriptorGetEMACRxDMADescriptorListGetEMACRxDMADescriptorListSetEMACRxDMAPollDemandEMACTxDMAPollDemandEMACHashFilterBitCalculateEMACHashFilterGetEMACHashFilterSetEMACFrameFilterGetEMACFrameFilterSetEMACConfigSetEMACPHYConfigSetEMACResetEMACInit// __DRIVERLIB_EMAC_H__// Public function prototypes.// EMAC_PMT_POWER_DOWN if the MAC is in power-down mode.// EMACPowerManagementStatusGet.  This call will also return// Values which may be ORed together and returned from a call to// EMACPowerManagementControlGet.// EMACPowerManagementControlSet.  These may also returned be from a call to// Values which may be ORed together and used in the ui32Flags parameter to// Turn off structure packing again.//! CRC is calculated using all bytes indicated by the filter's mask.//! The CRC16 value that is expected for each filter if it passes.  The//! byte of a frame is offset 0.//! examining bytes.  The minimum value for each offset is 12.  The first//! Determines the byte offset within the frame at which the filter starts//! EMAC_RWU_FILTER_UNICAST or EMAC_RWU_FILTER_MULTICAST.//! EMAC_RWU_FILTER_ENABLE or EMAC_RWU_FILTER_DISABLE ORed with one of//! multicast or unicast frames.  Valid values are one of//! Defines whether each filter is enabled and, if so, whether it filters//! CRC16 for the filter, a 0 indicates that the byte is ignored.//! packets. A 1 indicates that the relevant byte is used to update the//! 31 (bit 31 must be clear in each mask) are used to filter incoming//! A byte mask for each filter defining which bytes from a sequence of//! frames which will cause the MAC to wake up from sleep mode.//! This structure defines up to 4 filters that can be used to define specific// The following structure fields must be packed.// parameter and which may be returned from EMACVLANTxConfigGet.// Values which may be passed to EMACVLANTxConfigSet in the ui32Config// parameter and which may be returned from EMACVLANRxConfigGet.// Values which may be passed to EMACVLANRxConfigSet in the ui32Config// Commands which may be passed to EMACTimestampPPSCmd.// EMACTimestampPPSCommandModeSet().// Configuration flags that may be passed in the ui32Config parameter to// EMACTimestampPPSSimpleModeSet().// Configuration flags that may be passed in the ui32FreqConfig parameter to// be cleared by calling EMACPowerManagementStatusGet().// This interrupt source is readable using EMACIntStatus but must// Interrupt sources which may be returned from EMACTimestampIntStatus().// be cleared by calling the EMACTimestampIntStatus().// be cleared by calling the EMACEEEStatus().// EMAC_INT_RX_WATCHDOG | EMAC_INT_EARLY_TRANSMIT | EMAC_INT_BUS_ERROR.// EMAC_INT_TX_UNDERFLOW | EMAC_INT_RX_NO_BUFFER | EMAC_INT_RX_STOPPED |// EMAC_INT_TX_STOPPED | EMAC_INT_TX_JABBER | EMAC_INT_RX_OVERFLOW |// EMAC_INT_ABNORMAL_INT is the logical OR of the masked state of// EMAC_INT_EARLY_RECEIVE.// EMAC_INT_TRANSMIT | EMAC_INT_RECEIVE | EMAC_INT_TX_NO_BUFFER |// EMAC_INT_NORMAL_INT is the logical OR of the masked state of// normal or abnormal condition requiring software attention.// they are derived from but offer merely a simple way to be informed of a// may be enabled or disabled independently of the group of interrupts that// using EMACIntStatus() and must be cleared using EMACIntClear().  They// These interrupt sources are summary indicators.  They are readable// and unfriendly so we hide it inside DriverLib.// read the PHY interrupt status to see that it fired.  This would be nasty// they would have to call EMACIntStatus() and then, if it returned 0,// different API (since they share a vector).  To further complicate matters,// have to enable the MAC interrupt then enable the PHY interrupt via a// independent register within the code.  If we didn't do this, the app would// register.  We handle the fact that the PHY interrupt is controlled via an// EMAC_INT_PHY is deliberately set to a reserved bit in the MAC interrupt// and EMACPowerManagementControlSet.// independently enabled via calls to functions EMACTimestampTargetIntEnable// Note that interrupts relating to timestamping and power management must be// EMACIntDisable() to enable or disable various Ethernet interrupt sources.// These interrupt sources may be passed to EMACIntEnable() and// the definitions here helps when using an external MII or RMII PHY.// relevant (or available) when using the internal Ethernet PHY but having// Some register bit definitions relating to external PHYs.  These are not// EMACTimestampConfigGet.// Flags passed to EMACTimestampConfigSet or returned from// EMACAddrFilterSet and which may be returned by EMACAddrFilterGet.// Values which may be ORed together in the ui32Config parameter passed to// Values which may be returned by EMACDMAStateGet().// Values which may be returned by EMACStatusGet().// parameter, and are returned by EMACFrameFilterGet().// These values may be passed to EMACFrameFilterSet() in the ui32FilterOpts// EMACRxEnable/Disable().// disabled using independent functions, EMACTxEnable/Disable() and// parameter. The transmit and receive DMA channels are, however, enabled and// These two values may be returned by EMACConfigGet() in the *pui32Mode// using independent functions, EMACTxEnable/Disable() and// parameter.  The transmitter and receiver are, however, enabled and disabled// These two values may be returned by EMACConfigGet() in the *pui32Config// Options used in the ui32ModeFlags parameter to EMACConfigSet().// Options used in the ui32Config parameter to EMACConfigSet().// Options used in the ui32Config parameter to EMACPHYConfigSet().//***************************************************************************// Values used in the ui32BusConfig parameter to EMACInit().// tEMACDMADescriptor)// Fields found in the DES4 word of the receive descriptor (ui32ExtRxStatus in// Fields found in the DES1 word of the receive descriptor (ui32Count in// Fields found in the DES0 word of the receive descriptor (ui32CtrlStatus in// Fields found in the DES1 word of the transmit descriptor (ui32Count in// with a newly calculated CRC.// specified, the MAC will replace the last 4 bytes of a transmitted frame// This value is only valid if used alongside DES0_TX_CTRL_DISABLE_CRC.  When// after the last data byte in the frame.// CRC for all frames transmitted and append this value as the 4-byte FCS// If DES0_TX_CTRL_DISABLE_CRC is not specified, the MAC will calculate the// transmitted have valid CRCs precomputed and included in the frame data.// If DES0_TX_CTRL_REPLACE_CRC is not specified, it is assumed that packets// packet passed to the transmitter are replaced with a newly calculated CRC.// packets.  If used with DES0_TX_CTRL_REPLACE_CRC, the last 4 bytes of the// This value indicates that the MAC should not append a CRC to transmitted// Fields found in the DES0 word of the transmit descriptor (ui32CtrlStatus in//! timestamp captured for transmitted or received data.//! The eighth descriptor word contains the high 32 bits of the 64-bit//! in the first descriptor word.//! packet.  Availability of the timestamp is indicated via a status bit//! only when the transmitted or received data contains the end of a//! timestamp captured for transmitted or received data.  The value is set//! The seventh descriptor word contains the low 32 bits of the 64-bit//! descriptors.//! The sixth descriptor word is reserved for both transmit and receive//! used to report extended status in a receive descriptor.//! The fifth descriptor word is reserved for transmit descriptors but//! word of the receive descriptor.//! appears in the first word of the transmit descriptor or the second//! meaning of the word is controlled by the ``CHAINED'' control bit which//! descriptor in the ring or a pointer to a second data buffer.  The//! The fourth descriptor word contains either a pointer to the next//! reporting a bus error.//! EPI-connected memory may not be used and will result in the MAC//! pointer must refer to a buffer in internal SRAM.  Pointers to flash or//! data to transmit or into which received data should be written.  This//! The third descriptor word contains a pointer to the buffer containing//! control bits.//! buffer or buffers attached to the descriptor and various additional//! The second descriptor word contains information on the size of the//! that the hardware has control of the descriptor.//! queue.  Bit 31 is always the ``OWN'' bit which, when set, indicates//! depending upon whether the descriptor is in the transmit or receive//! The first DMA descriptor word contains various control and status bits//! A structure defining a single Ethernet DMA buffer descriptor.//! storage for a received frame.//! to a second buffer containing data for transmission or providing//! When the DMA descriptors are unchained, this field may be used to point//! provide a link to the next descriptor.//! When DMA descriptors are used in chained mode, this field is used to//! word of the Ethernet DMA descriptor.//! A union used to describe the two overlapping fields forming the third// Forward reference to the Ethernet DMA descriptor structure.// values.// htons/ntohs - Big endian/little endian byte swapping macros for 16-bit// htonl/ntohl - Big endian/little endian byte swapping macros for 32-bit// Helper Macros for Ethernet Processing// The physical address of the internal PHY.  This should be in hw_emac.h.//! \addtogroup emac_api//          devices.// emac.h - Defines and Macros for the Ethernet module on Snowflake-classui8PhyAddrui16RegAddrui16DatabLPIConfigui16LPILSTimerui16LPITWTimerpFilterui32Hashui16Tagpui16Tagui32Periodui32Widthui8Cmdui32FreqConfigui32Secondsui32Nanosecondsui32SubSecondsbIncpui32Secondspui32SubSecondspui32SubSecondIncui32SubSecondIncui8RegAddrui8Timeoutui32Indexpui8MACAddrpui32Configpui32Modepui32RxMaxFrameSizepDescriptorpui32HashHipui32HashLoui32HashHiui32HashLoui32FilterOptsui32ModeFlagsui32RxMaxFrameSizeui32SysClkui32BusConfigui32RxBurstui32TxBurstui32DescSkipSize/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/sw_crc.hCrc32Crc16Array3const uint32_tconst uint32_t *Crc16ArrayCrc16Crc8CCITT__DRIVERLIB_SW_CRC_H__// __DRIVERLIB_SW_CRC_H__// Prototypes for the functions.// sw_crc.h - Prototypes for the software CRC functions.ui32Crcui32WordLenpui16Crc3ui16Crcui8Crc/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/emac.c"driverlib/sw_crc.h""driverlib/emac.h""inc/hw_emac.h"6144040950x4000ui8PhyAddr < 32ui32Base + EMAC_O_LPICTLSTAT(EMAC_LPICTLSTAT_PLS)4294836223~(EMAC_LPICTLSTAT_PLS)ui32Base == EMAC0_BASE0xFFFFui32TimerValue67043328ui32Base + EMAC_O_LPITIMERCTL0x0ui32Base + EMAC_O_DMARISui32Base + 0x00000C143092ui32Base + EMAC_O_CFG4294967287~EMAC_CFG_TEui32Base + EMAC_O_DMAOPMODEui32Base + 0x00000C1830964294959103~EMAC_DMAOPMODE_STui32Base + EMAC_O_STATUS4294967293~EMAC_DMAOPMODE_SRui32Base + EMAC_O_PMTCTLSTAT(EMAC_PMTCTLSTAT_WUPRX | EMAC_PMTCTLSTAT_MGKPRX |
            EMAC_PMTCTLSTAT_PWRDWN)516518519(EMAC_PMTCTLSTAT_GLBLUCAST | EMAC_PMTCTLSTAT_WUPFREN |
            EMAC_PMTCTLSTAT_MGKPKTEN | EMAC_PMTCTLSTAT_PWRDWN)(EMAC_PMTCTLSTAT_GLBLUCAST | EMAC_PMTCTLSTAT_WUPFREN |
                   EMAC_PMTCTLSTAT_MGKPKTEN | EMAC_PMTCTLSTAT_PWRDWN)4294966776~(EMAC_PMTCTLSTAT_GLBLUCAST | EMAC_PMTCTLSTAT_WUPFREN |
                   EMAC_PMTCTLSTAT_MGKPKTEN | EMAC_PMTCTLSTAT_PWRDWN)~(ui32Flags & ~(EMAC_PMT_GLOBAL_UNICAST_ENABLE | EMAC_PMT_WAKEUP_PACKET_ENABLE | EMAC_PMT_MAGIC_PACKET_ENABLE | EMAC_PMT_POWER_DOWN))ui32Loopui32Base + EMAC_O_RWUFFui32Base + EMAC_O_VLANHASHui32Base + 0x000005881416ui32CRCui32Base + EMAC_O_VLNINCREPui32Base + 0x000005841412~EMAC_VLNINCREP_VLT_Mui32Base + EMAC_O_VLANTG~EMAC_VLANTG_VL_Mui32Base + EMAC_O_PPS0INTVLui32Base + 0x000007601888ui32Base + EMAC_O_PPS0WIDTHui32Base + 0x000007641892ui32Base + EMAC_O_PPSCTRLui32Base + 0x0000072C1836!(ui32Config & (EMAC_PPS_TARGET_INT | EMAC_PPS_TARGET_PPS | EMAC_PPS_TARGET_BOTH))bDigitalui32Base + EMAC_O_TIMSTCTRLui32Base + 0x00000700bDigital || (ui32FreqConfig != EMAC_PPS_1HZ)!bDigital || (ui32FreqConfig != EMAC_PPS_32768HZ)ui32Base + EMAC_O_TIMSTATui32Base + 0x0000072818324294967279~EMAC_TIMSTCTRL_INTTRIGui32Base + EMAC_O_TARGNANOui32Base + 0x000007201824ui32Base + EMAC_O_TARGSECui32Base + 0x0000071C1820ui32Base + EMAC_O_TIMADDui32Base + 0x000007181816ui32Base + EMAC_O_TIMSECUui32Base + 0x000007101808ui32Base + EMAC_O_TIMNANOUui32Base + 0x000007141812ui32Base + EMAC_O_TIMSECui32Base + 0x00000708ui32Base + EMAC_O_TIMNANOui32Base + 0x0000070C18041800~EMAC_TIMSTCTRL_TSENui32Base + EMAC_O_SUBSECINCui32Base + 0x000007041796ui32Base + EMAC_O_CC-2049~EPHY_BMCR_PWRDWN-4097~EPHY_BMCR_ANEN1074708480EMAC0_BASE0x001F164150x401Fui32Base + EMAC_O_MIIADDRui32Base + EMAC_O_MIIDATAui32Incrementui16Value1644916453EMAC_NORMAL_INTS186442954197810170EMAC_ABNORMAL_INTS2147483647~EMAC_INT_PHYui32Base + EMAC_O_EPHYMISCui32Base + 0x00000FD84056ui32Valui32PHYStat5872025673400326606028866977792(EMAC_DMARIS_AE_M | EMAC_DMARIS_TS_M | EMAC_DMARIS_RS_M)4227989503~(EMAC_DMARIS_AE_M | EMAC_DMARIS_TS_M | EMAC_DMARIS_RS_M)ui32Base + EMAC_O_DMAIMui32Base + 0x00000C1C16106127361342177282013265920EMAC_NON_MASKED_INTS3100ui32Base + EMAC_O_EPHYRISui32Base + 0x00000FD040484294901759~EMAC_INT_NORMAL_INT4294934527~EMAC_INT_ABNORMAL_INTui32Base + EMAC_O_EPHYIMui32Base + 0x00000FD44052~EMAC_EPHYIM_INT(ui32IntFlags & ~EMAC_MASKABLE_INTS) == 0pfnHandler != 0~EMAC_CFG_RE167772161048576587284485964595266985984(EMAC_DMARIS_FBI | EMAC_DMARIS_AE_M | EMAC_DMARIS_RS_M |
            EMAC_DMARIS_TS_M)ui32Base + EMAC_O_HOSTXBAui32Base + 0x00000C503152ui32Base + EMAC_O_HOSTXDESCui32Base + 0x00000C483144ui32Base + EMAC_O_TXDLADDRui32Base + 0x00000C103088((uint32_t)pDescriptor & 3) == 0ui32Base + EMAC_O_HOSRXBAui32Base + 0x00000C543156ui32Base + EMAC_O_HOSRXDESCui32Base + 0x00000C4C3148ui32Base + EMAC_O_RXDLADDRui32Base + 0x00000C0C3084ui32Base + EMAC_O_RXPOLLDui32Base + 0x00000C083080ui32Base + EMAC_O_TXPOLLDui32Base + 0x00000C043076ui32Base + EMAC_O_RXINTWDTui32Base + 0x00000C243108ui32Base + EMAC_O_HASHTBLLui32Base + EMAC_O_HASHTBLHui32Base + EMAC_O_FRAMEFLTR214754918421475502082147550720214755097621475510402147551168214755120021475512162147551224214755122821475512302147551231VALID_FRMFILTER_FLAGS2147416064~VALID_FRMFILTER_FLAGS(ui32FilterOpts & ~VALID_FRMFILTER_FLAGS) == 0ui32Base + EMAC_O_ADDRH(ui32Index)ui32Base + (0x00000040 + ((0x0000004C - 0x00000044) * (ui32Index)))105696460832044482564278190080(EMAC_FILTER_BYTE_MASK_M | EMAC_FILTER_ADDR_ENABLE |
            EMAC_FILTER_SOURCE_ADDR)ui32Index < NUM_MAC_ADDRui32Base + EMAC_O_ADDRL(ui32Index)ui32Base + (0x00000044 + ((0x0000004C - 0x00000044) * (ui32Index)))(ui32Config & ~(EMAC_FILTER_BYTE_MASK_M | EMAC_FILTER_ADDR_ENABLE | EMAC_FILTER_SOURCE_ADDR)) == 0NUM_MAC_ADDR(NUM_MAC_ADDR)0xFF805306368335544322046820352419430420510146562052063232205298073620530462722053062656205307084820530749442053076992205307801620530785282053078656205307875220530787682053078771VALID_CONFIG_FLAGS20530787792053078783(VALID_CONFIG_FLAGS | EMAC_CONFIG_TX_ENABLED |
                     EMAC_CONFIG_RX_ENABLED)ui32Base + EMAC_O_WDOGTOui32Base + 0x000000DC22016383102402241888524~VALID_CONFIG_FLAGS~EMAC_WDOGTO_PWE(ui32Config & ~(VALID_CONFIG_FLAGS | EMAC_CONFIG_TX_ENABLED | EMAC_CONFIG_RX_ENABLED)) == 0!ui32RxMaxFrameSize || ((ui32RxMaxFrameSize < 0x4000) && (ui32RxMaxFrameSize > 1522))ui32Base + EMAC_O_PC32212254724026544128SYSCTL_PERIPH_EPHY010000EMAC0_BASE + EMAC_O_CC0x400EC000 + 0x00000FC81074712520~EMAC_CC_CLKEN1000ui32Base + EMAC_O_DMABUSMODui32Base + 0x00000C003072ui32DivEMAC0_BASE + EMAC_O_DMABUSMOD0x400EC000 + 0x00000C0010747115528388608const struct <unnamed>const struct <unnamed>[3]struct <unnamed>[3]const struct <unnamed> *NUM_CLOCK_DIVISORS4294967235~EMAC_MIIADDR_CR_Mui32Base + EMAC_O_MMCRXIMui32Base + 0x0000010C268ui32Base + EMAC_O_MMCTXIMui32Base + 0x00000110272ui32DescSkipSize < 32ui32TxBurst < (32 * 8)ui32RxBurst < (32 * 8)ui32Divisorui32SysClockMaxconst struct <unnamed>[]struct <unnamed>[]g_pi16MIIClockDiv64000000104000000150000000REG_ADDR(x)((x & 0x0FFF))DEV_ADDR(x)((x & 0xF000) >> 12)(sizeof(g_pi16MIIClockDiv) / sizeof(g_pi16MIIClockDiv[0]))EMAC_O_ADDRH(n)(EMAC_O_ADDR0H + (MAC_ADDR_OFFSET * (n)))EMAC_O_ADDRL(n)(EMAC_O_ADDR0L + (MAC_ADDR_OFFSET * (n)))MAC_ADDR_OFFSET(EMAC_O_ADDR1L - EMAC_O_ADDR0L)(EMAC_DMARIS_LPI | EMAC_DMARIS_TT | EMAC_DMARIS_PMT | EMAC_DMARIS_MMC)(EMAC_INT_TX_STOPPED | EMAC_INT_TX_JABBER | EMAC_INT_RX_OVERFLOW | EMAC_INT_TX_UNDERFLOW | EMAC_INT_RX_NO_BUFFER | EMAC_INT_RX_STOPPED | EMAC_INT_RX_WATCHDOG | EMAC_INT_EARLY_TRANSMIT | EMAC_INT_BUS_ERROR)(EMAC_INT_TRANSMIT | EMAC_INT_RECEIVE | EMAC_INT_EARLY_RECEIVE | EMAC_INT_TX_NO_BUFFER)EMAC_MASKABLE_INTS(EMAC_INT_EARLY_RECEIVE | EMAC_INT_BUS_ERROR | EMAC_INT_EARLY_TRANSMIT | EMAC_INT_RX_WATCHDOG | EMAC_INT_RX_STOPPED | EMAC_INT_RX_NO_BUFFER | EMAC_INT_RECEIVE | EMAC_INT_TX_UNDERFLOW | EMAC_INT_RX_OVERFLOW | EMAC_INT_TX_JABBER | EMAC_INT_TX_NO_BUFFER | EMAC_INT_TX_STOPPED | EMAC_INT_TRANSMIT | EMAC_INT_NORMAL_INT | EMAC_INT_ABNORMAL_INT | EMAC_INT_PHY)(EMAC_FRMFILTER_RX_ALL | EMAC_FRMFILTER_VLAN | EMAC_FRMFILTER_HASH_AND_PERFECT | EMAC_FRMFILTER_SADDR | EMAC_FRMFILTER_INV_SADDR | EMAC_FRMFILTER_PASS_NO_PAUSE | EMAC_FRMFILTER_PASS_ALL_CTRL | EMAC_FRMFILTER_PASS_ADDR_CTRL | EMAC_FRMFILTER_BROADCAST | EMAC_FRMFILTER_PASS_MULTICAST | EMAC_FRMFILTER_INV_DADDR | EMAC_FRMFILTER_HASH_MULTICAST | EMAC_FRMFILTER_HASH_UNICAST | EMAC_FRMFILTER_PROMISCUOUS)(EMAC_CONFIG_USE_MACADDR1 | EMAC_CONFIG_SA_INSERT | EMAC_CONFIG_SA_REPLACE | EMAC_CONFIG_2K_PACKETS | EMAC_CONFIG_STRIP_CRC | EMAC_CONFIG_JABBER_DISABLE | EMAC_CONFIG_JUMBO_ENABLE | EMAC_CONFIG_IF_GAP_MASK | EMAC_CONFIG_CS_DISABLE | EMAC_CONFIG_100MBPS | EMAC_CONFIG_RX_OWN_DISABLE | EMAC_CONFIG_LOOPBACK | EMAC_CONFIG_FULL_DUPLEX | EMAC_CONFIG_CHECKSUM_OFFLOAD | EMAC_CONFIG_RETRY_DISABLE | EMAC_CONFIG_AUTO_CRC_STRIPPING | EMAC_CONFIG_BO_MASK | EMAC_CONFIG_DEFERRAL_CHK_ENABLE | EMAC_CONFIG_PREAMBLE_MASK)// Read the extended register value.// Set the address of the register we're about to read.// Parameter sanity check.//! \return Returns the 16-bit value read from the PHY.//! \e ui16RegAddr.//! this function returns the contents of the MMD register specified by//! When connected to an external PHY supporting extended registers, this//! accessed.//! \param ui16RegAddr is the address of the PHY extended register to be//! \param ui8PhyAddr is the physical address of the PHY to access.//! Reads from an extended PHY register in MMD address space.// Write the extended register value.// Set the address of the register we're about to write.//! register specified by \e ui16RegAddr.//! address space, this function allows a value to be written to the MMD//! When uhen connected to an external PHY supporting extended registers in MMD//! \param ui16Value is the value to write to the register.//! Writes a value to an extended PHY register in MMD address space.// Configure the LPI Control registers.//! link is lost due to a disconnect or EEE mode link is not established.//! This function is used to clear the link status of the external PHY when the//! Clears the link status of the external PHY.//! link is established in EEE mode.//! This function is used to set the link status of the external PHY when the//! Sets the link status of the external PHY.//! \return Returns the lower 16 bits of the LPI Control and Status register.//! path when the link is configured in LPI mode.//! This function may be used to read the status of the transmit and receive//! Returns the status of the LPI link.//! is no more data to be transmitted by the MAC controller.//! This function is used to enable the transmit path in LPI mode when there//! Enables the transmit path for LPI mode entry.// Update the LPI Timer.//! path must be automated or should be under user control.//! timer value. The parameter \e bLPIConfig is used to decide if the transmit//! status timer value and \e ui16LPITWTimer is programmed as the transmit wait //! is established as EEE, then \e ui16LPILSTimer is programmed as the link//! the link is established as EEE mode or when the link is lost. When the link//! This function is used to configure the LPI timer and control registers when//! \param ui16LPITWTimer is the value of TW timer in micro-seconds.//! \param ui16LPILSTimer is the value of LS timer in milli-seconds.//! \param bLPIConfig is state of LPI trasnmit automate bit.//! Configures the LPI timers and control register.// Disable the MAC receive path.// Check if the Receive FIFO is empty.// Disable the MAC transmit path in the opmode register.// Disable transmission in the MAC configuration register.// Check if the Transmit interrupt bit is clear.//! disables the receive DMA controller.//! if any data from the network is being actively received and if not then it//! disabling the trasnmitter and the transmit DMA controller. Then it checks//! controller. It is done by first checking if the transmit path is idle and//! This function is used to enable the wake-on-LAN feature of the MAC//! Enables the wake-on-LAN feature of the MAC controller.// them to the caller.// Read the control/status register and mask off the status bits to return//! function call clears this flag.//! power-down mode due to a wake-on-LAN magic packet being received.  This//! - \b EMAC_PMT_MAGIC_PACKET_RECEIVED indicates that the MAC exited//! power-down mode due to a remote wake-up frame being received.  This//! - \b EMAC_PMT_WAKEUP_PACKET_RECEIVED indicates that the MAC exited//! mode.//! - \b EMAC_PMT_POWER_DOWN indicates that the MAC is currently in power-down//! \return Returns a logical OR of the following flags://! to exit power-down state.//! returned value indicates the type of received frame that caused the MAC//! Ethernet MAC. If the MAC has been woken up since the last call, the//! This function returns information on the remote wake-up state of the//! Queries the current Ethernet MAC remote wake-up status.// Read the control/status register and mask off the control bits to return//! filter.//! frames as described by other returned flags and via the remote wake-up//! mode and is  waiting for an incoming frame matching the remote wake-up//! MAC address.//! 6 bytes of 0xFF followed immediately by 16 repetitions of the destination//! standard Wake-on-LAN "magic packet" is received.  The magic packet contains//! - \b EMAC_PMT_MAGIC_PACKET_ENABLE indicates that the MAC wakes up when a//! to EMACRemoteWakeUpFrameFilterSet().//! received frame matches the remote wake-up filter configured via a call//! - \b EMAC_PMT_WAKEUP_PACKET_ENABLE indicates that the MAC wakes up when any//! any unicast frame matching the MAC destination address filter is received.//! - \b EMAC_PMT_GLOBAL_UNICAST_ENABLE indicates that the MAC wakes up when//! wake-up event//! These settings determine which types of frame should trigger a remote//! This function allows the MAC's remote wake-up settings to be queried.//! Queries the current Ethernet MAC remote wake-up configuration.// in the new values then rewrite the new register value.// Read the control/status register, clear all the bits we can set, mask//! exiting via another call to this function.//! to determine the interrupt status and also prevents power-down mode from//! power-down mode, doing so prevents the reading of the registers required//! \note While it is possible to gate the clock to the MAC while it is in//! the status using EMACPowerManagementStatusGet().//! \b EMAC_INT_POWER_MGMNT interrupt is signaled and may be cleared by reading//! If a configured wake-up frame is received while in power-down mode, the//! this function with the \b EMAC_PMT_POWER_DOWN flag absent from \e ui32Flags.//! When the MAC is in power-down mode, software may exit the mode by calling//! frame type.//! set set if at least one other flag is specified to configure a wake-up//! by other flags and via the remote wake-up filter.  This flag should only//! wait for an incoming frame matching the remote wake-up frames as described//! - \b EMAC_PMT_POWER_DOWN instructs the MAC to enter power-down mode and//! - \b EMAC_PMT_MAGIC_PACKET_ENABLE instructs the MAC to wake up when a//! - \b EMAC_PMT_WAKEUP_PACKET_ENABLE instructs the MAC to wake up when any//! unicast frame matching the MAC destination address filter is received.//! - \b EMAC_PMT_GLOBAL_UNICAST_ENABLE instructs the MAC to wake up when any//! The \e ui32Flags parameter is a logical OR of the following flags://! automatically exits power-down mode and continues to receive frames.//! configured remote wake-up frame is received, at which point the MAC//! mode, the MAC ignores all received frames until one matching a//! allowing an application to place the MAC in power-down mode.  In this//! determining which types of frame should trigger a wake-up event and//! This function allows the MAC's remote wake-up features to be configured,//! wake-up and allows the MAC to be put into power-down mode.//! \param ui32Flags defines which types of frame should trigger a remote//! Sets the Ethernet MAC remote wake-up configuration.// Read a word of the filter definition.// Read the 8 words of the wake-up filter definition from the hardware.// Get a word pointer to the supplied structure.// is reset.  This bit automatically resets after 1 clock cycle.// Make sure that the internal register counter for the frame filter//! checksums.//! Note that this filter uses CRC16 rather than CRC32 as used in frame//! frame is considered to be a valid remote wake-up frame.//! values provided and the final CRC calculation equals this value, the//! wake-up frame.  If the incoming frame is processed according to the filter//! - \b pui16CRC provides the value of the calculated CRC for a valid remote//! in \b pui32ByteMask.//! frame that the MAC skips before accumulating the CRC based on the pattern//! Alternatively, this value can be thought of as the number of bytes in the//! at which CRC checking defined by \b pui32ByteMask begins.//! - \b pui8Offset defines the zero-based index of the byte within the frame//! \b EMAC_RWU_FILTER_DISABLE.//! EMAC_RWU_FILTER_UNICAST ORed with one of \b EMAC_RWU_FILTER_ENABLE or//! values are one of \b EMAC_RWU_FILTER_MULTICAST or \b//! and, if so, whether it refers to unicast or multicast packets.  Valid//! - \b pui8Command contains flags defining whether this filter is enabled//! causes the byte to be skipped.//! A 1 indicates that the byte should contribute to the calculation, a 0//! sequence within the frame should contribute to the CRC calculation or not.//! - \b pui32ByteMask defines whether a given byte in the chosen 31-byte//! times, once for each possible wake-up frame://! structure contains the following fields, each of which is replicated 4//! structure containing the information defining the frame filters.  This//! The \e pFilter parameter points to storage that is written with a//! the first byte in the 31-byte CRC-checked sequence.//! an offset from the start of the frame to the payload byte that represents //! CRC calculation and a ``0'' indicates that the byte should be skipped, and//! where a ``1'' indicates that a byte in the frame should contribute to the//! actual bytes used in the CRC calculation are defined by means of a bit mask//! terms of a CRC calculated on up to 31 payload bytes in the frame.  The//! settings.  The data returned by the function describes wake-up frames in//! This function may be used to read the current wake-up frame filter//! remote wake-up frame filter information.//! \param pFilter points to the structure that is written with the current//! Returns the current remote wake-up frame filter configuration.// Write a word of the filter definition.// Write the 8 words of the wake-up filter definition to the hardware.//! found at http://www.zorc.breitbandkatze.de/crc.html.//! for use in this function may be determined using the online calculator//! initial seed value 0xFFFF, no final XOR and reversed data order.  CRCs//! checksums. The required CRC uses a direct algorithm with polynomial 0x8005,//! frame that the MAC skips before accumulating the CRC based on the pattern  //! frame://! fields, each of which is replicated 4 times, once for each possible wake-up//! necessary to set up the filters.  This structure contains the following//! The \e pFilter parameter points to a structure containing the information//! as an offset from the start of the frame to the payload byte that represents //! calculation and a ``0'' indicates that the byte should be skipped, as well //! indicates that a byte in the frame should contribute to the CRC//! in the CRC calculation are defined by means of a bit mask where a ``1''//! calculated on up to 31 payload bytes in the frame.  The actual bytes used//! data passed to the function describes a wake-up frame in terms of a CRC//! are considered by the Ethernet MAC to be remote wake-up signals.  The//! This function may be used to define up to four different frames that//! filter information.//! \param pFilter points to the structure containing remote wake-up frame//! Sets values defining up to four frames used to trigger a remote wake-up.// Return the VLAN Hash Table register.//! \return Returns the current value of the VLAN hash filter.//! calling EMACVLANHashFilterSet() to set the new filter value.//! bits, determined by calling EMACVLANHashFilterBitCalculate(), and then//! Additional VLAN tags may be added to this filter by setting the appropriate//! This function allows the current VLAN tag hash filter value to be returned.//! VLAN-tagged frames.//! Returns the current value of the hash filter used to control reception of// Write the VLAN Hash Table register.//! tags and hash filter bits.//! due to the fact that there is a many-to-one correspondence between VLAN//! that function.  Care must be taken when clearing bits in the hash filter//! filter and then set each of the bits for which the numbers are returned by//! EMACVLANHashFilterBitCalculate() for each VLAN tag that is to pass the//! The hash filter value passed in \e ui32Hash may be built up by calling//! cost of some false positive results that must be removed by software.//! filtering, several different VLAN tags can be filtered very easily at the//! This function allows the VLAG tag hash filter to be set.  By using hash//! \param ui32Hash is the hash filter value to set.//! Sets the hash filter used to control reception of VLAN-tagged frames.// Return the final hash filter bit index.// Reverse the order of the bottom 4 bits of the calculated CRC.// CRC with the bit order of those 4 bits reversed).// top 4 bits of the reversed CRC (or the bottom 4 bits of the calculated// Determine the hash bit to use from the calculated CRC.  This is the// Calculate the CRC for the MAC address.//! the passed tag.//! \return Returns the bit number to set in the VLAN hash filter to describe//! 2 of the hash filter must be set to pass the supplied VLAN tag.//! hash filter. For example, if 0x02 is returned, this indicates that bit//! a 4-bit value indicating the bit number to set within the 16-bit VLAN//! to set to describe a given 12- or 16-bit VLAN tag.  The returned value is//! This function may be used to determine which bit in the VLAN hash filter//! be determined.//! \param ui16Tag is the VLAN tag for which the hash filter bit number is to //! given tag.//! Returns the bit number to set in the VLAN hash filter corresponding to a// Return the configuration flags.// Extract the tag.// Read the VLAN Tag Inclusion or Replacement register.//! value returned in \e *pui16Tag.//! the VLAN tag in all transmitted frames of type 0x8100 or 0x88A8 with the//! - \b EMAC_VLAN_TX_VLC_REPLACE indicates that the transmitter is replacing//! they already contain a VLAN tag.//! a VLAN type and tag into all outgoing frames regardless of whether or not//! - \b EMAC_VLAN_TX_VLC_INSERT indicates that the transmitter is inserting//! VLAN tags from all transmitted frames which contain them.//! - \b EMAC_VLAN_TX_VLC_DELETE indicates that the transmitter is removing//! performing VLAN tag insertion, deletion or replacement.//! - \b EMAC_VLAN_TX_VLC_NONE indicates that the transmitter is not//! EMAC_VLAN_TX_VLC_MASK.//! value may be extracted from the return value using the mask \b//! is also included to define the transmit VLAN tag handling.  Note that this//! If \b EMAC_VLAN_TX_USE_VLC is returned, one of the following four labels//! descriptor.//! this tag is absent, VLAN handling is controlled by fields in the transmit//! VLAN frames according to the VLAN control (VLC) value returned here.  If//! - \b EMAC_VLAN_TX_USE_VLC indicates that the transmitter is processing//! this label is absent, C-VLAN type (0x8100) is being used.//! being used when inserting or replacing tags in transmitted frames.  If//! - \b EMAC_VLAN_TX_SVLAN indicates that the S-VLAN type (0x88A8) is//! to frame transmission.  The return value is a logical OR of the following//! \return Returns flags describing the current VLAN configuration relating//! \sa EMACVLANTxConfigSet()//! tagging of transmitted frames.//! This function returns information on the current settings related to VLAN//! currently being used for insertion or replacement.//! \param pui16Tag points to storage that is written with the VLAN tag//! frames.//! Returns currently-selected options related to transmission of VLAN-tagged// Write the VLAN Tag Inclusion or Replacement register.//! this function in the \e ui16Tag parameter.//! VLAN tag in all frames of type 0x8100 or 0x88A8 with the value provided to//! - \b EMAC_VLAN_TX_VLC_REPLACE instructs the transmitter to replace the//! already contain a VLAN tag.//! type and tag into all outgoing frames regardless of whether or not they//! - \b EMAC_VLAN_TX_VLC_INSERT instructs the transmitter to insert a VLAN//! 13, 14, 15 and 16 are removed from all frames with types 0x8100 or 0x88A8.//! tags from all transmitted frames that contain them.  As a result, bytes//! - \b EMAC_VLAN_TX_VLC_DELETE instructs the transmitter to remove VLAN//! tag insertion, deletion or replacement.//! - \b EMAC_VLAN_TX_VLC_NONE instructs the transmitter to perform no VLAN//! must also be included to define the transmit VLAN tag handling://! If \b EMAC_VLAN_TX_USE_VLC is set, one of the following four labels//! by fields in the transmit descriptor.//! this function call.  If this tag is absent, VLAN handling is controlled//! handling should be defined by the VLAN control (VLC) value provided in//! - \b EMAC_VLAN_TX_USE_VLC informs the transmitter that the VLAN tag//! type (0x8100) is used.//! replacing tags in transmitted frames.  If this label is absent, C-VLAN//! - \b EMAC_VLAN_TX_SVLAN uses the S-VLAN type (0x88A8) when inserting or//! following labels://! tagged frames.  The \e ui32Config parameter is a logical OR of the//! The \e ui16Tag parameter contains the VLAN tag to be used in outgoing//! into untagged frames or replace existing tags with new values.//! IEEE 802.1Q VLAN tagging.  The transmitter may be set to insert tagging//! This function is used to configure transmitter options relating to//! the transmitter.//! \param ui32Config determines the VLAN-related processing performed by//! in transmitted frames.//! \param ui16Tag is the VLAN tag to be used when inserting or replacing tags//! Sets options related to transmission of VLAN-tagged frames.// Extract the VLAN tag from the register.// Read the VLAN tag register.//! 0x8100 or 0x88A8 regardless of the tag values they contain.//! all bottom 12 bits clear, the receiver passes all frames with types//! tag are examined when filtering.  If this flag is set and \e *pui16Tag has//! filtering of VLAN frames.  If this flag is absent, all 16 bits of the frame//! the bottom 12 bits of \e *pui16Tag when performing either perfect or hash//! - \b EMAC_VLAN_RX_12BIT_TAG indicates that the receiver is comparing only//! this flag is absent, only tagged frames matching \e *pui16Tag are passed.//! VLAN frames for which the tags do not match the \e *pui16Tag value.  If //! - \b EMAC_VLAN_RX_INVERSE_MATCH indicates that the receiver passes all//! frames with type 0x8100 are considered valid VLAN frames.//! S-VLAN (Type = 0x88A8) frames as valid VLAN-tagged frames.  If absent, only//! - \b EMAC_VLAN_RX_SVLAN_ENABLE indicates that the receiver recognizes//! returned in \e *pui16Tag is performed.//! for VLAN tags.  If this flag is absent, perfect filtering using the tag//! - \b EMAC_VLAN_RX_HASH_ENABLE indicates that hash filtering is enabled//! value is a logical OR of the following flags://! \return Returns flags defining how VLAN-tagged frames are handled.  The//! \sa EMACVLANRxConfigSet()//! handling IEEE 802.1Q VLAN-tagged frames.//! This function returns information on how the receiver is currently//! configured VLAN tag used for perfect filtering.//! \param pui16Tag points to storage which is written with the currently//! Returns the currently-set options related to reception of VLAN-tagged// Write the VLAN tag register.//! \sa EMACVLANRxConfigGet()//! indicating that the packet did not match the current VLAG tag filter.//! application, but bit 10 of RDES0 (\b EMAC_FRMFILTER_VLAN) is clear//! this flag is not set, failing VLAN packets are received by the//! EMAC_FRMFILTER_VLAN flag set in the \e ui32FilterOpts parameter.  If//! by the MAC, EMACFrameFilterSet() must be called with the \b//! \note To ensure that VLAN frames that fail the tag filter are dropped//! tag are examined when filtering.  If this flag is set and \e ui16Tag has//! bottom 12 bits of \e ui16Tag when performing either perfect or hash//! - \b EMAC_VLAN_RX_12BIT_TAG causes the receiver to compare only the//! this flag is absent, only tagged frames matching \e ui16Tag are passed.//! frames for which the tags do not match the supplied \e ui16Tag value.  If //! - \b EMAC_VLAN_RX_INVERSE_MATCH causes the receiver to pass all VLAN//! (Type = 0x88A8) frames as valid VLAN-tagged frames.  If absent, only//! - \b EMAC_VLAN_RX_SVLAN_ENABLE causes the receiver to recognize S-VLAN//! to set in the filter for given VLAN tags.//! and EMACVLANHashFilterBitCalculate() may be used to determine which bits//! is performed.  The hash filter may be set using EMACVLANHashFilterSet(),//! this flag is absent, perfect filtering using the tag supplied in \e ui16Tag//! - \b EMAC_VLAN_RX_HASH_ENABLE enables hash filtering for VLAN tags.  If//! The \e ui32Config parameter is a logical OR of the following values://! VLAN ID portion of the tag.//! rejected.  The tag comparison may involve all 16 bits or only the 12-bit//! tagged with the value of \e ui16Tag pass the filter and all others are//! filter or a hash filter.  When hash filtering is disabled, VLAN frames//! tagged frames.  Incoming tagged frames are filtered using either a perfect//! This function configures the receiver's handling of IEEE 802.1Q VLAN//! \param ui32Config determines how the receiver handles VLAN-tagged frames.//! \param ui16Tag is the IEEE 802.1Q VLAN tag expected for incoming frames.//! Sets options related to reception of VLAN-tagged frames.// Write the desired PPS period and pulse width.//! EMACTimestampConfigSet().//! by the subsecond increment value passed in the \e ui32SubSecondInc to//! increments the actual system time, queried using EMACTimestampSysTimeGet()//! EMACTimestampAddendSet().  Regardless of the tick source, each tick//! and this, in turn, is determined by the value passed to the function//! mode, a tick occurs every time the 32-bit system time accumulator overflows//! update mode, each tick is equivalent to the system clock.  In fine update//! system time update ticks.  When the system time is operating in coarse//! The \e ui32Period and \e ui32Width parameters are expressed in terms of//! \e ui32FreqConfig parameter passed to EMACTimestampPPSSimpleModeSet().//! In simple mode, the PPS output signal frequency is controlled by the//! EMACTimestampPPSCommandModeSet().//! executed.  Command mode is selected by calling//! operating in command mode and a command to send one or more pulses has been//! signal output on the Ethernet MAC PPS pin when the PPS generator is//! This function may be used to control the period and duty cycle of the//! expressed in terms of system time update ticks.//! \param ui32Width is the width of the high portion of the PPS output//! system time update ticks.//! \param ui32Period is the period of the PPS output expressed in terms of//! Sets the period and width of the pulses on the Ethernet MAC PPS output.// Write the command to the PPS control register.// Wait a bit.// Wait for any previous command write to complete.//! EMACTimestampTargetSet().//! Target times associated with PPS commands are set by calling//! by the \e ui32Period parameter passed to the same function.//! command starts a train of pulses, the period of the pulses is governed//! \e ui32Width parameter passed to EMACTimestampPPSPeriodSet().  If a//! In all cases, the width of the pulses generated is governed by the//! the system time has not yet reached the programmed target time.//! - \b EMAC_PPS_COMMAND_CANCEL_STOP cancels any pending stop command if//! should be stopped immediately.//! - \b EMAC_PPS_COMMAND_STOP_NOW indicates that the current pulse train//! time.//! train should be stopped when the system time reaches the current target//! - \b EMAC_PPS_COMMAND_STOP_AT_TIME indicates that the current pulse//! - \b EMAC_PPS_COMMAND_CANCEL_START cancels any pending start command if//! should be started when the system time reaches the current target time.//! - \b EMAC_PPS_COMMAND_START_TRAIN indicates that a train of pulses//! should be generated when the system time reaches the current target time.//! - \b EMAC_PPS_COMMAND_START_SINGLE indicates that a single high pulse//! - \b EMAC_PPS_COMMAND_NONE indicates no command.//! commands are as follow://! is selected by calling EMACTimestampPPSCommandModeSet(). Valid//! Second) controller when it is operating in command mode.  Command mode//! This function may be used to send a command to the MAC PPS (Pulse Per//! \param ui8Cmd identifies the command to be sent.//! Sends a command to control the PPS output from the Ethernet MAC.// clearing the command in the PPSCTRL field.// PPSEN0 bit to ensure that the PPS engine is in command mode and// Write the configuration value to the PPS control register, setting the//! pulse train to be started at the required time.//! - EMACTimestampPPSCommand() to send a command to cause the pulse or//! executed, and finally//! - EMACTimestampTargetSet() to set the time at which the next command is//! then//! - EMACTimestampPPSPeriodSet() to set the desired pulse width and period//! mode, then call://! To use command mode, an application must call this function to enable the//! pending PPS command and also raise an interrupt.//! - \b EMAC_PPS_TARGET_BOTH configures the target time to trigger any//! PPS command but not raise an interrupt.//! - \b EMAC_PPS_TARGET_PPS configures the target time to trigger a pending//! an interrupt and not to trigger any pending PPS command.//! - \b EMAC_PPS_TARGET_INT configures the target time to only raise//! to the CPU.  Valid values are://! time is used to trigger commands only or can also generate an interrupt//! The \e ui32Config parameter may be used to control whether the target//! at specific times using the target time last set using a call to//! ticks of the clock used to update the system time.  Commands are triggered//! this mode, the pulse width and period may be set arbitrarily based on//! engine to send individual pulses or start and stop trains if pulses.  In//! allows complex pulse trains to be generated using commands that tell the//! may be too restrictive for some applications.  The second mode, however,//! The simple mode of operation offered by the PPS (Pulse Per Second) engine//! \param ui32Config determines how the system target time is used.//! Configures the Ethernet MAC PPS output in command mode.// the default operation of the target time registers.// waiting for a command.  We also clear the TRGMODS0 field to revert to// the PPSEN0 bit to ensure that the PPS engine is in simple mode and not// Write the frequency control value to the PPS control register, clearing// in digital mode.// where the control value generates an output that is twice as fast as// Adjust the supplied frequency if we are currently in binary update mode// 32KHz output when we are digital rollover mode.// 1Hz output when we are in binary rollover mode and can't produce a// Weed out some unsupported frequencies.  The hardware can't produce a// Are we currently running the clock in digital or binary rollover mode?//! period followed by a fourth clock of 195 ms period, 134 ms low and 61 ms high.//! output generates three clocks with 50 percent duty cycle and 268 ms//! example, if \b EMAC_PPS_4HZ is selected in digital rollover mode, the//! averages the value requested and is resynchronized each second.  For//! system time subsecond count.  In digital mode, the output frequency//! on PPS has a duty cycle of 50% when binary rollover mode is used for the//! Except when \b EMAC_PPS_SINGLE_PULSE is specified, the signal generated//! configured to operate in digital rollover mode.//! option is not available if the system time subsecond counter is currently//! - \b EMAC_PPS_32768HZ generates a 32KHz signal on the PPS output.  This//! frequency on the PPS output in both binary and digital rollover modes.//!   \b EMAC_PPS_8192HZ, \b EMAC_PPS_16384HZ generate the requested//!   \b EMAC_PPS_1024HZ, \b EMAC_PPS_2048HZ, \b EMAC_PPS_4096HZ,//!   \b EMAC_PPS_128HZ, \b EMAC_PPS_256HZ, \b EMAC_PPS_512HZ,//!   \b EMAC_PPS_16HZ, \b EMAC_PPS_32HZ, \b EMAC_PPS_64HZ,//! - \b EMAC_PPS_2HZ, \b EMAC_PPS_4HZ, \b EMAC_PPS_8HZ,//! configured to operate in binary rollover mode.//! is not available if the system time subsecond counter is currently//! - \b EMAC_PPS_1HZ generates a 1Hz signal on the PPS output.  This option//! period.//! output once per second.  The pulse width is the same as the system clock//! - \b EMAC_PPS_SINGLE_PULSE generates a single high pulse on the PPS//! The \e ui32FreqConfig parameter may take one of the following values://! PPS control mode that can be selected by calling//! train generation is required, the MAC also provides a command-based//! frequencies and pulse widths on the PPS pin.  If more complex pulse//! operate in its simple mode which allows the generation of a few, fixed//! This function configures the Ethernet MAC PPS (Pulse Per Second) engine to//! the PPS pin.//! \param ui32FreqConfig determines the frequency of the output generated on//! Configures the Ethernet MAC PPS output in simple mode.// Return the current interrupt status from the timestamp module.//! EMACTimestampTargetIntEnable().//! using calls to EMACTimestampTargetSet() and//! this occurs, a new target time may be set and the interrupt re-enabled//! past the value set in an earlier call to EMACTimestampTargetSet().  When//! - \b EMAC_TS_INT_TARGET_REACHED indicates that the system time incremented//! hardware timer has rolled over.//! - \b EMAC_TS_INT_TS_SEC_OVERFLOW indicates that the second counter in the//! \b EMAC_TS_INT_TS_SEC_OVERFLOW and \b EMAC_TS_INT_TARGET_REACHED.//! \return The return value is the logical OR of the values//! timer interrupt status.//! bu EMACIntStatus(), this function must be called to read and clear the//! When an Ethernet interrupt occurs and \b EMAC_INT_TIMESTAMP is reported//! Reads the status of the Ethernet system time interrupt.// disabled if you want to cancel a previously-set interrupt.// clears automatically when the interrupt fires, so it only must be// Clear the bit to disable the timestamp target interrupt.  This bit //! and EMACTimestampTargetIntEnable().//! interrupt previously scheduled using calls to EMACTimestampTargetSet()//! This function may be used to disable any pending Ethernet system time//! Disables the Ethernet system time interrupt.// set a new target time and re-enable the interrupts.// automatically when the interrupt fires after which point, you must// Set the bit to enable the timestamp target interrupt.  This bit clears//! Ethernet interrupt with status \b EMAC_INT_TIMESTAMP is generated.//! interrupt.  When the system time increments past the target time, an//! to set the desired time, then EMACTimestampTargetIntEnable() to enable the//! an interrupt when the system time exceeds a given value, call this function//! the IEEE 1588 time as returned by EMACTimestampSysTimeGet().  To generate//! interrupt at some future time.  The time reference for the function is//! This function may be used after EMACTimestampTargetSet() to schedule an//! Enables the Ethernet system time interrupt.// Write the new target time.// Wait for any previous write to complete.//! system time to be greater than or equal to the target time set.//! interrupt is generated on the first timer increment that causes the//! update frequency and the subsecond increment value currently in use.  The//! The accuracy of the interrupt timing depends on the Ethernet timer//! status \b EMAC_INT_TIMESTAMP is generated.//! system time increments past the target time, an Ethernet interrupt with//! then EMACTimestampTargetIntEnable() to enable the interrupt.  When the//! time exceeds a given value, call this function to set the desired time,//! EMACTimestampSysTimeGet().  To generate an interrupt when the system//! The time reference for the function is the IEEE 1588 time as returned by//! This function may be used to schedule an interrupt at some future time.//! \param ui32SubSeconds is the subseconds value of the desired target time.//! \param ui32Seconds is the second value of the desired target time.//! generated.//! Sets the target system time at which the next Ethernet timer interrupt is// Force the system clock to update by the value provided.// Spin for a while.// Wait for any previous update to complete.//! \sa EMACTimestampConfigSet()//! finely control the system time rate.//! overflows, small changes in the \e ui32Increment value can be used to very//! oscillator tick.  Because the system time updates each time the accumulator//! would be set to 0x80000000 to generate a carry on every second main//! the 12.5-MHz clock period of 80 ns, the initial \e ui32Increment value//! a previous call to EMACTimestampConfigSet() with \e ui32SubSecondInc set to//! clock with a desired IEEE 1588 clock accuracy of 12.5 MHz, and having made//! As an example, using digital rollover mode and a 25-MHz main oscillator//! clock rate.//! \e ui32SubSecondInc value is set to correspond to the desired IEEE 1588//! the main oscillator clock rate and the desired IEEE 1588 clock rate and the//! the timestamp counter.  The addend value is calculated using the ratio of//! addend value is modified to allow fine control over the rate of change of//! incremented by the "addend" value on each main oscillator tick, and this//! 32-bit accumulator register generates a carry.  The accumulator register is//! EMACTimestampConfigSet() in the \e ui32SubSecondInc parameter each time a//! clock.  The subsecond counter is incremented by the number passed to//! typically used when synchronizing the local clock to the IEEE 1588 master//! to a previous call to EMACTimestampConfigSet().  Fine update mode is//! \e EMAC_TS_UPDATE_FINE is supplied in the \e ui32Config parameter passed//! when in fine update mode.  Fine correction mode is selected if//! This function is used to control the rate of update of the system time//! each tick of the 25-MHz main oscillator.//! \param ui32Increment is the number to add to the accumulator register on//! Adjusts the system time update rate when using the fine correction method.// Write the new time to the system time update registers.//! specified instead, a subsecond bit represents 0.46 ns.//! subsecond value represents 1 ns. If \e EMAC_TS_BINARY_ROLLOVER was//! the \e EMAC_TS_DIGITAL_ROLLOVER configuration option, each bit in the//! configuration.  If EMACTimestampConfigSet() was previously called with//! The meaning of \e ui32SubSeconds depends on the current system time//! by the interval.//! advanced by the interval given.  When it is \e false, the time is retarded//! by the \e bInc parameter.  When \e bInc is \e true, the system time is//! the \e ui32Seconds and \e ui32SubSeconds parameter and the direction//! or downwards by a given amount.  The size of the adjustment is given by//! This function may be used to adjust the current system time either upwards//! \param bInc defines the direction of the update.//! \param ui32SubSeconds is the subseconds value of the time update to apply.//! \param ui32Seconds is the seconds value of the time update to apply.//! Adjusts the current system time upwards or downwards by a given amount.// the registers across a nanosecond wrap.// registers.  We do this in a way that should guard against us reading// Read the two-part system time from the seconds and nanoseconds//! specified instead, a \e ui32SubSeconds bit represents 0.46 ns.//! \e ui32SubSeconds value represents 1 ns. If \e EMAC_TS_BINARY_ROLLOVER was//! This function may be used to get the current system time.//! \param pui32SubSeconds points to storage for the current subseconds value.//! \param pui32Seconds points to storage for the current seconds value.//! Gets the current system time.// Force the system clock to reset.//! \e ui32SubSeconds parameters.//! clock is set to the value passed in the \e ui32Seconds and//! This function may be used to set the current system time.  The system//! setting.//! \param ui32SubSeconds is the subseconds value of the new system clock//! \param ui32Seconds is the seconds value of the new system clock setting.//! Sets the current system time.// Disable IEEE 1588 timestamping.//! Ethernet frames and to disable timestamping.//! This function is used to stop the system clock used to timestamp//! Disables packet timestamping and stops the system clock.// currently ongoing.// once the system time is loaded.  Only do this if initialization is not// If necessary, initialize the timestamping system.  This bit self-clears// Enable IEEE 1588 timestamping.//! Ethernet frames and to enable that timestamping.//! This function is used to enable the system clock used to timestamp//! Enables packet timestamping and starts the system clock running.// Return the current timestamp configuration.// Read the current subsecond increment value.//! SYNC, Follow_Up, Delay_Req and Delay_Resp messages only.//! of PTP packets to timestamp are set, the MAC is configured to timestamp//! If \b EMAC_TS_ALL_RX_FRAMES and none of the options specifying subsets//! frames received by the MAC, regardless of type.//! - \b EMAC_TS_ALL_RX_FRAMES indicates that timestamping is enabled for all//! these frames.//! directly in Ethernet frames are being processd.  If absent, the MAC ignores//! - \b EMAC_TS_PROCESS_ETHERNET indicates that PTP packets encapsulated//! UDP over IPv6 packets are being processed.  If absent, the MAC ignores//! - \b EMAC_TS_PROCESS_IPV6_UDP indicates that PTP packets encapsulated in//! UDP over IPv4 packets are being processed.  If absent, the MAC ignores//! - \b EMAC_TS_PROCESS_IPV4_UDP indicates that PTP packets encapsulated in//! for Pdelay_Req and Pdelay_Resp messages.//! - \b EMAC_TS_PDREQ_PDRESP indicates that timestamps are only generated//! for Delay_Req messages.//! - \b EMAC_TS_SYNC_DELAYREQ indicates that timestamps are only generated//! generated for Delay_Req, Pdelay_Req and Pdelay_Resp messages.//! - \b EMAC_TS_DREQ_PDREQ_PDRESP indicates that timestamps are only//! Pdelay_Resp messages.//! - \b EMAC_TS_SYNC_PDREQ_PDRESP timestamps only SYNC, Pdelay_Req and//! IEEE 1588 messages.//! - \b EMAC_TS_ALL indicates that timestamps are generated for all//! - \b EMAC_TS_DELAYREQ_ONLY indicates that timestamps are only generated//! SYNC messages.//! - \b EMAC_TS_SYNC_ONLY indicates that timestamps are only generated for//! value on each system clock tick.//! method is in use and the clock is advanced by the \e *pui32SubSecondInc//! addend accumulator register.  If this flag is absent, the coarse update//! \e *pui32SubSecondInc parameter each time a carry is generated from the//! IEEE 1588 clock to advance by the the value returned in the//! - \b EMAC_TS_UPDATE_FINE implements the fine update method that causes the //! others are discarded.  If this flag is absent, the MAC address is ignored.//! destination address programmed into the MAC address filter are passed,//! are filtered using any of the configured MAC addresses.  Messages with a//! - \b EMAC_TS_MAC_FILTER_ENABLE indicates that incoming PTP messages//! increments of 0.465 ns.//! absent, the subsecond value rolls over at 0x7FFFFFFF, effectively counting//! as a nanosecond counter with each digit representing 1 ns.  If this flag is//! over at 0x3BA9C9FF (999999999 decimal). In this mode, it can be considered//! - \b EMAC_TS_DIGITAL_ROLLOVER causes the clock's subsecond value to roll//! expected.//! version 2 messages.  If this flag is absent, PTP version 1 messages are//! - \b EMAC_TS_PTP_VERSION_2 indicates that the MAC is processing PTP//! the following flags://! \return Returns the current timestamping configuration as a logical OR of//! This function may be used to retreive the current MAC timestamping//! current subsecond increment value for the IEEE 1588 clock.//! \param pui32SubSecondInc points to storage that is written with the//! Returns the current IEEE 1588 timestamping configuration.// Set the timestamp configuration.// Write the subsecond increment value.// Ensure that the PTP module clock is enabled.//! \sa EMACTimestampAddendSet()//! second system clock.//! set the initial addend value to 0x80000000 to generate a carry on every//! we would set \e ui32SubSecondInc to the 12.5-MHz clock period of 80 ns and//! main oscillator clock with a desired IEEE 1588 clock accuracy of 12.5 MHz,//! clock rate.  As an example, using digital rollover mode and a 25-MHz//! incremented by the addend value on each main oscillator tick and this//! accumulator register generates a carry.  The accumulator register is//! counter is incremented by \e ui32SubSecondInc counts each time a 32-bit//! synchronizing the local clock to the IEEE 1588 master clock.  The subsecond//! lower than the system clock rate.  Fine update mode is typically used when//! to the desired accuracy of the recovered IEEE 1588 clock which must be//! In fine update mode, the subsecond increment value must be set according//! rollover mode.//! if digital rollover mode is selected or (40 / 0.465) = 86 in binary//! example, if the main oscillator is 25 MHz, \e ui32SubSecondInc is set to 40//! subseconds, increments at the same rate as the main oscillator clock.  For//! 0.465 ns units ensures that the time stamp, read as seconds and//! \e ui32SubSecondInc to the main oscillator clock period in either 1 ns or//! \e ui32SubSecondInc on each main oscillator clock tick.  Setting//! In coarse update mode, the timestamp subsecond counter is incremented by//! each lsb represent 1 nanosecond.//! nanosecond counter and rolls over to 0 after reaching 999,999,999 making//! binary rollover mode is selected, the subsecond counter acts as a //! the definition of 1 second resolution for the seconds counter).  When//! this case, each lsb of the subsecond counter represents 0.465 ns (assuming//! simple 31-bit counter, rolling over to 0 after reaching 0x7FFFFFFF.  In//! rolls over.  In digital rollover mode, the subsecond counter acts as a//! The timestamp second counter is incremented each time the subsecond counter//! in \e ui32Config.//! \b EMAC_TS_UPDATE_FINE or \b EMAC_TS_UPDATE_COARSE were included//! EMAC_TS_DIGITAL_ROLLOVER or \b EMAC_TS_BINARY_ROLLOVER and//! subsecond count increments.  Its meaning depends on which of \b//! The \e ui32SubSecondInc controls the rate at which the timestamp clock's//!   by the MAC, regardless of type.//! - \b EMAC_TS_ALL_RX_FRAMES enables timestamping for all frames received//!   in Ethernet frames.  If absent, the MAC ignores these frames.//! - \b EMAC_TS_PROCESS_ETHERNET processes PTP packets encapsulated directly//!   over IPv6 packets.  If absent, the MAC ignores these frames.//! - \b EMAC_TS_PROCESS_IPV6_UDP processes PTP packets encapsulated in UDP//!   over IPv4 packets.  If absent, the MAC ignores these frames.//! - \b EMAC_TS_PROCESS_IPV4_UDP processes PTP packets encapsulated in UDP//! Optional, additional flags are://!   messages.//! - \b EMAC_TS_PDREQ_PDRESP timestamps only Pdelay_Req and Pdelay_Resp//! - \b EMAC_TS_SYNC_DELAYREQ timestamps only Delay_Req messages.//!   Pdelay_Resp messages.//! - \b EMAC_TS_DREQ_PDREQ_PDRESP timestamps only Delay_Req, Pdelay_Req and//! - \b EMAC_TS_ALL timestamps all IEEE 1588 messages.//! - \b EMAC_TS_DELAYREQ_ONLY timestamps only Delay_Req messages.//! - \b EMAC_TS_SYNC_ONLY timestamps only SYNC messages.//!   and Delay_Resp messages.//! - \b EMAC_TS_SYNC_FOLLOW_DREQ_DRESP timestamps SYNC, Follow_Up, Delay_Req//! One of the following to determine which IEEE 1588 messages are timestamped://! addend accumulator register.//! \e ui32SubSecondInc parameter each time a carry is generated from the//! IEEE 1588 clock to advance by the the value supplied in the//! - \b EMAC_TS_UPDATE_FINE selects the fine update method which causes the//! oscillator clock cycle.//! the value supplied in the \e ui32SubSecondInc parameter on each main//! - \b EMAC_TS_UPDATE_COARSE causes the IEEE 1588 clock to advance by//! One of the following to determine how the clock is updated://! - \b EMAC_TS_MAC_FILTER_DISABLE//! - \b EMAC_TS_MAC_FILTER_ENABLE//! any of the currently programmed MAC addresses.//! enabled, PTP frames are filtered unless the destination MAC address matches//! One of the following to enable or disable MAC address filtering. When//! periods.//! over at 0x7FFFFFFF.  In this mode, the subsecond value counts 0.465 ns//! - \b EMAC_TS_BINARY_ROLLOVER causes the clock's subsecond value to roll//! as a nanosecond counter with each digit representing 1 ns.//! value should be interpreted and handled://! One of the following to determine how the IEEE 1588 clock's subsecond//! - \b EMAC_TS_PTP_VERSION_1//! - \b EMAC_TS_PTP_VERSION_2//! packet format is to be processed://! One of the following to determine whether IEEE 1588 version 1 or version 2//! desired options.  Valid flags are://! The \e ui32Config parameter contains a collection of flags selecting the//! IEEE 1588 Precision Time Protocol is in use.//! and outgoing packets and as an accurate system time reference when//! internal timestamping clock.  This clock is used to timestamp incoming//! This function is used to configure the operation of the Ethernet MAC's//! should increment on each tick.//! \param ui32SubSecondInc is the number that the IEEE 1588 subsecond clock//! options.//! \param ui32Config contains flags selecting particular configuration//! Configures the Ethernet MAC's IEEE 1588 timestamping options.// normal operating mode.// Clear the PWRDN bit and set the ANEGEN bit in the PHY, putting it into//! called if EMACPHYPowerOff() has previously been called.//! operation.  By default, the PHY is powered on, so this function is only//! This function powers on the Ethernet PHY, enabling it return to normal//! \param ui8PhyAddr is the physical address of the PHY to power up.//! Powers on the Ethernet PHY.// its low power mode.// Set the PWRDN bit and clear the ANEN bit in the PHY, putting it into//! controller is unable to connect to Ethernet.//! consumption of the device.  While in the powered-off state, the Ethernet//! This function powers off the Ethernet PHY, reducing the current//! \param ui8PhyAddr is the physical address of the PHY to power down.//! Powers off the Ethernet PHY.// Write the extended register.//! to the extended PHY register specified by \e ui16RegAddr.//! supporting extended registers, this function allows a value to be written//! When using the internal PHY or when connected to an external PHY//! Writes a value to an extended PHY register.//! extended PHY register specified by \e ui16RegAddr.//! supporting extended registers, this function returns the contents of the//! Reads from an extended PHY register.// Wait for the read to complete.// Tell the MAC to read the given PHY register.// Make sure the MII is idle.//! \e ui8RegAddr.//! This function returns the contents of the PHY register specified by//! \param ui8RegAddr is the address of the PHY register to be accessed.//! Reads from a PHY register.// Tell the MAC to write the given PHY register.// Write the value provided.//! This function writes the \e ui16Data value to the PHY register specified by//! \param ui16Data is the data to be written to the PHY register.//! Writes to the PHY register.// Clear the PHY interrupt if we've been asked to do this.// sources.// this if some bits are actually set that refer to the DMA interrupt// the bottom 17 bits of the register are actually clearable.  Only do// (with the summary sources added if necessary) but remember that only// Clear the maskable interrupt sources.  We write exactly the value passed// relates to is specified.// Similarly, mask in the abnormal interrupt if one of the sources it// specified.// Mask in the normal interrupt if one of the sources it relates to is//! explicitly clear these bits.//! of their constituent sources are cleared.  Applications do not need to//! \b EMAC_INT_ABNORMAL_INT are cleared automatically by the driver if any//! Summary interrupt bits \b EMAC_INT_NORMAL_INT and//! completed and that all requested status has been updated in the descriptor.//! - \b EMAC_INT_TRANSMIT indicates that transmission of a frame has//! - \b EMAC_INT_TX_STOPPED indicates that the transmit process has stopped.//! the descriptor ownership and calling EMACTxDMAPollDemand().//! acquire a buffer.  Transmission is suspended and can be resumed by changing//! in the DMA's transmit descriptor list and that the DMA cannot, therefore,//! - \b EMAC_INT_TX_NO_BUFFER indicates that the host owns the next buffer//! enter the Stopped state.//! bytes in Jumbo Frame mode) and causes the transmit process to abort and //! This condition occurs when the frame size exceeds 2048 bytes (or 10240 //! - \b EMAC_INT_TX_JABBER indicates that the transmit jabber timer expired.//! during reception.//! - \b EMAC_INT_RX_OVERFLOW indicates that an overflow was experienced//! underflow during transmission.  The transmit process is suspended.//! - \b EMAC_INT_TX_UNDERFLOW indicates that the transmitter experienced an//! and all requested status has been written to the appropriate DMA receive//! - \b EMAC_INT_RECEIVE indicates that reception of a frame has completed//! the descriptor ownership and calling EMACRxDMAPollDemand().//! a buffer.  The receive process is suspended and can be resumed by changing//! in the DMA's receive descriptor list and the DMA cannot, therefore, acquire//! - \b EMAC_INT_RX_NO_BUFFER indicates that the host owns the next buffer//! the stopped state.//! - \b EMAC_INT_RX_STOPPED indicates that the receive process has entered//! 2048 bytes (of 10240 bytes in Jumbo Frame mode) was received.//! - \b EMAC_INT_RX_WATCHDOG indicates that a frame with length greater than//! been fully written from memory into the MAC transmit FIFO.//! - \b EMAC_INT_EARLY_TRANSMIT indicates that a frame to be transmitted has//! that the DMA engine has been disabled.//! - \b EMAC_INT_BUS_ERROR indicates that a fatal bus error has occurred and//! first data buffer of a packet.//! - \b EMAC_INT_EARLY_RECEIVE indicates that the DMA engine has filled the//! disable and clear particular notifications.//! Software must read and write the appropriate PHY registers to enable,//! - \b EMAC_INT_PHY indicates that the PHY has signaled a change of state.//! This function disables the indicated Ethernet MAC interrupt sources.//! \param ui32IntFlags is the bit mask of the interrupt sources to be cleared.//! \param ui32Base is the base address of the Ethernet MAC.//! Clears individual Ethernet MAC interrupt sources.// If the PHY interrupt is reported, add the appropriate flag to the// Read the PHY interrupt status.// of the register can be masked so make sure we take this into account.// so perform the masking manually.  Note that only the bottom 16 bits// This peripheral doesn't have a masked interrupt status register// Get the unmasked interrupt status and clear any unwanted status fields.//! \b EMAC_INT_BUS_ERROR.//! \b EMAC_INT_RX_WATCHDOG, \b EMAC_INT_EARLY_TRANSMIT and//! \b EMAC_INT_RX_NO_BUFFER, \b EMAC_INT_RX_STOPPED,//! \b EMAC_INT_RX_OVERFLOW, \b EMAC_INT_TX_UNDERFLOW,//! OR of the masked state of \b EMAC_INT_TX_STOPPED, \b EMAC_INT_TX_JABBER,//! - \b EMAC_INT_ABNORMAL_INT is a summary interrupt comprising the logical//! \b EMAC_INT_TX_NO_BUFFER and \b EMAC_INT_EARLY_RECEIVE.//! OR of the masked state of \b EMAC_INT_TRANSMIT, \b EMAC_INT_RECEIVE,//! - \b EMAC_INT_NORMAL_INT is a summary interrupt comprising the logical//! determined by calling EMACDMAStateGet().//! that the DMA engine has been disabled.  The cause of the error can be//! Software must read the relevant PHY interrupt status register to determine//! - \b EMAC_INT_PHY indicates that the PHY interrupt has occurred.//! the following://! \return Returns the current interrupt status as the logical OR of any of//! to reflect to the processor can be returned.//! the raw interrupt status or the status of interrupts that are allowed//! This function returns the interrupt status for the Ethernet MAC.  Either//! to return the unmasked status.//! \param bMasked is \b true to return the masked interrupt status or \b false//! Gets the current Ethernet MAC interrupt status.// Disable the PHY interrupt if we've been asked to do this.// Write the new mask back to the hardware.// disable the abnormal interrupt.// Similarly, if none of the abnormal interrupt sources are enabled,// normal interrupt.// If none of the normal interrupt sources are enabled, disable the// Clear the requested bits.// Get the current interrupt mask.//! disabled independently by using a call to EMACTimestampTargetIntDisable().//! \note Timestamp-related interrupts from the IEEE 1588 module must be//! explicitly disable these bits.//! of their constituent sources are enabled.  Applications do not need to//! \b EMAC_INT_ABNORMAL_INT are disabled automatically by the driver if none//! bit.//! determined by calling EMACTimestampIntStatus(), which also clears this//! module has occurred.  This precise source of the interrupt can be//! - \b EMAC_INT_TIMESTAMP indicates that an interrupt from the timestamp//! disable particular notifications.//! Software must read and write the appropriate PHY registers to enable and//! \param ui32IntFlags is the bit mask of the interrupt sources to be disabled.//! Disables individual Ethernet MAC interrupt sources.// Enable the PHY interrupt if we've been asked to do this.// we've been asked to enable are found in that register.// Set the MAC DMA interrupt mask appropriately if any of the sources// sources are enabled.// Similarly, enable the abnormal interrupt if any of its individual// enabled.// Enable the normal interrupt if any of its individual sources are//! enabled independently by using a call to EMACTimestampTargetIntEnable().//! explicitly enable these bits.//! \b EMAC_INT_ABNORMAL_INT are enabled automatically by the driver if any//! the sources that are enabled can be reflected to the processor interrupt;//! This function enables the indicated Ethernet MAC interrupt sources.  Only//! Enables individual Ethernet MAC interrupt sources.//! handler is no longer called.//! the global interrupt in the interrupt controller so that the interrupt//! Unregisters an interrupt handler for an Ethernet interrupt.// Enable the Ethernet interrupt.//! the interrupt source.//! EMACIntEnable().  It is the interrupt handler's responsibility to clear//! controller; specific Ethernet interrupts must be enabled via//! occurs.  This function enables the global interrupt in the interrupt//! This function sets the handler to be called when the Ethernet interrupt//! enabled Ethernet interrupts occur.//! Registers an interrupt handler for an Ethernet interrupt.// Disable reception in the MAC configuration register.//! be called.  This function disables the receiver.//! When terminating operations on the Ethernet interface, this function should//! Disables the Ethernet controller receiver.// Enable receive in the MAC configuration register.// Enable the MAC receive path.//! completed.//! be called to enable the receiver after all configuration has been//! When starting operations on the Ethernet interface, this function should//! Enables the Ethernet controller receiver.//! be called.  This function disables the transmitter.//! Disables the Ethernet controller transmitter.// Enable transmission in the MAC configuration register.// Enable the MAC transmit path in the opmode register.//! be called to enable the transmitter after all configuration has been//! Enables the Ethernet controller transmitter.// Wait for the flush to complete.// Flush the transmit FIFO since it is not currently empty.// Check to make sure that the FIFO is not already empty.//! transmission.//! transmitted, possibly resulting in a transmit underflow or runt frame//! FIFO.  Data that has already been passed to the MAC for transmission is//! This function flushes any data currently held in the Ethernet transmit//! Flushes the Ethernet controller transmit FIFO.// Return the status of the DMA channels.//! reading the transmit descriptor.//! - \b EMAC_DMA_ERR_TX_DESC_READ indicates that an error occurred when//! reading the receive descriptor.//! - \b EMAC_DMA_ERR_RX_DESC_READ indicates that an error occurred when//! writing to the transmit descriptor.//! - \b EMAC_DMA_ERR_TX_DESC_WRITE indicates that an error occurred when//! writing to the receive descriptor.//! - \b EMAC_DMA_ERR_RX_DESC_WRITE indicates that an error occurred when//! reading data from memory for transmission.//! - \b EMAC_DMA_ERR_TX_DATA_READ indicates that an error occurred when//! writing received data to memory.//! - \b EMAC_DMA_ERR_RX_DATA_WRITE indicates that an error occurred when//! \b EMAC_DMA_ERR_MASK://! of the following values which may be extracted from the return value using//! If this flag is present, the source of the error is identified using one//! Additionally, a DMA bus error may be signaled using \b EMAC_DMA_ERROR.//! currently transferring data from the MAC receive FIFO to memory.//! - \b EMAC_DMA_RXSTAT_RUN_RECEIVING indicating that the receive engine is//! currently writing timestamp information to the descriptor.//! - \b EMAC_DMA_RXSTAT_TS_WRITE indicating that the transmit engine is//! is closing the descriptor after receiving a buffer of data.//! - \b EMAC_DMA_RXSTAT_RUN_CLOSE_DESC indicating that the receive engine//! suspended due to the next descriptor being unavailable.//! - \b EMAC_DMA_RXSTAT_SUSPENDED indicating that the receive engine is//! is waiting for the next packet.//! - \b EMAC_DMA_RXSTAT_RUN_WAIT_PACKET indicating that the receive engine//! is fetching the next descriptor.//! - \b EMAC_DMA_RXSTAT_RUN_FETCH_DESC indicating that the receive engine//! stopped.//! - \b EMAC_DMA_RXSTAT_STOPPED indicating that the receive engine is//! and one of://! or a transmit buffer underflow.//! suspended due to the next descriptor being unavailable (owned by the host)//! - \b EMAC_DMA_TXSTAT_SUSPENDED indicating that the transmit engine is//! - \b EMAC_DMA_TXSTAT_TS_WRITE indicating that the transmit engine is//! is closing the descriptor after transmission of the buffer data.//! - \b EMAC_DMA_TXSTAT_RUN_CLOSE_DESC indicating that the transmit engine//! currently transferring data from memory to the MAC transmit FIFO.//! - \b EMAC_DMA_TXSTAT_RUN_READING indicating that the transmit engine is//! is waiting for status from the MAC.//! - \b EMAC_DMA_TXSTAT_RUN_WAIT_STATUS indicating that the transmit engine//! - \b EMAC_DMA_TXSTAT_RUN_FETCH_DESC indicating that the transmit engine//! - \b EMAC_DMA_TXSTAT_STOPPED indicating that the transmit engine is//! states are ORed together into a single word containing one of://! \return Returns the states of the transmit and receive DMA engines.  These//! directly to mask out the individual states from the returned value.//! \b EMAC_DMA_TXSTAT_MASK and \b EMAC_DMA_RXSTAT_MASK may be used//! extract these fields from the returned value.  Alternatively, masks//! \b EMAC_TX_DMA_STATE() and \b EMAC_RX_DMA_STATE() may be used to//! the transmit state and the other the receive state.  Macros//! receive DMA engines.  The return value contains two fields, one providing//! This function may be used to query the current states of the transmit and//! engines.//! Returns the current states of the Ethernet MAC transmit and receive DMA// Return the transmit buffer address currently being read by the DMA.//! DMA engine.//! \return Returns the transmit buffer address currently being read by the//! engine is currently reading from.//! This function may be called to determine which buffer the transmit DMA//! Returns the current DMA transmit buffer pointer.// Return the address of the current transmit descriptor read by the DMA.//! \return Returns a pointer to the start of the current transmit DMA//! read by the DMA.//! This function returns a pointer to the current Ethernet transmit descriptor//! Returns the current DMA transmit descriptor pointer.// Return the current transmit DMA descriptor list pointer.//! \return Returns a pointer to the start of the DMA transmit descriptor list.//! using a call to EMACTxDMADescriptorListSet().//! DMA descriptor list.  This value corresponds to the pointer originally set //! This function returns a pointer to the head of the Ethernet MAC's transmit//! Returns a pointer to the start of the DMA transmit descriptor list.// Write the supplied address to the MACTXDLADDR register.//! appropriately before passing the descriptor list to the hardware.//! Applications are responsible for initializing all descriptor fields//! should be set to accommodate the newly sized structure.//! add new state fields to the end of the descriptor structure, the skip size//! of \b tEMACDMADescriptor structures is used. If the application wishes to//! the start of the next.  This value must be 0 in cases where a packed array//! been set to the number of words between the end of one descriptor and//! the \e ui32DescSkipSize parameter to EMACInit() must previously have//! descriptor to point to two buffers rather than one.  In this case,//! becomes available to store a second buffer pointer, allowing each//! If unchained descriptors are used, the \e pvLink field in the descriptor//! consistent offset between the start of one descriptor and the next.//! Unchained descriptors are assumed to be contiguous in memory with a//! point to the next descriptor in the chain.//! Chained descriptors use a link pointer in each descriptor to//! unchained descriptors are assumed.//! word of the transmit or receive descriptor.  If this bit is clear,//! \b DES0_TX_CTRL_CHAINED or \b DES1_RX_CTRL_CHAINED bit in the relevant//! unchained.  Chained descriptors are indicated by setting the//! When multiple descriptors are provided, they can be either chained or//! structures.//! The \e pDescriptor pointer must point to one or more descriptor//! This function sets the Ethernet MAC's transmit DMA descriptor list pointer.//! be passed to the transmit DMA engine.//! \param pDescriptor points to the first DMA descriptor in the list to//! Sets the DMA transmit descriptor list pointer.// Return the receive buffer address currently being written by the DMA.//! the DMA engine.//! \return Returns the receive buffer address currently being written by//! engine is currently writing to.//! This function may be called to determine which buffer the receive DMA//! Returns the current DMA receive buffer pointer.// Return the address of the current receive descriptor written by the DMA.//! \return Returns a pointer to the start of the current receive DMA//! This function returns a pointer to the current Ethernet receive descriptor//! Returns the current DMA receive descriptor pointer.// Return the current receive DMA descriptor list pointer.//! \return Returns a pointer to the start of the DMA receive descriptor list.//! using a call to EMACRxDMADescriptorListSet().//! DMA descriptor list.  This value corresponds to the pointer originally set//! This function returns a pointer to the head of the Ethernet MAC's receive//! Returns a pointer to the start of the DMA receive descriptor list.// Write the supplied address to the MACRXDLADDR register.//! This function sets the Ethernet MAC's receive DMA descriptor list pointer.//! be passed to the receive DMA engine.//! Sets the DMA receive descriptor list pointer.// to resume.// Any write to the MACRXPOLLD register causes the receive DMA to attempt//! into its buffer(s).//! attempt to acquire the descriptor before writing the next received packet//! it as being owned by the MAC DMA, this function causes the hardware to//! host.  Once the application reads any data from the descriptor and marks//! suspended due to the current receive DMA descriptor being owned by the//! This function must be called to restart the receiver if it has been//! \param ui32Base is the base address of the Ethernet controller.//! Orders the MAC DMA controller to attempt to acquire the next receive// Any write to the MACTXPOLLD register causes the transmit DMA to attempt//! data.//! attempt to acquire the descriptor and start transmission of the new//! host.  Once the application writes new values to the descriptor and marks//! suspended due to the current transmit DMA descriptor being owned by the//! This function must be called to restart the transmitter if it has been//! Orders the MAC DMA controller to attempt to acquire the next transmit// Read and return the MAC status register content.//! - \b EMAC_STATUS_RX_FIFO_FLUSHING//! - \b EMAC_STATUS_RX_FIFO_STATUS//! - \b EMAC_STATUS_RX_FIFO_READING//! - \b EMAC_STATUS_RX_FIFO_IDLE//! by ANDing with \b EMAC_STATUS_RX_FIFO_STATE_MASK and is one of the //! The current receive FIFO state can be extracted from the returned value//! - \b EMAC_STATUS_RX_FIFO_FULL indicating that the FIFO is full.//! above the flow-control activate threshold.//! - \b EMAC_STATUS_RX_FIFO_ABOVE indicating that the FIFO fill level is//! below the flow-control deactivate threshold.//! - \b EMAC_STATUS_RX_FIFO_BELOW indicating that the FIFO fill level is//! - \b EMAC_STATUS_RX_FIFO_EMPTY indicating that the FIFO is empty.//! by ANDing with \b EMAC_STATUS_RX_FIFO_LEVEL_MASK and is one of the //! The current receive FIFO levels can be extracted from the returned value//! - \b EMAC_STATUS_TRC_STATE_STATUS//! - \b EMAC_STATUS_TRC_STATE_WAITING//! - \b EMAC_STATUS_TRC_STATE_READING//! - \b EMAC_STATUS_TRC_STATE_IDLE//! value by ANDing with \b EMAC_STATUS_TRC_STATE_MASK and is one of the //! The transmit FIFO read controller status can be extracted from the returned //! - \b EMAC_STATUS_TFC_STATE_WRITING//! - \b EMAC_STATUS_TFC_STATE_PAUSING//! - \b EMAC_STATUS_TFC_STATE_WAITING//! - \b EMAC_STATUS_TFC_STATE_IDLE//! value by ANDing with \b EMAC_STATUS_TFC_STATE_MASK and is one of the //! The transmit frame controller status can be extracted from the returned //! - \b EMAC_STATUS_RPE_ACTIVE//! - \b EMAC_STATUS_RWC_ACTIVE//! - \b EMAC_STATUS_MAC_NOT_IDLE//! - \b EMAC_STATUS_TX_PAUSED//! - \b EMAC_STATUS_TX_WRITING_FIFO//! - \b EMAC_STATUS_TX_NOT_EMPTY//! following flags://! \return Returns the current MAC status as a logical OR of any of the//! modules in the MAC transmit and receive data paths.//! This function returns information on the current status of all the main//! Returns the current Ethernet MAC status.// Set the receive interrupt watchdog timeout period.//! To disable the receive interrupt watchdog function, set \e ui8Timeout to 0.//! does not disable the receive interrupt.//! whenever a packet is transferred to memory using a DMA descriptor that//! interrupt to be generated when it times out.  The watchdog timer is reset//! \b DES1_RX_CTRL_DISABLE_INT set, the watchdog causes a receive//! transferred a frame using a descriptor that has//! that elapse before the timer expires.  In cases where the DMA has//! The \e uiTimeout parameter specifies the number of 256 system clock periods//! This function configures the receive interrupt watchdog timer.//! system clock periods.//! \param ui8Timeout is the desired timeout expressed as a number of 256//! Sets the receive interrupt watchdog timer period.// Return the final hash table bit index.// Reverse the order of the bottom 6 bits of the calculated CRC.// CRC with the bit order of those 6 bits reversed).// top 6 bits of the reversed CRC (or the bottom 6 bits of the calculated//! passed MAC address.//! \return Returns the bit number to set in the MAC hash table to describe the//! to describe the passed MAC address.//! 2 of word 1 (\e ui32HashHi as passed to EMACHashFilterSet()) must be set//! word.  For example, if 0x22 (100010b) is returned, this indicates that bit//! affected and the bottom 5 bits indicate the bit number to set within that//! a 6-bit number where bit 5 indicates which of the two hash table words is//! filter to set to describe a given 6-byte MAC address.  The returned value is//! This function may be used to determine which bit in the MAC address hash//!  for which the hash filter bit is to be determined.//! \param pui8MACAddr points to a buffer containing the 6-byte MAC address//! given MAC address.//! Returns the bit number to set in the MAC hash filter corresponding to a// Get the current hash table values.//! configured).//! packet is rejected (assuming normal rather than inverse filtering is//! considered to have passed.  If the bit is clear, the filter fails and the//! hash filter table.  If the bit in the hash table is set, the filter is//! calculated and the bottom 6 bits are used as a bit index into the 64-bit//! required.  A CRC of the packet source or destination MAC address is//! packets passing the filter when their MAC address was not one of those//! simultaneously at the cost of some false-positive results in the form of//! Hash table filtering allows many different MAC addresses to be filtered//! call to EMACHashFilterSet().//! from the MAC prior to making changes and setting the new hash filter via a//! This function may be used to retrieve the current 64-bit hash filter table//! of the current 64-bit hash filter table.//! \param pui32HashLo points to storage to be written with the lower 32 bits //! \param pui32HashHi points to storage to be written with the upper 32 bits //! Returns the current MAC address hash filter table.// Set the hash table with the values provided.//! required).  A CRC of the packet source or destination MAC address is//! simultaneously at the cost of some false-positive results (in the form of//! by calling EMACHashFilterGet().//! to EMACFrameFilterSet().  The current hash filter may be retrieved//! and/or \b EMAC_FRMFILTER_HASH_MULTICAST in the \e ui32FilterOpts parameter//! Hash filtering is enabled by passing \b EMAC_FRMFILTER_HASH_UNICAST//! used by the MAC to filter incoming packets when hash filtering is enabled.//! This function may be used to set the current 64-bit hash filter table//! table to set.//! \param ui32HashLo is the lower 32 bits of the current 64-bit hash filter//! \param ui32HashHi is the upper 32 bits of the current 64-bit hash filter//! Sets the MAC address hash filter table.// Return the current MAC frame filter setting.//! pass the configured address filter.//! - \b EMAC_FRMFILTER_PASS_ADDR_CTRL passes all control frames only if they//! PAUSE even if they fail the configured address filter.//! - \b EMAC_FRMFILTER_PASS_ALL_CTRL passes all control frames, including//! - \b EMAC_FRMFILTER_PASS_NO_PAUSE passes all control frames other than//! the application.//! - \b EMAC_FRMFILTER_PASS_NO_CTRL prevents any control frame from reaching//! \b EMAC_FRMFILTER_PASS_MASK://! values which may be extracted from the returned value using the mask//! Control frame filtering configuration is indicated by one of the following//! status word are always cleared.//! application and the SA and DA filter status bits of the descriptor receive//! operate in promiscuous mode where all received frames are passed to the//! - \b EMAC_FRMFILTER_PROMISCUOUS indicates that the MAC is configured to//! the perfect filter.//! that the hash filter should be used for incoming unicast packets along with//! conjunction with \b EMAC_FRMFILTER_HASH_AND_PERFECT, this flag indicates//! absent, perfect destination address filtering is used.  If used in//! filtering of received unicast frames is enabled using the hash table.  If//! - \b EMAC_FRMFILTER_HASH_UNICAST indicates that destination address//! with the perfect filter.//! that the hash filter should be used for incoming multicast packets along//! filtering of received multicast frames is enabled using the hash table.  If//! - \b EMAC_FRMFILTER_HASH_MULTICAST indicates that destination address//! address filtering for both unicast and multicast frames is inverted.//! - \b EMAC_FRMFILTER_INV_DADDR indicates that the sense of the destination//! to pass all incoming frames with multicast destinations addresses.//! - \b EMAC_FRMFILTER_PASS_MULTICAST indicates that the MAC is configured//! discard all incoming broadcast frames.//! - \b EMAC_FRMFILTER_BROADCAST indicates that the MAC is configured to//! SA registers are marked as passing the source address filter.//! When this option is specified, frames for which the SA does not match the //! - \b EMAC_FRMFILTER_INV_SADDR enables inverse source address filtering.//! the values programmed into the enabled SA registers.//! received frames when the source address field in the frame does not match//! - \b EMAC_FRMFILTER_SADDR indicates that the MAC is configured to drop//! \b EMAC_FRMFILTER_HASH_UNICAST are clear or the hash filter otherwise.//! filter, the perfect filter if \b EMAC_FRMFILTER_HASH_MULTICAST or//! If this flag is absent, frames passing based on the result of a single//! to pass frames if they match either the hash filter or the perfect filter.//! - \b EMAC_FRMFILTER_HASH_AND_PERFECT indicates that the MAC is configured//! frames which do not pass the VLAN tag comparison.//! - \b EMAC_FRMFILTER_VLAN indicates that the MAC is configured to drop any//! filter passed or failed for the frame.//! relevant DMA descriptor is updated to indicate whether the configured//! address filter that is configured.  The receive status word in the//! pass all received frames regardless of whether or not they pass any//! - \b EMAC_FRMFILTER_RX_ALL indicates that the MAC to is configured to//! indicating the frame filtering options in use.  Possible flags are://! \return Returns a value comprising the logical OR of various flags//! set using a prior call to EMACFrameFilterSet().//! This function may be called to retrieve the frame filtering configuration//! Returns the current Ethernet frame filtering settings.// Set the Ethernet MAC frame filter according to the flags passed.//! values into \e ui32FilterOpts://! Control frame filtering may be configured by ORing one of the following//! are always cleared.//! and the SA and DA filter status bits of the descriptor receive status word//! promiscuous mode where all received frames are passed to the application//! - \b EMAC_FRMFILTER_PROMISCUOUS configures the MAC to operate in//! should be used for incoming unicast packets along with the perfect filter.//! EMAC_FRMFILTER_HASH_AND_PERFECT, this flag indicates that the hash filter//! destination address filtering is used.  If used in conjunction with \b//! of received unicast frames using the hash table.  If absent, perfect//! - \b EMAC_FRMFILTER_HASH_UNICAST enables destination address filtering//! should be used for incoming multicast packets along with the perfect//! of received multicast frames using the hash table.  If absent, perfect//! - \b EMAC_FRMFILTER_HASH_MULTICAST enables destination address filtering//! address filtering for both unicast and multicast frames.//! - \b EMAC_FRMFILTER_INV_DADDR inverts the sense of the destination//! incoming frames with multicast destinations addresses.//! - \b EMAC_FRMFILTER_PASS_MULTICAST configures the MAC to pass all//! broadcast frames.//! - \b EMAC_FRMFILTER_BROADCAST configures the MAC to discard all incoming//! programmed into the enabled SA registers.//! when the source address field in the frame does not match the values//! - \b EMAC_FRMFILTER_SADDR configures the MAC to drop received frames//! for unicast and multicast frames respectively.//! \b EMAC_FRMFILTER_HASH_UNICAST and \b EMAC_FRMFILTER_HASH_MULTICAST//! option is absent, only one of the filter types is used, as controlled by//! this case, only if both filters fail is the packet rejected.  If this//! \b EMAC_FRMFILTER_HASH_UNICAST or \b EMAC_FRMFILTER_HASH_MULTICAST.  In//! based on both any perfect filters set and the hash filter if enabled using//! - \b EMAC_FRMFILTER_HASH_AND_PERFECT configures the MAC to filter frames//! not pass the VLAN tag comparison.//! - \b EMAC_FRMFILTER_VLAN configures the MAC to drop any frames that do//! the frame.//! updated to indicate whether the configured filter passed or failed for//! configured.  The receive status word in the relevant DMA descriptor is//! regardless of whether or not they pass any address filter that is//! - \b EMAC_FRMFILTER_RX_ALL configures the MAC to pass all received frames//! flags://! The \e ui32FilterOpts parameter is a logical OR of any of the following//! tagging.//! criteria related to the frame source and destination MAC addresses or VLAN//! an application to control which frames are received based on various//! This function allows various filtering options to be defined and allows//! address filtering options.//! \param ui32FilterOpts is a logical OR of flags defining the required MAC//! Sets options related to Ethernet frame filtering.// Read and return the filter settings for the requested MAC address slot.//! first byte of the source or destination address when filtering.//! - \b EMAC_FILTER_MASK_BYTE_1 indicates that the MAC ignores the//! second byte of the source or destination address when filtering.//! - \b EMAC_FILTER_MASK_BYTE_2 indicates that the MAC ignores the//! third byte of the source or destination address when filtering.//! - \b EMAC_FILTER_MASK_BYTE_3 indicates that the MAC ignores the//! fourth byte of the source or destination address when filtering.//! - \b EMAC_FILTER_MASK_BYTE_4 indicates that the MAC ignores the//! fifth byte of the source or destination address when filtering.//! - \b EMAC_FILTER_MASK_BYTE_5 indicates that the MAC ignores the//! sixth byte of the source or destination address when filtering.//! - \b EMAC_FILTER_MASK_BYTE_6 indicates that the MAC ignores the//! destination address.//! perfect filtering.  If absent, the MAC address is compared against the//! index is compared to the source address of incoming frames while performing//! - \b EMAC_FILTER_SOURCE_ADDR indicates that the MAC address at the given//! filtering.//! the MAC address at the given index is disabled and is not used in//! and is used when performing perfect filtering.  If this flag is absent,//! - \b EMAC_FILTER_ADDR_ENABLE indicates that this MAC address is enabled//! \return Returns the filter configuration as the logical OR of the//! not have filtering parameters associated with it.//! calling EMACNumAddrGet().  MAC index 0 is the local MAC address and does //! slots - 1). The number of supported MAC address slots may be found by //! Valid values for \e ui32Index are from 1 to (number of MAC address //! when perfect filtering (rather than hash table filtering) is selected.//! address slots that the controller supports.  This configuration is used//! This function returns filtering parameters associated with one of the MAC//!        is to be queried.//! \param ui32Index is the index of the MAC address slot for which the filter //! addresses.//! Gets filtering parameters associated with one of the configured MAC// that the upper half's data is latched.// Read and rewrite the low half of the MAC address register to ensure// Set the filter configuration for a particular MAC address.//! - \b EMAC_FILTER_MASK_BYTE_1 indicates that the MAC should ignore the//! - \b EMAC_FILTER_MASK_BYTE_2 indicates that the MAC should ignore the//! - \b EMAC_FILTER_MASK_BYTE_3 indicates that the MAC should ignore the//! - \b EMAC_FILTER_MASK_BYTE_4 indicates that the MAC should ignore the//! - \b EMAC_FILTER_MASK_BYTE_5 indicates that the MAC should ignore the//! - \b EMAC_FILTER_MASK_BYTE_6 indicates that the MAC should ignore the//! against the destination address.//! performing perfect filtering.  If absent, the MAC address is compared//! index is compared to the source address of incoming frames while//! in filtering.//! absent, the MAC address at the given index is disabled and is not used//! and should be used when performing perfect filtering.  If this flag is//! of the fields://! when filtering incoming Ethernet frames.  It is comprised of a logical OR//! The \e ui32Config parameter determines how the given MAC address is used//! This function sets filtering parameters associated with one of the MAC//! \param ui32Config sets the filter parameters for the given MAC address.//!        is to be set.//! Sets filtering parameters associated with one of the configured MAC// The only Ethernet controller on Snowflake supports 4 MAC addresses.//! \return Returns the number of supported MAC addresses.//! perfect (rather than hash table) filtering of packets.//! given controller supports.  MAC address slots may be used when performing//! This function may be used to determine the number of MAC addresses that the//! Returns the number of MAC addresses supported by the Ethernet controller.// Get the last 2 bytes of the MAC address.// Get the first 4 bytes of the MAC address.//! the second, 0x48 in the third and so on.//! the data is returned with 0xAC in the first byte of the array, 0xDE in //! AC-DE-48-00-00-80//! (OUI) shown first as://! is written in its usual form with the Organizationally Unique Identifier//! to be transmitted in the first array entry.  For example, if the address//! The address is written to the pui8MACAddr array ordered with the first byte//! used to define MAC addresses when filtering incoming packets.//! Index 0 refers to the MAC address of the local node.  Other indices are//! by the controller may be queried using a call to EMACNumAddrGet().//! hardware's MAC addresses to return.  The number of MAC addresses supported//! \e pui8MACAddr buffer.  The \e ui32Index parameter defines which of the//! This function reads the currently programmed MAC address into the//! array of MAC-48 address octets.//! \param pui8MACAddr is the pointer to the location in which to store the//! \param ui32Index is the zero-based index of the MAC address to return.//! Gets one of the MAC addresses stored in the Ethernet controller.// Set the first 4 bytes of the MAC address// on the write to EMAC_O_ADDRL.// registers in this order since the address is latched internally// Set the high 2 bytes of the MAC address.  Note that we must set the//! the MAC address remains unaffected by a change in the address.//! enabled following this call.  Similarly, any filter configured for//! If the MAC address set by this function is currently enabled, it remains//! uint8_t g_pui8MACAddr[] = { 0xAC, 0xDE, 0x48, 0x00, 0x00, 0x80 };//! following array://! For example, the address given above could be represented using the//! ordered with the first byte to be transmitted in the first array entry.//! The address passed to this function in the \e pui8MACAddr array is//! ``80''.//! of ``AC'', and the last bit to be transmitted would be ``1'', the MSB of//! For this address, the first bit to be transmitted would be ``0'', the LSB//! transmitted last.  Within an octet, the bits are transmitted LSB to MSB.//! with the ``AC'' octet being transmitted first and the ``80'' octet being//! In this representation, the octets are transmitted from left to right,//! to be connected to the Ethernet.//! to uniquely identify a piece of hardware within that organization that is//! last three octets (00-00-80) are a 24-bit number managed by the OUI owner//! the IEEE to an organization that requests a block of MAC addresses.  The//! Organizationally Unique Identifier (OUI).  This is a number assigned by//! In this representation, the first three octets (AC-DE-48) are the//!         AC-DE-48-00-00-80//! example address.  The numbers are shown in hexadecimal format.//! The MAC-48 address is defined as 6 octets, illustrated by the following//! lie in the range from 0 to (number of MAC addresses - 1) inclusive.//! call to EMACNumAddrGet().  The value of the \e ui32Index parameter must//! number of MAC addresses that the hardware supports may be queried using a//! may be programmed independently and used to filter incoming packets.  The//! The controller may support several Ethernet MAC address slots, each of which//! packets.//! the local node's MAC address which is inserted into all transmitted//! packets (when promiscuous mode is not enabled).  Index 0 is used to hold//! Ethernet controller for hardware-level filtering of incoming Ethernet//! \e pui8MACAddr into the Ethernet controller.  This address is used by the//! This function programs the IEEE-defined MAC-48 address specified in//! \param pui8MACAddr is the pointer to the array of MAC-48 address octets.//! \param ui32Index is the zero-based index of the MAC address to set.//! Sets the MAC address of the Ethernet controller.// 2048 bytes.// Jumbo frames are not enabled so the watchdog kicks in at// bytes.// Jumbo frames are enabled so the watchdog kicks in at 10240// by whether or not jumbo frame mode is enabled.// register is not enabled so the maximum packet size is determined// The maximum packet size override found in the watchdog timer// from the watchdog timeout register.// The watchdog is enables so the maximum packet length can be read// Get the receive packet size watchdog value.// Return the current configuration flags from the EMAC_O_CFG register.// Return the mode information from the operation mode register.//! error.//! receive packet size.  Packets larger than this are flagged as being in//! The \e pui32RxMaxFrameSize is written with the currently configured maximum//! currently enabled.//! - \b EMAC_MODE_RX_DMA_ENABLED indicates that the receive DMA engine is//! - \b EMAC_MODE_TX_DMA_ENABLED indicates that the transmit DMA engine is//! before moving on to the next frame.//! waiting for that frame to be transmitted and its status to be received//! If absent, the transmit DMA works on a single frame at any one time,//! frame to be transmitted and associated status and timestamps to be reported.//! configured to operate on a second frame while waiting for the previous//! - \b EMAC_MODE_OPERATE_2ND_FRAME indicates that the transmit DMA is//! the receive FIFO due to the receive threshold setting.//! dropped by the receiver unless it has already started transferring them to//! the application.  If this option is not reported, all undersized frames are//! (frames shorter than 64 bytes but with no errors) are being forwarded to//! - \b EMAC_MODE_RX_UNDERSIZED_FRAMES indicates that undersized frames//! errors detected in the frames.//! error frames are being forwarded to the receive DMA regardless of any//! - \b EMAC_MODE_RX_ERROR_FRAMES indicates that all frames other than runt//! ignored.//! to the transmit FIFO.  If this mode is enabled, the transmit threshold is//! configured to transmit a frame only after the whole frame has been written//! - \b EMAC_MODE_TX_STORE_FORWARD indicates that the transmitter is//! unavailable.//! frames is disabled in cases where receive descriptors or buffers are//! - \b EMAC_MODE_RX_FLUSH_DISABLE indicates that the flushing of received//! been written to it.  If this mode is enabled, the receive threshold is//! configured to read frames from the FIFO only after the complete frame has//! - \b EMAC_MODE_RX_STORE_FORWARD indicates that the receive DMA is//! \b EMAC_MODE_RX_ERROR_FRAMES is also reported.//! all frames with any detected error are discarded unless//! the frames have errors only in the payload.  If this flag is not reported,//! any errors (including FCS errors) in the Ethernet framing.  In these cases,//! errors are being forwarded to the application if those frames do not have//! - \b EMAC_MODE_KEEP_BAD_CRC indicates that frames with TCP/IP checksum//! The following additional flags may be included://! - \b EMAC_MODE_RX_THRESHOLD_128_BYTES//! - \b EMAC_MODE_RX_THRESHOLD_96_BYTES//! - \b EMAC_MODE_RX_THRESHOLD_32_BYTES//! - \b EMAC_MODE_RX_THRESHOLD_64_BYTES//! is reported://! \b EMAC_MODE_RX_STORE_FORWARD is included.  One of the following values//! or this number of bytes.  This field should be ignored if//! received data begin either when the receive FIFO contains a full frame//! The second field reports the receive FIFO threshold.  DMA transfers of//! - \b EMAC_MODE_TX_THRESHOLD_256_BYTES//! - \b EMAC_MODE_TX_THRESHOLD_192_BYTES//! - \b EMAC_MODE_TX_THRESHOLD_128_BYTES//! - \b EMAC_MODE_TX_THRESHOLD_64_BYTES//! - \b EMAC_MODE_TX_THRESHOLD_40_BYTES//! - \b EMAC_MODE_TX_THRESHOLD_32_BYTES//! - \b EMAC_MODE_TX_THRESHOLD_24_BYTES//! - \b EMAC_MODE_TX_THRESHOLD_16_BYTES//! values is reported://! \b EMAC_MODE_TX_STORE_FORWARD is also reported.  One of the following//! exists in the transmit FIFO.  This field should be ignored if//! Transmission of a frame begins when this amount of data or a full frame//! following fields.  The first field reports the transmit FIFO threshold.//! related to the internal MAC FIFOs.  It comprises a logical OR of the//! The \e pui32ModeFlags parameter is written with operating parameters//! - \b EMAC_CONFIG_RX_ENABLED indicates that the MAC receiver is//! - \b EMAC_CONFIG_TX_ENABLED indicates that the MAC transmitter is//! carrier sense signal on the MII.//! bit times (or 155680 bit times in Jumbo frame mode) due to an active//! reports an error if it is unable to transmit a frame for more than 24288 //! checking is disabled in half-duplex mode.  When enabled, the transmitter//! - \b EMAC_CONFIG_DEFERRAL_CHK_ENABLE indicates that transmit deferral//! frames are forwarded to the application.//! (frame check sequence) from all Ether type frames are being stripped before//! - \b EMAC_CONFIG_AUTO_CRC_STRIPPING indicates that the last 4 bytes//! reported in the transmit frame status.//! condition causes the current frame to be ignored and a frame abort to be //! in cases where half-duplex mode is in use and a collision occurs.  This//! - \b EMAC_CONFIG_RETRY_DISABLE indicates that retransmission is disabled//! fields in the DMA receive descriptors.//! enabled.  The results of the checksum calculations are reported via status//! checking and IPv4 or IPv6 TCP, UPD or ICMP payload checksum checking is//! - \b EMAC_CONFIG_CHECKSUM_OFFLOAD indicates that IPv4 header checksum//! - \b EMAC_CONFIG_LOOPBACK indicates that internal loopback is enabled.//! frames is disabled when operating in half-duplex mode.//! - \b EMAC_CONFIG_RX_OWN_DISABLE indicates that reception of transmitted//! signaling to communicate with the PHY.//! - \b EMAC_CONFIG_100MBPS indicates that the MAC is using 100Mbps//! during transmission when operating in half-duplex mode.//! - \b EMAC_CONFIG_CS_DISABLE indicates that Carrier Sense is disabled//! (or 9022 if using VLAN tagging) are enabled.//! - \b EMAC_CONFIG_JUMBO_ENABLE indicates that Jumbo Frames of up to 9018//! any one frame.//! (or 10240 if \b EMAC_CONFIG_JUMBO_ENABLE is reported) bytes to be sent in//! transmitted.  If this flag is absent, the MAC does not allow more than 2048//! transmitter is disabled, allowing frames of up to 16384 bytes to be//! - \b EMAC_CONFIG_JABBER_DISABLE indicates that the the jabber timer on the//! type frames is being stripped and dropped before the frame is forwarded to//! - \b EMAC_CONFIG_STRIP_CRC indicates that the 4-byte CRC of all Ethernet//! \b EMAC_CONFIG_JUMBO_ENABLE is also reported.//! frames.  The value of this flag should be ignored if//! not reported, all frames larger than 2000 bytes are treated as Giant//! bytes in length as normal packets.  When \b EMAC_CONFIG_JUMBO_ENABLE is//! packets is enabled.  When present, the MAC considers all frames up to 2000//! - \b EMAC_CONFIG_2K_PACKETS indicates that IEEE802.3as support for 2K//! The following additional flags may also be included://! - \b EMAC_CONFIG_HALF_DUPLEX//! - \b EMAC_CONFIG_FULL_DUPLEX//! reported by one of the following flags://! Whether the interface attempts to operate in full- or half-duplex mode is//! descriptor, allowing control on a frame-by-frame basis.//! insertion or deletion to be controlled by fields in the DMA transmit//! - \b EMAC_CONFIG_SA_FROM_DESCRIPTOR causes control of source address//! the selected address in all transmitted frames.//! - \b EMAC_CONFIG_SA_REPLACE causes the MAC address to be replaced with//! was specified) to be inserted into all transmitted frames.//! on whether \b EMAC_CONFIG_USE_MACADDR0 or \b EMAC_CONFIG_USE_MACADDR1//! - \b EMAC_CONFIG_SA_INSERT causes the MAC address (0 or 1 depending//! transmitted frames is described by one of the following fields://! Handling of insertion or replacement of the source address in all//! - \b EMAC_CONFIG_BO_LIMIT_2//! - \b EMAC_CONFIG_BO_LIMIT_16//! - \b EMAC_CONFIG_BO_LIMIT_256//! - \b EMAC_CONFIG_BO_LIMIT_1024//! backoff-limit.//! lower of (2 ** N) and a random number between 0 and the reported//! case the retransmission delay in terms of 512 bit time slots, is the//! of the following values provides the currently selected limit.  In each//! delays after a collision and before attempting to retransmit a frame.  One//! The back-off limit determines the range of the random time that the MAC//! - \b EMAC_CONFIG_3BYTE_PREAMBLE//! - \b EMAC_CONFIG_5BYTE_PREAMBLE//! - \b EMAC_CONFIG_7BYTE_PREAMBLE//! frame is described using one of the following values://! The number of bytes of preamble added to the beginning of every transmitted//! - \b EMAC_CONFIG_IF_GAP_40BITS//! - \b EMAC_CONFIG_IF_GAP_48BITS//! - \b EMAC_CONFIG_IF_GAP_56BITS//! - \b EMAC_CONFIG_IF_GAP_64BITS//! - \b EMAC_CONFIG_IF_GAP_72BITS//! - \b EMAC_CONFIG_IF_GAP_80BITS//! - \b EMAC_CONFIG_IF_GAP_88BITS//! - \b EMAC_CONFIG_IF_GAP_96BITS//! following values://! The interframe gap between transmitted frames is given using one of the//! - \b EMAC_CONFIG_USE_MACADDR0//! - \b EMAC_CONFIG_USE_MACADDR1//! are//! during insertion or replacement for all transmitted frames.  Valid options//! fields and flags.  The first field describes which MAC address is used//! The \e pui32Config parameter is written with the logical OR of various//! MAC and its DMA engines.//! This function is called to query the basic operating parameters for the//! maximum receive frame size.//! \param pui32RxMaxFrameSize points to storage that is written with the//! information.//! \param pui32Mode points to storage that is written with Ethernet MAC mode//! \param pui32Config points to storage that is written with Ethernet MAC//! Returns the Ethernet MAC's current basic configuration parameters.// Set the operating mode register.// the override.// that the default maximum frame size should be used so just turn off// Set the maximum receive frame size.  If 0 is passed, this implies// MII and RMII interfaces to the PHYs.// OR in the EMAC_CFG_PS bit here since this implementation supports only// Set the configuration flags as specified.  Note that we unconditionally// caller needing to explicitly remove these bits from the parameter.// makes back-to-back EMACConfigGet/EMACConfigSet calls work without the// here because we'll mask them off before writing the value and this// Parameter sanity check.  Note that we allow TX_ENABLED and RX_ENABLED//! flagged as an error.//! whether the MAC is configured for normal or Jumbo frame operation, is//! received which is longer than the \e ui32RxMaxFrameSize, regardless of//! to 0, the default hardware settings are applied.  If non-zero, any frame//! before that frame is flagged as being in error.  If the parameter is set//! setting for the maximum number of bytes that can be received in a frame//! The \e ui32RxMaxFrameSize parameter may be used to override the default//! frame.//! transmitted and its status to be received before moving on to the next//! DMA works on a single frame at any one time, waiting for that frame to be//! associated status and timestamps to be reported.  If absent, the transmit//! second frame while waiting for the previous frame to be transmitted and//! - \b EMAC_MODE_OPERATE_2ND_FRAME enables the transmit DMA to operate on a//! the receive threshold setting.//! unless it has already started transferring them to the receive FIFO due to//! option is not selected, all undersized frames are dropped by the receiver//! shorter than 64 bytes but with no errors) to the application.  If this//! - \b EMAC_MODE_RX_UNDERSIZED_FRAMES causes undersized frames (frames//! in the frames.//! frames to be forwarded to the receive DMA regardless of any errors detected//! - \b EMAC_MODE_RX_ERROR_FRAMES causes all frames other than runt error//! transmit FIFO.  If this mode is enabled, the transmit threshold is ignored.//! transmitting a frame only after the whole frame has been written to the//! - \b EMAC_MODE_TX_STORE_FORWARD causes the transmitter to start//! in cases where receive descriptors or buffers are unavailable.//! - \b EMAC_MODE_RX_FLUSH_DISABLE disables the flushing of received frames//! this mode is enabled, the receive threshold is ignored.//! from the FIFO only after the complete frame has been written to it.  If//! - \b EMAC_MODE_RX_STORE_FORWARD causes the receive DMA to read frames//! is also specified.//! with any detected error are discarded unless \b EMAC_MODE_RX_ERROR_FRAMES//! have errors only in the payload.  If this flag is not specified, all frames//! (including FCS errors) in the Ethernet framing.  In these cases, the frames//! to be forwarded to the application if those frames do not have any errors//! - \b EMAC_MODE_KEEP_BAD_CRC causes frames with TCP/IP checksum errors//! The following additional flags may be specified://! specified://! \b EMAC_MODE_RX_STORE_FORWARD is included.  One of the following must be//! or this number of bytes.  This field is ignored if//! The second field controls the receive FIFO threshold.  DMA transfers of//! included.  One of the following must be specified://! FIFO.  This field is ignored if \b EMAC_MODE_TX_STORE_FORWARD is//! begins when this amount of data or a full frame exists in the transmit//! The first selects the transmit FIFO threshold.  Transmission of a frame//! internal MAC FIFOs.  It comprises a logical OR of the following fields.//! The \e ui32ModeFlags parameter sets operating parameters related to the//! the MII.//! bit times in Jumbo frame mode) due to an active carrier sense signal on//! is unable to transmit a frame for more than 24288 bit times (or 155680 //! in half-duplex mode.  When enabled, the transmitter reports an error if it //! - \b EMAC_CONFIG_DEFERRAL_CHK_ENABLE enables transmit deferral checking//! application.//! sequence) from all Ether type frames before forwarding the frames to the//! - \b EMAC_CONFIG_AUTO_CRC_STRIPPING strips the last 4 bytes (frame check//! transmit frame status.//! the current frame to be ignored and a frame abort to be reported in the //! half-duplex mode is in use and a collision occurs.  This condition causes //! - \b EMAC_CONFIG_RETRY_DISABLE disables retransmission in cases where//! receive descriptors.//! of the checksum calculations are reported via status fields in the DMA//! and IPv4 or IPv6 TCP, UPD or ICMP payload checksum checking.  The results//! - \b EMAC_CONFIG_CHECKSUM_OFFLOAD enables IPv4 header checksum checking//! - \b EMAC_CONFIG_LOOPBACK enables internal loopback.//! when operating in half-duplex mode.//! - \b EMAC_CONFIG_RX_OWN_DISABLE disables reception of transmitted frames//! - \b EMAC_CONFIG_CS_DISABLE disables Carrier Sense during transmission//! provided transmit and receive clocks.//! or an external MII PHY, the signaling rate is controlled by the PHY-//! been made as a result of auto-negotiation.  When using the internal PHY //! PHY where the selected rate must match the PHY's setting which may have //! signaling.  This speed setting is important when using an external RMII //! 100Mbps signaling.  If this option is not specified, the MAC uses 10Mbps //! - \b EMAC_CONFIG_100MBPS forces the MAC to communicate with the PHY using//! giant frame errors.//! up to 9018 (or 9022 if using VLAN tagging) to be handled without reporting//! - \b EMAC_CONFIG_JUMBO_ENABLE enables Jumbo Frames, allowing frames of//! \b EMAC_CONFIG_JUMBO_ENABLE is specified) bytes to be sent in any one//! this flag is absent, the MAC does not allow more than 2048 (or 10240 if//! transmitter and enables frames of up to 16384 bytes to be transmitted.  If//! - \b EMAC_CONFIG_JABBER_DISABLE disables the jabber timer on the//! frames to be stripped and dropped before the frame is forwarded to the//! - \b EMAC_CONFIG_STRIP_CRC causes the 4-byte CRC of all Ethernet type//! ignored if \b EMAC_CONFIG_JUMBO_ENABLE is specified.//! frames larger than 2000 bytes are treated as Giant frames.  This flag is//! normal packets.  When \b EMAC_CONFIG_JUMBO_ENABLE is not specified, all//! When specified, the MAC considers all frames up to 2000 bytes in length as//! - \b EMAC_CONFIG_2K_PACKETS enables IEEE802.3as support for 2K packets.//! The following additional flags may also be specified://! controlled by one of the following flags://! transmitted frames is provided by using one of the following fields://! Control over insertion or replacement of the source address in all//! (2 ** N) and a random number between 0 and the selected backoff-limit.//! the retransmission delay in terms of 512 bit time slots, is the lower of //! of the following values must be used to select this limit.  In each case,//! frame is selected using one of the following values://! the following values://! The interframe gap between transmitted frames is controlled using one of//! - \b EMAC_CONFIG_USE_MACADDR1 and//! insertion or replacement for all transmitted frames.  Valid options are//! flags.  The first field determines which MAC address is used during//! The \e ui32Config parameter is the logical OR of various fields and//! This function is called to configure basic operating parameters for the//! an error is reported.//! \param ui32RxMaxFrameSize sets the maximum receive frame size above which//! receive DMA engines.//! \param ui32ModeFlags provides configuration relating to the transmit and//! \param ui32Config provides various flags and values configuring the MAC.//! Configures basic Ethernet MAC operation parameters.// Reset the MAC regardless of whether the PHY connection changed or not.// Disable the external clock.// Select and enable the external clock from the RMII PHY.// Clock Configuration Register.// If using an external RMII PHY, we must set 2 bits in the Ethernet MAC// Delay a bit longer to ensure that the PHY reset has completed.// Wait for the PHY reset to complete.// latched there.// If using the internal PHY, reset it to ensure that new configuration is// Write the Ethernet PHY configuration to the peripheral configuration//! previous MAC configuration is lost.//! As a side effect of this function, the Ethernet MAC is reset so any//! line.//! - \b EMAC_PHY_INT_HOLD prevents the PHY from transmitting energy on the//! the default value of PHY register MR9 bits [13:11] to 3b111).//! 10Base-T half or full duplex, and 100Base-T half or full duplex modes (sets//! - \b EMAC_PHY_AN_100B_T_FULL_DUPLEX enables auto-negotiation and advertises//! default value of PHY register MR9 bits [13:11] to 3b110).//! 10Base-T half or full duplex, and 100Base-T half duplex modes (sets the//! - \b EMAC_PHY_AN_100B_T_HALF_DUPLEX enables auto-negotiation and advertises//! MR9 bits [13:11] to 3b101).//! 10Base-T half or full duplex modes (sets the default value of PHY register//! - \b EMAC_PHY_AN_10B_T_FULL_DUPLEX enables auto-negotiation and advertises//! [13:11] to 3b100).//! 10Base-T, half duplex mode (sets the default value of PHY register MR9 bits//! - \b EMAC_PHY_AN_10B_T_HALF_DUPLEX enables auto-negotiation and advertises//! register MR9 bits [13:11] to 3b011).//! operation in 100Base-T, full duplex mode (sets the default value of PHY//! - \b EMAC_PHY_FORCE_100B_T_FULL_DUPLEX disables auto-negotiation and forces//! register MR9 bits [13:11] to 3b010).//! operation in 100Base-T, half duplex mode (sets the default value of PHY//! - \b EMAC_PHY_FORCE_100B_T_HALF_DUPLEX disables auto-negotiation and forces//! register MR9 bits [13:11] to 3b001).//! operation in 10Base-T, full duplex mode (sets the default value of PHY//! - \b EMAC_PHY_FORCE_10B_T_FULL_DUPLEX disables auto-negotiation and forces//! register MR9 bits [13:11] to 3b000).//! operation in 10Base-T, half duplex mode (sets the default value of PHY//! - \b EMAC_PHY_FORCE_10B_T_HALF_DUPLEX disables auto-negotiation and forces//! 3b110).//! respectively (sets the default value of PHY register MR9 bits [4:2] to//! break link, link fail inhibit and wait timers set to 140, 150 and 100//! - \b EMAC_PHY_INT_FAST_AN_140_150_100 enables fast auto-negotiation using//! 3b101).//! break link, link fail inhibit and wait timers set to 120, 75 and 50//! - \b EMAC_PHY_INT_FAST_AN_120_75_50 enables fast auto-negotiation using//! 3b100).//! break link, link fail inhibit and wait timers set to 80, 50 and 35//! - \b EMAC_PHY_INT_FAST_AN_80_50_35 enables fast auto-negotiation using//! MR10 bit 5).//! link partner in forced 100B-TX (sets the default value of PHY register//! - \b EMAC_PHY_INT_EXT_FULL_DUPLEX forces full-duplex while working with a//! detection (sets the default value of PHY register MR10 bit 6)//! - \b EMAC_PHY_INT_FAST_L_UP_DETECT enables fast link-up time during parallel//! default value of PHY register MR9 bit 1).//! - \b EMAC_PHY_INT_FAST_RXDV_DETECT enables fast RXDV detection (set the//! default value of PHY register MR9 bit 14).//! - \b EMAC_PHY_INT_MDIX_EN enables auto-MDI/MDIX crossover (sets the//! default value of PHY register MR9 bit 6).//! - \b EMAC_PHY_INT_FAST_MDIX enables fast auto-MDI/MDIX resolution (sets the//! default value of PHY register MR9 bit 5).//! - \b EMAC_PHY_INT_ROBUST_MDIX enables robust auto MDI-X resolution (sets the//! 6).//! pair and transmit on TPRD (sets the default value of PHY register MR11 bit//! - \b EMAC_PHY_INT_MDI_SWAP swaps the MDI pairs putting receive on the TPTD//! pairs (sets the default value of PHY register MR11 bit 5).//! - \b EMAC_PHY_INT_POLARITY_SWAP inverts the polarity on both TPTD and TPRD//! indicates Energy Loss (sets the default value of PHY register MR11 bit 0).//! - \b EMAC_PHY_INT_LD_ON_SIGNAL_ENERGY enables link down if energy detector//! register MR11 bit 1).//! is crossed 20 times in a 10 us-interval (sets the default value of PHY//! - \b EMAC_PHY_INT_LD_ON_LOW_SNR enables link down if the low SNR threshold//! MR11 bit 2).//! count reaches 20 in a 10 us-interval (sets the default value of PHY register//! - \b EMAC_PHY_INT_LD_ON_MTL3_ERR_COUNT enables link down if the MTL3 error//! PHY register MR11 bit 3).//! error count reaches 32 within a 10-us interval (sets the default value of//! - \b EMAC_PHY_INT_LD_ON_RX_ERR_COUNT enables link down if the receiver//! down event (sets the default value of PHY register MR9, bit 8).//! - \b EMAC_PHY_INT_TDRRUN enables execution of the TDR procedure after a link//! default value of PHY register MR9, bit 7).//! - \b EMAC_PHY_INT_LINK_LOSS_RECOVERY enables link loss recovery (sets the//! register MR10, bit 3).//! established in 100B-T and full duplex modes (sets the default value of PHY//! - \b EMAC_PHY_INT_ISOLATE_MII_LLOSS ties the MII outputs low if no link is//! idle  (sets the default value of PHY register MR10, bit 2).//! - \b EMAC_PHY_INT_RX_ER_DURING_IDLE enables receive error detection during//! detection (sets the default value of PHY register MR10, bit 1).//! - \b EMAC_PHY_INT_NIB_TXERR_DET_DIS disables odd nibble transmit error//! are ignored if an external PHY is selected.//! into \e ui32Config to control various PHY features and modes.  These flags //! If \b EMAC_PHY_TYPE_INTERNAL is selected, the following flags may be ORed//! RMII interface.//! - \b EMAC_PHY_TYPE_EXTERNAL_RMII selects an external PHY connected via the//! MII interface.//! - \b EMAC_PHY_TYPE_EXTERNAL_MII selects an external PHY connected via the//! - \b EMAC_PHY_TYPE_INTERNAL selects the internal Ethernet PHY.//! The \e ui32Config parameter must specify one of the following values://!     EMACConfigSet(EMAC0_BASE, <parameters>);//!              <Rx burst size>, <Tx burst size>, <desc skip>);//!     EMACInit(EMAC0_BASE, <system clock rate>, <bus config>,//!     // Initialize and configure the MAC.//!     EMACPHYConfigSet(EMAC0_BASE, <config>);//!     // Set the PHY type and configuration options.//!     }//!     {//!     while(!MAP_SysCtlPeripheralReady(SYSCTL_PERIPH_EMAC0))//!     // Ensure the MAC is completed its reset.//!         SysCtlPeripheralReset(SYSCTL_PERIPH_EPHY0);//!         SysCtlPeripheralEnable(SYSCTL_PERIPH_EPHY0);//!         // Enable and reset the internal PHY.//!     if(<using internal PHY>)//!     SysCtlPeripheralReset(SYSCTL_PERIPH_EMAC0);//!     SysCtlPeripheralEnable(SYSCTL_PERIPH_EMAC0);//!     // Enable and reset the MAC.//! sequence to select and configure the PHY, therefore, must be as follows://! by this function are latched by the hardware only on a MAC reset.  The call//! the Ethernet MAC is reset during this function call because parameters used//! function also allows configuration of various PHY parameters.  Note that//! select the Ethernet PHY to be used.  If the internal PHY is selected, the//! This function must be called prior to EMACInit() and EMACConfigSet() to//! PHY, allows various various PHY parameters to be configured.//! \param ui32Config selects the PHY in use and, when using the internal//! Selects the Ethernet PHY in use.// Wait for the reset to complete.// Reset the Ethernet MAC.//! function does not return.//! enabled when this function is called.  If the PHY clock is absent, this//! \note To ensure that the reset completes, the selected PHY clock must be//! only after the hardware indicates that the reset has completed.//! and returning all registers to their default values.  The function returns //! This function performs a reset of the Ethernet MAC by resetting all logic //! Resets the Ethernet MAC.// Disable all the MMC interrupts as these are enabled by default at reset.// Set the MII CSR clock speed.// Find the MII CSR clock divider to use based on the current system clock.// Default the MII CSR clock divider based on the fastest system clock.// Finally, write the bus mode register.// No - we need to use separate burst lengths for each.// Yes - set up to use a single burst length.// Are the receive and transmit burst lengths the same?// they did, this indicates that the values passed are invalid.// Sanity check - neither burst length should have become zero.  If// multiplier.// Divide both burst lengths by 8 and set the 8X burst length// Do we need to use the 8X burst length multiplier?// 8 word descriptors so we need to OR in EMAC_DMABUSMOD_ATDS here.// Set common flags.  Note that this driver assumes we are always using// Make sure that the DMA software reset is clear before continuing.// Parameter sanity checks.//! desired.//! application-specific data and modify \e ui32DescSkipSize appropriately if//! Applications may modify these structure definitions to include their own//!  the \e pvNext pointer added to the end of each of these structures.  //! types defined for this driver, \e ui32DescSkipSize must be set to 1 to skip//! arrays of either the \b tEMACDMADescriptor or \b tEMACAltDMADescriptor //! descriptor to get to the first field of the next descriptor.  When using //! 32-bit words to skip after the last field of the hardware-defined //! defined descriptor fields.  The parameter value indicates the number of //! skip past any application-defined fields after the end of the hardware-//! in the list).  In ring mode, the hardware uses the \e ui32DescSkipSize to//! (where each descriptor includes a field that points to the next descriptor//! descriptor marked with the \b END_OF_RING flag) rather than chained mode//! using ring mode (where descriptors are contiguous in memory with the last//! The \e ui32DescSkipSize parameter is used when the descriptor lists are//! results in undefined behavior.//! transaction.  Valid values are 1, 2, 4, 8, 16 and 32.  Any other value//! number of words that the relevant DMA should transfer in a single//! The \e ui32RxBurst and \e ui32TxBurst parameters indicate the maximum//! across the system bus.//! mixed burst types depending on the length of data to be transferred//! - \b EMAC_BCONFIG_MIXED_BURST indicates that the DMA engine should use//! be used.//! - \b EMAC_BCONFIG_FIXED_BURST indicates that fixed burst transfers should//! \b EMAC_BCONFIG_PRIORITY_4_1, and \b EMAC_BCONFIG_TX_PRIORITY.//! \b EMAC_BCONFIG_PRIORITY_2_1, \b EMAC_BCONFIG_PRIORITY_3_1 or//! weighting defined using \b EMAC_BCONFIG_PRIORITY_1_1,//! specified, a weighted round-robin arbitration scheme is used with the//! transmit channel has priority.  If \b EMAC_BCONFIG_PRIORITY_FIXED is not//! priority unless \b EMAC_BCONFIG_TX_PRIORITY is set, in which case the//! for system-side bus access.  In this case, the receive channel always has//! should be employed when arbitrating between the transmit and receive DMA//! - \b EMAC_BCONFIG_PRIORITY_FIXED indicates that a fixed priority scheme//! descriptor structures.//! descriptor type.  Please see the part datasheet for information on basic//! for clarity, emac.h does not contain type definitions for the basic//! timestamping, VLAN or TCP/UDP/ICMP CRC insertion features.  Note that,//! Alternate descriptors are required if using IEEE 1588-2008 advanced//! \b tEMACDMADescriptor.  If absent, the basic descriptor type is used.//! use the alternate descriptor format as defined in type//! - \b EMAC_BCONFIG_ALT_DESCRIPTORS indicates that the DMA engine should//! address.//! the first burst is unaligned but subsequent bursts are aligned to the//! least significant bits.  If \b EMAC_BCONFIG_FIXED_BURST is not specified,//! When both flags are specified, all bursts are aligned to the start address//! \b EMAC_BCONFIG_FIXED_BURST to control address alignment of AHB bursts.//! - \b EMAC_BCONFIG_ADDR_ALIGNED works in tandem with//! defined, the receive DMA has higher priority.//! higher priority in all arbitration for the system-side bus.  If this is not//! - \b EMAC_BCONFIG_TX_PRIORITY indicates that the transmit DMA should be//! The following additional flags may also be defined://! - \b EMAC_BCONFIG_PRIORITY_4_1//! - \b EMAC_BCONFIG_PRIORITY_3_1//! - \b EMAC_BCONFIG_PRIORITY_2_1//! - \b EMAC_BCONFIG_PRIORITY_1_1//! \b EMAC_BCONFIG_PRIORITY_FIXED is specified.//! Tx:Rx.  The priority provided here is ignored if//! \b EMAC_BCONFIG_TX_PRIORITY is also specified, in which case they become//! arbitrating between the Rx and Tx DMA.  The priorities are Rx:Tx unless//! The second field sets the receive and transmit priorities used when//! - \b EMAC_BCONFIG_DMA_PRIO_WEIGHT_4//! - \b EMAC_BCONFIG_DMA_PRIO_WEIGHT_3//! - \b EMAC_BCONFIG_DMA_PRIO_WEIGHT_2//! - \b EMAC_BCONFIG_DMA_PRIO_WEIGHT_1//! first sets the DMA channel priority weight://! The \e ui32BusConfig parameter is the logical OR of various fields.  The//! after any subsequent call to EMACPHYConfigSet().//! engines.  It must be called after EMACPHYConfigSet() and called again//! This function sets bus-related parameters for the Ethernet MAC DMA//! two unchained DMA descriptors.  Values in the range 0 to 31 are valid.//! \param ui32DescSkipSize is the number of 32-bit words to skip between//! \param ui32TxBurst is the maximum transmit burst size in words.//! \param ui32RxBurst is the maximum receive burst size in words.//! DMA controller.//! \param ui32BusConfig defines the bus operating mode for the Ethernet MAC//! \param ui32SysClk is the current system clock frequency in Hertz.//! Initializes the Ethernet MAC and sets bus-related DMA parameters.// The define for accessing PHY registers in the MMD address space.// The number of clock divisors in the above table.// based on the current system clock rate.// A structure used to help in choosing the correct clock divisor for the MII// Macros aiding access to the MAC address registers.// The number of MAC addresses the module can store for filtering purposes.// masked (or enabled) via the DMAIM register.// Interrupt sources reported via the DMARIS register but which are not// Combined valid abnormal interrupts.// Combined valid normal interrupts.// Combined valid maskable interrupts.// Combined valid frame filter flags.// Combined valid configuration flags.// Combined defines used in parameter validity checks.// Copyright (c) 2013-2020 Texas Instruments Incorporated.  All rights reserved.//          Tiva devices.// emac.c - Driver for the Integrated Ethernet Controller on Snowflake-class/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/inc/hw_epi.hEPI_FIFOLVL_RDFIFO_FULLEPI_FIFOLVL_RDFIFO_7_8EPI_FIFOLVL_RDFIFO_3_4EPI_FIFOLVL_RDFIFO_1_2EPI_FIFOLVL_RDFIFO_1_4EPI_FIFOLVL_RDFIFO_1_8EPI_FIFOLVL_WRFIFO_3_4EPI_FIFOLVL_WRFIFO_1_2EPI_FIFOLVL_WRFIFO_1_4EPI_HBPSRAM_CR_SEPI_HBPSRAM_CR_M0x001FFFFFEPI_HB16TIME4_CAPWIDTH_SEPI_HB16TIME4_IRDYDLY_SEPI_HB16TIME4_RDWSMEPI_HB16TIME4_WRWSMEPI_HB16TIME4_CAPWIDTH_MEPI_HB16TIME4_PSRAMSZ_8KBEPI_HB16TIME4_PSRAMSZ_4KBEPI_HB16TIME4_PSRAMSZ_2KBEPI_HB16TIME4_PSRAMSZ_1KBEPI_HB16TIME4_PSRAMSZ_512BEPI_HB16TIME4_PSRAMSZ_256BEPI_HB16TIME4_PSRAMSZ_128BEPI_HB16TIME4_PSRAMSZ_0EPI_HB16TIME4_PSRAMSZ_MEPI_HB16TIME4_IRDYDLY_MEPI_HB8TIME4_CAPWIDTH_SEPI_HB8TIME4_IRDYDLY_SEPI_HB8TIME4_RDWSMEPI_HB8TIME4_WRWSMEPI_HB8TIME4_CAPWIDTH_MEPI_HB8TIME4_IRDYDLY_MEPI_HB8TIME3_CAPWIDTH_SEPI_HB8TIME3_IRDYDLY_SEPI_HB8TIME3_RDWSMEPI_HB8TIME3_WRWSMEPI_HB8TIME3_CAPWIDTH_MEPI_HB8TIME3_IRDYDLY_MEPI_HB16TIME3_CAPWIDTH_SEPI_HB16TIME3_IRDYDLY_SEPI_HB16TIME3_RDWSMEPI_HB16TIME3_WRWSMEPI_HB16TIME3_CAPWIDTH_MEPI_HB16TIME3_PSRAMSZ_8KBEPI_HB16TIME3_PSRAMSZ_4KBEPI_HB16TIME3_PSRAMSZ_2KBEPI_HB16TIME3_PSRAMSZ_1KBEPI_HB16TIME3_PSRAMSZ_512BEPI_HB16TIME3_PSRAMSZ_256BEPI_HB16TIME3_PSRAMSZ_128BEPI_HB16TIME3_PSRAMSZ_0EPI_HB16TIME3_PSRAMSZ_MEPI_HB16TIME3_IRDYDLY_MEPI_HB16TIME2_CAPWIDTH_SEPI_HB16TIME2_IRDYDLY_SEPI_HB16TIME2_RDWSMEPI_HB16TIME2_WRWSMEPI_HB16TIME2_CAPWIDTH_MEPI_HB16TIME2_PSRAMSZ_8KBEPI_HB16TIME2_PSRAMSZ_4KBEPI_HB16TIME2_PSRAMSZ_2KBEPI_HB16TIME2_PSRAMSZ_1KBEPI_HB16TIME2_PSRAMSZ_512BEPI_HB16TIME2_PSRAMSZ_256BEPI_HB16TIME2_PSRAMSZ_128BEPI_HB16TIME2_PSRAMSZ_0EPI_HB16TIME2_PSRAMSZ_MEPI_HB16TIME2_IRDYDLY_MEPI_HB8TIME2_CAPWIDTH_SEPI_HB8TIME2_IRDYDLY_SEPI_HB8TIME2_RDWSMEPI_HB8TIME2_WRWSMEPI_HB8TIME2_CAPWIDTH_MEPI_HB8TIME2_IRDYDLY_MEPI_HB16TIME_CAPWIDTH_SEPI_HB16TIME_IRDYDLY_SEPI_HB16TIME_RDWSMEPI_HB16TIME_WRWSMEPI_HB16TIME_CAPWIDTH_MEPI_HB16TIME_PSRAMSZ_8KBEPI_HB16TIME_PSRAMSZ_4KBEPI_HB16TIME_PSRAMSZ_2KBEPI_HB16TIME_PSRAMSZ_1KBEPI_HB16TIME_PSRAMSZ_512BEPI_HB16TIME_PSRAMSZ_256BEPI_HB16TIME_PSRAMSZ_128BEPI_HB16TIME_PSRAMSZ_0EPI_HB16TIME_PSRAMSZ_MEPI_HB16TIME_IRDYDLY_MEPI_HB8TIME_CAPWIDTH_SEPI_HB8TIME_IRDYDLY_SEPI_HB8TIME_RDWSMEPI_HB8TIME_WRWSMEPI_HB8TIME_CAPWIDTH_MEPI_HB8TIME_IRDYDLY_MEPI_HB8CFG4_MODE_ADEPI_HB8CFG4_MODE_ADMUXEPI_HB8CFG4_MODE_MEPI_HB8CFG4_RDWS_8EPI_HB8CFG4_RDWS_6EPI_HB8CFG4_RDWS_4EPI_HB8CFG4_RDWS_2EPI_HB8CFG4_RDWS_MEPI_HB8CFG4_WRWS_8EPI_HB8CFG4_WRWS_6EPI_HB8CFG4_WRWS_4EPI_HB8CFG4_WRWS_2EPI_HB8CFG4_WRWS_MEPI_HB8CFG4_ALEHIGHEPI_HB8CFG4_RDHIGHEPI_HB8CFG4_WRHIGHEPI_HB16CFG4_MODE_ADEPI_HB16CFG4_MODE_ADMUXEPI_HB16CFG4_MODE_MEPI_HB16CFG4_RDWS_8EPI_HB16CFG4_RDWS_6EPI_HB16CFG4_RDWS_4EPI_HB16CFG4_RDWS_2EPI_HB16CFG4_RDWS_MEPI_HB16CFG4_WRWS_8EPI_HB16CFG4_WRWS_6EPI_HB16CFG4_WRWS_4EPI_HB16CFG4_WRWS_2EPI_HB16CFG4_WRWS_MEPI_HB16CFG4_BURSTEPI_HB16CFG4_RDCREEPI_HB16CFG4_WRCREEPI_HB16CFG4_ALEHIGHEPI_HB16CFG4_RDHIGHEPI_HB16CFG4_WRHIGHEPI_HB16CFG3_MODE_ADEPI_HB16CFG3_MODE_ADMUXEPI_HB16CFG3_MODE_MEPI_HB16CFG3_RDWS_8EPI_HB16CFG3_RDWS_6EPI_HB16CFG3_RDWS_4EPI_HB16CFG3_RDWS_2EPI_HB16CFG3_RDWS_MEPI_HB16CFG3_WRWS_8EPI_HB16CFG3_WRWS_6EPI_HB16CFG3_WRWS_4EPI_HB16CFG3_WRWS_2EPI_HB16CFG3_WRWS_MEPI_HB16CFG3_BURSTEPI_HB16CFG3_RDCREEPI_HB16CFG3_WRCREEPI_HB16CFG3_ALEHIGHEPI_HB16CFG3_RDHIGHEPI_HB16CFG3_WRHIGHEPI_HB8CFG3_MODE_ADEPI_HB8CFG3_MODE_ADMUXEPI_HB8CFG3_MODE_MEPI_HB8CFG3_RDWS_8EPI_HB8CFG3_RDWS_6EPI_HB8CFG3_RDWS_4EPI_HB8CFG3_RDWS_2EPI_HB8CFG3_RDWS_MEPI_HB8CFG3_WRWS_8EPI_HB8CFG3_WRWS_6EPI_HB8CFG3_WRWS_4EPI_HB8CFG3_WRWS_2EPI_HB8CFG3_WRWS_MEPI_HB8CFG3_ALEHIGHEPI_HB8CFG3_RDHIGHEPI_HB8CFG3_WRHIGHEPI_EISC_TOUTEPI_EISC_RSTALLEPI_EISC_WTFULLEPI_EISC_DMARDICEPI_EISC_DMAWRICEPI_MIS_ERRMISEPI_MIS_RDMISEPI_MIS_WRMISEPI_MIS_DMARDMISEPI_MIS_DMAWRMISEPI_RIS_ERRRISEPI_RIS_RDRISEPI_RIS_WRRISEPI_RIS_DMARDRISEPI_RIS_DMAWRRISEPI_IM_ERRIMEPI_IM_RDIMEPI_IM_WRIMEPI_IM_DMARDIMEPI_IM_DMAWRIMEPI_DMATXCNT_TXCNT_SEPI_DMATXCNT_TXCNT_MEPI_WFIFOCNT_WTAV_SEPI_WFIFOCNT_WTAV_MEPI_FIFOLVL_RDFIFO_8EPI_FIFOLVL_RDFIFO_7EPI_FIFOLVL_RDFIFO_6EPI_FIFOLVL_RDFIFO_4EPI_FIFOLVL_RDFIFO_2EPI_FIFOLVL_RDFIFO_1EPI_FIFOLVL_RDFIFO_EMPTEPI_FIFOLVL_RDFIFO_MEPI_FIFOLVL_WRFIFO_NFULLEPI_FIFOLVL_WRFIFO_1EPI_FIFOLVL_WRFIFO_2EPI_FIFOLVL_WRFIFO_EMPTEPI_FIFOLVL_WRFIFO_MEPI_FIFOLVL_RSERREPI_FIFOLVL_WFERREPI_READFIFO7_DATA_SEPI_READFIFO7_DATA_MEPI_READFIFO6_DATA_SEPI_READFIFO6_DATA_MEPI_READFIFO5_DATA_SEPI_READFIFO5_DATA_MEPI_READFIFO4_DATA_SEPI_READFIFO4_DATA_MEPI_READFIFO3_DATA_SEPI_READFIFO3_DATA_MEPI_READFIFO2_DATA_SEPI_READFIFO2_DATA_MEPI_READFIFO1_DATA_SEPI_READFIFO1_DATA_MEPI_READFIFO0_DATA_SEPI_READFIFO0_DATA_MEPI_RFIFOCNT_COUNT_SEPI_RFIFOCNT_COUNT_MEPI_STAT_ACTIVEEPI_STAT_NBRBUSYEPI_STAT_WBUSYEPI_STAT_INITSEQEPI_STAT_XFEMPTYEPI_STAT_XFFULLEPI_RPSTD1_POSTCNT_SEPI_RPSTD1_POSTCNT_MEPI_RADDR1_ADDR_SEPI_RADDR1_ADDR_MEPI_RSIZE1_SIZE_32BITEPI_RSIZE1_SIZE_16BITEPI_RSIZE1_SIZE_8BITEPI_RSIZE1_SIZE_MEPI_RPSTD0_POSTCNT_SEPI_RPSTD0_POSTCNT_MEPI_RADDR0_ADDR_SEPI_RADDR0_ADDR_MEPI_RSIZE0_SIZE_32BITEPI_RSIZE0_SIZE_16BITEPI_RSIZE0_SIZE_8BITEPI_RSIZE0_SIZE_MEPI_ADDRMAP_ERADR_HBQSEPI_ADDRMAP_ERADR_8000EPI_ADDRMAP_ERADR_6000EPI_ADDRMAP_ERADR_NONEEPI_ADDRMAP_ERADR_MEPI_ADDRMAP_ERSZ_256MBEPI_ADDRMAP_ERSZ_16MBEPI_ADDRMAP_ERSZ_64KBEPI_ADDRMAP_ERSZ_256BEPI_ADDRMAP_ERSZ_MEPI_ADDRMAP_EPADR_HBQSEPI_ADDRMAP_EPADR_C000EPI_ADDRMAP_EPADR_A000EPI_ADDRMAP_EPADR_NONEEPI_ADDRMAP_EPADR_MEPI_ADDRMAP_EPSZ_256MBEPI_ADDRMAP_EPSZ_16MBEPI_ADDRMAP_EPSZ_64KBEPI_ADDRMAP_EPSZ_256BEPI_ADDRMAP_EPSZ_MEPI_ADDRMAP_ECADR_1000EPI_ADDRMAP_ECADR_NONEEPI_ADDRMAP_ECADR_MEPI_ADDRMAP_ECSZ_256MBEPI_ADDRMAP_ECSZ_16MBEPI_ADDRMAP_ECSZ_64KBEPI_ADDRMAP_ECSZ_256BEPI_ADDRMAP_ECSZ_MEPI_HB16CFG2_MODE_ADEPI_HB16CFG2_MODE_ADMUXEPI_HB16CFG2_MODE_MEPI_HB16CFG2_RDWS_8EPI_HB16CFG2_RDWS_6EPI_HB16CFG2_RDWS_4EPI_HB16CFG2_RDWS_2EPI_HB16CFG2_RDWS_MEPI_HB16CFG2_WRWS_8EPI_HB16CFG2_WRWS_6EPI_HB16CFG2_WRWS_4EPI_HB16CFG2_WRWS_2EPI_HB16CFG2_WRWS_MEPI_HB16CFG2_BURSTEPI_HB16CFG2_RDCREEPI_HB16CFG2_WRCREEPI_HB16CFG2_ALEHIGHEPI_HB16CFG2_RDHIGHEPI_HB16CFG2_WRHIGHEPI_HB16CFG2_CSCFG_ADCSEPI_HB16CFG2_CSCFG_DCSEPI_HB16CFG2_CSCFG_CSEPI_HB16CFG2_CSCFG_ALEEPI_HB16CFG2_CSCFG_MEPI_HB16CFG2_CSBAUDEPI_HB16CFG2_CSCFGEXTEPI_HB8CFG2_MODE_ADEPI_HB8CFG2_MODE_ADMUXEPI_HB8CFG2_MODE_MEPI_HB8CFG2_RDWS_8EPI_HB8CFG2_RDWS_6EPI_HB8CFG2_RDWS_4EPI_HB8CFG2_RDWS_2EPI_HB8CFG2_RDWS_MEPI_HB8CFG2_WRWS_8EPI_HB8CFG2_WRWS_6EPI_HB8CFG2_WRWS_4EPI_HB8CFG2_WRWS_2EPI_HB8CFG2_WRWS_MEPI_HB8CFG2_ALEHIGHEPI_HB8CFG2_RDHIGHEPI_HB8CFG2_WRHIGHEPI_HB8CFG2_CSCFG_ADCSEPI_HB8CFG2_CSCFG_DCSEPI_HB8CFG2_CSCFG_CSEPI_HB8CFG2_CSCFG_ALEEPI_HB8CFG2_CSCFG_MEPI_HB8CFG2_CSBAUDEPI_HB8CFG2_CSCFGEXTEPI_HB8CFG_MAXWAIT_SEPI_HB8CFG_MODE_FIFOEPI_HB8CFG_MODE_SRAMEPI_HB8CFG_MODE_NMUXEPI_HB8CFG_MODE_MUXEPI_HB8CFG_MODE_MEPI_HB8CFG_RDWS_8EPI_HB8CFG_RDWS_6EPI_HB8CFG_RDWS_4EPI_HB8CFG_RDWS_2EPI_HB8CFG_RDWS_MEPI_HB8CFG_WRWS_8EPI_HB8CFG_WRWS_6EPI_HB8CFG_WRWS_4EPI_HB8CFG_WRWS_2EPI_HB8CFG_WRWS_MEPI_HB8CFG_MAXWAIT_MEPI_HB8CFG_ALEHIGHEPI_HB8CFG_RDHIGHEPI_HB8CFG_WRHIGHEPI_HB8CFG_XFEENEPI_HB8CFG_XFFENEPI_HB8CFG_IRDYINVEPI_HB8CFG_RDYENEPI_HB8CFG_CLKINVEPI_HB8CFG_CLKGATEIEPI_HB8CFG_CLKGATEEPI_SDRAMCFG_RFSH_SEPI_SDRAMCFG_SIZE_64MBEPI_SDRAMCFG_SIZE_32MBEPI_SDRAMCFG_SIZE_16MBEPI_SDRAMCFG_SIZE_8MBEPI_SDRAMCFG_SIZE_MEPI_SDRAMCFG_SLEEPEPI_SDRAMCFG_RFSH_MEPI_SDRAMCFG_FREQ_30MHZEPI_SDRAMCFG_FREQ_15MHZEPI_SDRAMCFG_FREQ_NONEEPI_SDRAMCFG_FREQ_MEPI_GPCFG_FRMCNT_SEPI_GPCFG_DSIZE_32BITEPI_GPCFG_DSIZE_24BITEPI_GPCFG_DSIZE_16BITEPI_GPCFG_DSIZE_4BITEPI_GPCFG_DSIZE_MEPI_GPCFG_ASIZE_20BITEPI_GPCFG_ASIZE_12BITEPI_GPCFG_ASIZE_4BITEPI_GPCFG_ASIZE_NONEEPI_GPCFG_ASIZE_MEPI_GPCFG_WR2CYCEPI_GPCFG_FRMCNT_MEPI_GPCFG_FRM50EPI_GPCFG_CLKGATEEPI_GPCFG_CLKPINEPI_HB16CFG_MAXWAIT_SEPI_HB16CFG_MODE_XFIFOEPI_HB16CFG_MODE_SRAMEPI_HB16CFG_MODE_ADNMUXEPI_HB16CFG_MODE_ADMUXEPI_HB16CFG_MODE_MEPI_HB16CFG_BSELEPI_HB16CFG_RDWS_8EPI_HB16CFG_RDWS_6EPI_HB16CFG_RDWS_4EPI_HB16CFG_RDWS_2EPI_HB16CFG_RDWS_MEPI_HB16CFG_WRWS_8EPI_HB16CFG_WRWS_6EPI_HB16CFG_WRWS_4EPI_HB16CFG_WRWS_2EPI_HB16CFG_WRWS_MEPI_HB16CFG_MAXWAIT_MEPI_HB16CFG_BURSTEPI_HB16CFG_RDCREEPI_HB16CFG_WRCREEPI_HB16CFG_ALEHIGHEPI_HB16CFG_RDHIGHEPI_HB16CFG_WRHIGHEPI_HB16CFG_XFEENEPI_HB16CFG_XFFENEPI_HB16CFG_IRDYINVEPI_HB16CFG_RDYENEPI_HB16CFG_CLKINVEPI_HB16CFG_CLKGATEIEPI_HB16CFG_CLKGATEEPI_BAUD2_COUNT0_SEPI_BAUD2_COUNT1_SEPI_BAUD2_COUNT0_MEPI_BAUD2_COUNT1_MEPI_BAUD_COUNT0_SEPI_BAUD_COUNT1_SEPI_BAUD_COUNT0_MEPI_BAUD_COUNT1_MEPI_CFG_MODE_HB16EPI_CFG_MODE_HB8EPI_CFG_MODE_SDRAMEPI_CFG_MODE_NONEEPI_CFG_MODE_MEPI_CFG_BLKENEPI_CFG_INTDIVEPI_O_HBPSRAM0x00000360EPI_O_HB16TIME40x0000031CEPI_O_HB8TIME4EPI_O_HB8TIME30x00000318EPI_O_HB16TIME3EPI_O_HB16TIME20x00000314EPI_O_HB8TIME2EPI_O_HB16TIME0x00000310EPI_O_HB8TIMEEPI_O_HB8CFG4EPI_O_HB16CFG4EPI_O_HB16CFG3EPI_O_HB8CFG3EPI_O_EISC0x0000021CEPI_O_MIS0x00000218EPI_O_RIS0x00000214EPI_O_IM0x00000210EPI_O_DMATXCNT0x00000208EPI_O_WFIFOCNT0x00000204EPI_O_FIFOLVLEPI_O_READFIFO7EPI_O_READFIFO6EPI_O_READFIFO5EPI_O_READFIFO4EPI_O_READFIFO3EPI_O_READFIFO2EPI_O_READFIFO1EPI_O_READFIFO0EPI_O_RFIFOCNTEPI_O_STATEPI_O_RPSTD1EPI_O_RADDR1EPI_O_RSIZE1EPI_O_RPSTD0EPI_O_RADDR0EPI_O_RSIZE0EPI_O_ADDRMAPEPI_O_HB16CFG2EPI_O_HB8CFG2EPI_O_HB8CFGEPI_O_SDRAMCFGEPI_O_GPCFGEPI_O_HB16CFGEPI_O_BAUD2EPI_O_BAUDEPI_O_CFG__HW_EPI_H__// __HW_EPI_H__// in the NBRFIFO// Trigger when there are 8 entries// entries in the NBRFIFO// Trigger when there are 7 or more// Trigger when there are 6 or more// Trigger when there are 4 or more// Trigger when there are 2 or more// Trigger when there are 1 or more// available in the WFIFO// Trigger when there is 1 space// spaces available in the WFIFO// Trigger when there are up to 2// Trigger when there are up to 3// The following are deprecated defines for the bit fields in the EPI_O_FIFOLVL// PSRAM Config Register// The following are defines for the bit fields in the EPI_O_HBPSRAM register.// CS3n Read Wait State Minus One// CS3n Write Wait State Minus One// Width// CS3n Inter-transfer Capture// 8192 B// 4096 B// 2048 B// 1024 B// 512 B// 256 B// 128 B// No row size limitation// PSRAM Row Size// CS3n Input Ready Delay// The following are defines for the bit fields in the EPI_O_HB16TIME4// The following are defines for the bit fields in the EPI_O_HB8TIME4 register.// CS2n Read Wait State Minus One// CS2n Write Wait State Minus One// CS2n Inter-transfer Capture// CS2n Input Ready Delay// The following are defines for the bit fields in the EPI_O_HB8TIME3 register.// The following are defines for the bit fields in the EPI_O_HB16TIME3// CS1n Read Wait State Minus One// CS1n Write Wait State Minus One// CS1n Inter-transfer Capture// CS1n Input Ready Delay// The following are defines for the bit fields in the EPI_O_HB16TIME2// The following are defines for the bit fields in the EPI_O_HB8TIME2 register.// Read Wait State Minus One// Write Wait State Minus One// CS0n Inter-transfer Capture// CS0n Input Ready Delay// The following are defines for the bit fields in the EPI_O_HB16TIME register.// The following are defines for the bit fields in the EPI_O_HB8TIME register.// ADNONMUX - D[7:0]// ADMUX - AD[7:0]// CS3n Host Bus Sub-Mode// Active RDn is 8 EPI clocks// Active RDn is 6 EPI clocks// Active RDn is 4 EPI clocks// Active RDn is 2 EPI clocks// CS3n Read Wait States// Active WRn is 8 EPI clocks// Active WRn is 6 EPI clocks// Active WRn is 4 EPI clocks// Active WRn is 2 EPI clocks// CS3n Write Wait States// CS3n ALE Strobe Polarity// CS2n READ Strobe Polarity// CS3n WRITE Strobe Polarity// The following are defines for the bit fields in the EPI_O_HB8CFG4 register.// ADNONMUX - D[15:0]// ADMUX - AD[15:0]// CS3n Burst Mode// Register Read// CS3n PSRAM Configuration// Register Write// CS3n READ Strobe Polarity// The following are defines for the bit fields in the EPI_O_HB16CFG4 register.// CS2n Host Bus Sub-Mode// CS2n Read Wait States// CS2n Write Wait States// CS2n Burst Mode// CS2n PSRAM Configuration// CS2n ALE Strobe Polarity// CS2n WRITE Strobe Polarity// The following are defines for the bit fields in the EPI_O_HB16CFG3 register.// The following are defines for the bit fields in the EPI_O_HB8CFG3 register.// Timeout Error// Read Stalled Error// Write FIFO Full Error// Read uDMA Interrupt Clear// Write uDMA Interrupt Clear// The following are defines for the bit fields in the EPI_O_EISC register.// Error Masked Interrupt Status// Read Masked Interrupt Status// Write Masked Interrupt Status// Read uDMA Masked Interrupt// Write uDMA Masked Interrupt// The following are defines for the bit fields in the EPI_O_MIS register.// Error Raw Interrupt Status// Read Raw Interrupt Status// Write Raw Interrupt Status// Read uDMA Raw Interrupt Status// Write uDMA Raw Interrupt Status// The following are defines for the bit fields in the EPI_O_RIS register.// Error Interrupt Mask// Read FIFO Full Interrupt Mask// Write FIFO Empty Interrupt Mask// Read uDMA Interrupt Mask// Write uDMA Interrupt Mask// The following are defines for the bit fields in the EPI_O_IM register.// DMA Count// The following are defines for the bit fields in the EPI_O_DMATXCNT register.// Available Write Transactions// The following are defines for the bit fields in the EPI_O_WFIFOCNT register.// Empty// Read FIFO// are four entries in the WRFIFO// continue to assert until there// not full, meaning trigger will// Trigger interrupt when WRFIFO is// expects only single writes// available. This configuration// there is one WRFIFO entry// Interrupt is triggered until// bursts of 2// configuration is optimized for// WRFIFO entries present. This// deasserted when there are two// available. Thus, trigger is// there are only two slots// WRFIFO is empty.// Interrupt is triggered while// Write FIFO// Read Stall Error// Write Full Error// The following are defines for the bit fields in the EPI_O_FIFOLVL register.// Reads Data// The following are defines for the bit fields in the EPI_O_READFIFO7// The following are defines for the bit fields in the EPI_O_READFIFO6// The following are defines for the bit fields in the EPI_O_READFIFO5// The following are defines for the bit fields in the EPI_O_READFIFO4// The following are defines for the bit fields in the EPI_O_READFIFO3// The following are defines for the bit fields in the EPI_O_READFIFO2// The following are defines for the bit fields in the EPI_O_READFIFO1// The following are defines for the bit fields in the EPI_O_READFIFO0// FIFO Count// The following are defines for the bit fields in the EPI_O_RFIFOCNT register.// Register Active// Non-Blocking Read Busy// Initialization Sequence// External FIFO Empty// External FIFO Full// The following are defines for the bit fields in the EPI_O_STAT register.// Post Count// The following are defines for the bit fields in the EPI_O_RPSTD1 register.// Current Address// The following are defines for the bit fields in the EPI_O_RADDR1 register.// Word (32 bits)// Half-word (16 bits)// Byte (8 bits)// Current Size// The following are defines for the bit fields in the EPI_O_RSIZE1 register.// The following are defines for the bit fields in the EPI_O_RPSTD0 register.// The following are defines for the bit fields in the EPI_O_RADDR0 register.// The following are defines for the bit fields in the EPI_O_RSIZE0 register.// 0x8000.0000// 0x6000.0000 and CS1n maps to// select mode, CS0n maps to// quad chip select. In quad chip// Only to be used with Host Bus// At 0x8000.0000// At 0x6000.0000// Not mapped// External RAM Address// 0x000.0000 to 0xFFF.FFFF// 256 MB; lower address range:// 0x00.0000 to 0xFF.FFFF// 16 MB; lower address range:// 0x0000 to 0xFFFF// 64 KB; lower address range:// 0x00 to 0xFF// 256 bytes; lower address range:// External RAM Size// 0xC000.0000// 0xA000.0000 and CS3n maps to// select mode, CS2n maps to// At 0xC000.0000// At 0xA000.0000// External Peripheral Address// External Peripheral Size// At 0x1000.0000// External Code Address// 0x000.0000 to 0x0FFF.FFFF// 256MB; lower address range:// External Code Size// The following are defines for the bit fields in the EPI_O_ADDRMAP register.// CS1n Host Bus Sub-Mode// CS1n Read Wait States// CS1n Write Wait States// CS1n Burst Mode// CS1n PSRAM Configuration// CS1n ALE Strobe Polarity// CS1n READ Strobe Polarity// CS1n WRITE Strobe Polarity// ALE with Dual CSn Configuration// Dual CSn Configuration// CSn Configuration// ALE Configuration// Chip Select Configuration// enable// Multiple Sub-Mode Configuration// Chip Select Baud Rate and// Chip Select Extended// The following are defines for the bit fields in the EPI_O_HB16CFG2 register.// The following are defines for the bit fields in the EPI_O_HB8CFG2 register.// XFIFO - D[7:0]// Continuous Read - D[7:0]// Host Bus Sub-Mode// Read Wait States// Write Wait States// Maximum Wait// ALE Strobe Polarity// READ Strobe Polarity// WRITE Strobe Polarity// External FIFO EMPTY Enable// External FIFO FULL Enable// Input Ready Invert// Input Ready Enable// Invert Output Clock Enable// Clock Gated when Idle// Clock Gated// The following are defines for the bit fields in the EPI_O_HB8CFG register.// 512 megabits (64MB)// 256 megabits (32MB)// 128 megabits (16MB)// 64 megabits (8MB)// Size of SDRAM// Sleep Mode// Refresh Counter// 30 - 50 MHz// 15 - 30 MHz// 0 - 15 MHz// EPI Frequency Range// The following are defines for the bit fields in the EPI_O_SDRAMCFG register.// 32 Bits Wide (EPI0S0 to EPI0S31)// 24 Bits Wide (EPI0S0 to EPI0S23)// 16 Bits Wide (EPI0S0 to EPI0S15)// 8 Bits Wide (EPI0S0 to EPI0S7)// Size of Data Bus// other than 8// cannot be used with data sizes// Up to 20 bits wide. This size// cannot be used with 24-bit data// Up to 12 bits wide. This size// Up to 4 bits wide// No address// Address Bus Size// 2-Cycle Writes// Frame Count// 50/50 Frame// Clock Pin// The following are defines for the bit fields in the EPI_O_GPCFG register.// XFIFO - D[15:0]// Continuous Read - D[15:0]// Byte Select Configuration// Burst Mode// Read// PSRAM Configuration Register// Write// Clock Gated Idle// The following are defines for the bit fields in the EPI_O_HB16CFG register.// CS2n Baud Rate Counter 0// CS3n Baud Rate Counter 1// The following are defines for the bit fields in the EPI_O_BAUD2 register.// Baud Rate Counter 0// Baud Rate Counter 1// The following are defines for the bit fields in the EPI_O_BAUD register.// 16-Bit Host-Bus (HB16)// 8-Bit Host-Bus (HB8)// SDRAM// General Purpose// Mode Select// Block Enable// Integer Clock Divider Enable// The following are defines for the bit fields in the EPI_O_CFG register.// EPI Host-Bus PSRAM// EPI Host-Bus 16 Timing Extension// EPI Host-Bus 8 Timing Extension// EPI Host-Bus 8 Configuration 4// EPI Host-Bus 16 Configuration 4// EPI Host-Bus 16 Configuration 3// EPI Host-Bus 8 Configuration 3// EPI Error and Interrupt Status// EPI Masked Interrupt Status// EPI Raw Interrupt Status// EPI Interrupt Mask// EPI DMA Transmit Count// EPI Write FIFO Count// EPI FIFO Level Selects// EPI Read FIFO Alias 7// EPI Read FIFO Alias 6// EPI Read FIFO Alias 5// EPI Read FIFO Alias 4// EPI Read FIFO Alias 3// EPI Read FIFO Alias 2// EPI Read FIFO Alias 1// EPI Read FIFO// EPI Read FIFO Count// EPI Status// EPI Non-Blocking Read Data 1// EPI Read Address 1// EPI Read Size 1// EPI Non-Blocking Read Data 0// EPI Read Address 0// EPI Read Size 0// EPI Address Map// EPI Host-Bus 16 Configuration 2// EPI Host-Bus 8 Configuration 2// EPI Host-Bus 8 Configuration// EPI SDRAM Configuration// EPI General-Purpose// EPI Host-Bus 16 Configuration// EPI Main Baud Rate// EPI Configuration// offsets.// The following are defines for the External Peripheral Interface register// Copyright (c) 2008-2020 Texas Instruments Incorporated.  All rights reserved.// hw_epi.h - Macros for use in accessing the EPI registers./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/epi.hEPIWorkaroundByteReadui8Dataregisterui32ScratchEPIWorkaroundByteWriteEPIWorkaroundHWordReadEPIWorkaroundHWordWriteEPIWorkaroundWordReadEPIWorkaroundWordWriteEPI_INT_ERR_TIMEOUTEPI_INT_ERR_RSTALLEPI_INT_ERR_WTFULLEPI_INT_ERR_DMARDICEPI_INT_ERR_DMAWRICEPI_INT_ERREPI_INT_RXREQEPI_INT_TXREQEPI_INT_DMA_RX_DONEEPI_INT_DMA_TX_DONEEPI_FIFO_CONFIG_RX_FULLEPI_FIFO_CONFIG_RX_7_8EPI_FIFO_CONFIG_RX_3_4EPI_FIFO_CONFIG_RX_1_2EPI_FIFO_CONFIG_RX_1_4EPI_FIFO_CONFIG_RX_1_8EPI_FIFO_CONFIG_TX_3_4EPI_FIFO_CONFIG_TX_1_2EPI_FIFO_CONFIG_TX_1_4EPI_FIFO_CONFIG_TX_EMPTYEPI_FIFO_CONFIG_RSTALLERREPI_FIFO_CONFIG_WTFULLERREPI_NBCONFIG_SIZE_32EPI_NBCONFIG_SIZE_16EPI_NBCONFIG_SIZE_8EPI_ADDR_CODE_BASE_1EPI_ADDR_CODE_BASE_NONEEPI_ADDR_CODE_SIZE_256MBEPI_ADDR_CODE_SIZE_16MBEPI_ADDR_CODE_SIZE_64KBEPI_ADDR_CODE_SIZE_256BEPI_ADDR_QUAD_MODE0x00000033EPI_ADDR_RAM_BASE_8EPI_ADDR_RAM_BASE_6EPI_ADDR_RAM_BASE_NONEEPI_ADDR_RAM_SIZE_256MBEPI_ADDR_RAM_SIZE_16MBEPI_ADDR_RAM_SIZE_64KBEPI_ADDR_RAM_SIZE_256BEPI_ADDR_PER_BASE_CEPI_ADDR_PER_BASE_AEPI_ADDR_PER_BASE_NONEEPI_ADDR_PER_SIZE_256MBEPI_ADDR_PER_SIZE_16MBEPI_ADDR_PER_SIZE_64KBEPI_ADDR_PER_SIZE_256BEPI_HB16_RDWAIT_MINUS_ENABLEEPI_HB16_RDWAIT_MINUS_DISABLEEPI_HB16_WRWAIT_MINUS_ENABLEEPI_HB16_WRWAIT_MINUS_DISABLEEPI_HB16_CAP_WIDTH_2EPI_HB16_CAP_WIDTH_1EPI_HB16_PSRAM_8192EPI_HB16_PSRAM_4096EPI_HB16_PSRAM_2048EPI_HB16_PSRAM_1024EPI_HB16_PSRAM_512EPI_HB16_PSRAM_256EPI_HB16_PSRAM_128EPI_HB16_PSRAM_NO_LIMITEPI_HB16_IN_READY_DELAY_3EPI_HB16_IN_READY_DELAY_2EPI_HB16_IN_READY_DELAY_1EPI_HB8_RDWAIT_MINUS_ENABLEEPI_HB8_RDWAIT_MINUS_DISABLEEPI_HB8_WRWAIT_MINUS_ENABLEEPI_HB8_WRWAIT_MINUS_DISABLEEPI_HB8_CAP_WIDTH_2EPI_HB8_CAP_WIDTH_1EPI_HB8_IN_READY_DELAY_3EPI_HB8_IN_READY_DELAY_2EPI_HB8_IN_READY_DELAY_1EPI_HB16_CSCFG_MASK0x00001600EPI_HB16_CSBAUDEPI_HB16_BURST_TRAFFICEPI_HB16_ALE_LOWEPI_HB16_ALE_HIGHEPI_HB16_IN_READY_EN_INVERTED0x18000000EPI_HB16_IN_READY_ENEPI_HB16_CLOCK_INVERTEPI_HB16_CLOCK_GATE_IDLEEPI_HB16_CLOCK_GATEEPI_HB16_CSCFG_ALE_QUAD_CSEPI_HB16_CSCFG_QUAD_CSEPI_HB16_CSCFG_ALE_SINGLE_CSEPI_HB16_CSCFG_ALE_DUAL_CSEPI_HB16_CSCFG_DUAL_CSEPI_HB16_CSCFG_CSEPI_HB16_CSCFG_ALEEPI_HB16_WORD_ACCESSEPI_HB16_BSELEPI_HB16_MODE_FIFOEPI_HB16_MODE_SRAMEPI_HB16_MODE_ADDEMUXEPI_HB16_MODE_ADMUXEPI_HB16_RDWAIT_3EPI_HB16_RDWAIT_2EPI_HB16_RDWAIT_1EPI_HB16_RDWAIT_0EPI_HB16_WRWAIT_3EPI_HB16_WRWAIT_2EPI_HB16_WRWAIT_1EPI_HB16_WRWAIT_0EPI_HB16_RDHIGHEPI_HB16_WRHIGHEPI_HB16_USE_RXFULLEPI_HB16_USE_TXEMPTYEPI_HB8_CSCFG_MASKEPI_HB8_IN_READY_EN_INVERTEPI_HB8_IN_READY_ENEPI_HB8_CLOCK_INVERTEPI_HB8_CLOCK_GATE_IDLEEPI_HB8_CLOCK_GATEEPI_HB8_CSBAUDEPI_HB8_CSCFG_ALE_QUAD_CSEPI_HB8_CSCFG_QUAD_CSEPI_HB8_CSCFG_ALE_SINGLE_CSEPI_HB8_CSCFG_ALE_DUAL_CSEPI_HB8_CSCFG_DUAL_CSEPI_HB8_CSCFG_CSEPI_HB8_CSCFG_ALEEPI_HB8_WORD_ACCESSEPI_HB8_MODE_FIFOEPI_HB8_MODE_SRAMEPI_HB8_MODE_ADDEMUXEPI_HB8_MODE_ADMUXEPI_HB8_RDWAIT_3EPI_HB8_RDWAIT_2EPI_HB8_RDWAIT_1EPI_HB8_RDWAIT_0EPI_HB8_WRWAIT_3EPI_HB8_WRWAIT_2EPI_HB8_WRWAIT_1EPI_HB8_WRWAIT_0EPI_HB8_ALE_LOWEPI_HB8_ALE_HIGHEPI_HB8_RDHIGHEPI_HB8_WRHIGHEPI_HB8_USE_RXFULLEPI_HB8_USE_TXEMPTYEPI_GPMODE_DSIZE_32EPI_GPMODE_DSIZE_24EPI_GPMODE_DSIZE_16EPI_GPMODE_DSIZE_8EPI_GPMODE_ASIZE_20EPI_GPMODE_ASIZE_12EPI_GPMODE_ASIZE_4EPI_GPMODE_ASIZE_NONEEPI_GPMODE_WRITE2CYCLEEPI_GPMODE_FRAME50EPI_GPMODE_CLKGATEEPI_GPMODE_CLKPINEPI_SDRAM_SIZE_512MBITEPI_SDRAM_SIZE_256MBITEPI_SDRAM_SIZE_128MBITEPI_SDRAM_SIZE_64MBITEPI_SDRAM_FULL_POWEREPI_SDRAM_LOW_POWEREPI_SDRAM_CORE_FREQ_50_100EPI_SDRAM_CORE_FREQ_30_50EPI_SDRAM_CORE_FREQ_15_30EPI_SDRAM_CORE_FREQ_0_15EPI_MODE_DISABLEEPI_MODE_HB16EPI_MODE_HB8EPI_MODE_SDRAMEPI_MODE_GENERAL__DRIVERLIB_EPI_H__rvmdkccs(defined gcc) || (defined ewarm) || (defined sourcerygxx) || \EPIIntUnregisterEPIIntRegisterEPIIntErrorClearEPIIntErrorStatusEPIIntStatusEPIIntDisableEPIIntEnableEPIWriteFIFOCountGetEPIFIFOConfigEPINonBlockingReadGet8EPINonBlockingReadGet16EPINonBlockingReadGet32EPINonBlockingReadAvailEPINonBlockingReadCountEPINonBlockingReadStopEPINonBlockingReadStartEPINonBlockingReadConfigureEPIAddressMapSetEPIConfigSDRAMSetEPIPSRAMConfigRegGetEPIPSRAMConfigRegGetNonBlockingEPIPSRAMConfigRegReadEPIPSRAMConfigRegSetEPIConfigHB16TimingSetEPIConfigHB8TimingSetEPIConfigHB16CSSetEPIConfigHB8CSSetEPIConfigHB16SetEPIConfigHB8SetEPIConfigGPModeSetEPIDMATxCountEPIDividerCSSetEPIDividerSetEPIModeSet// __DRIVERLIB_EPI_H__// Keep the compiler from generating a warning.// the EPI read.// Add a NOP to ensure we dont have a flash read immediately before// "real" read.// ui32Scratch is not used other than to add a padding read following the// GCC-based toolchain and IAR case.// source file epi_workaround_ccs.s.// Code Composer Studio versions of these functions can be found in separate// a flash read.// Read from SRAM to ensure that we don't have an EPI read followed by// Perform the read we're actually interested in.// Read from SRAM to ensure that we don't have an EPI write followed by// Perform the write we're actually interested in.// Keil case.// EPIIntErrorStatus()// Values that can be passed to EPIIntErrorClear(), or returned as flags from// as flags from EPIIntStatus()// Values that can be passed to EPIIntEnable(), EPIIntDisable(), or returned// Values that can be passed to EPIFIFOConfig()// Values that can be passed to EPINonBlockingReadConfigure()// Values that can be passed to EPIAddressMapSet().// Values that can be passed to EPIConfigHB16TimingSet().// Values that can be passed to EPIConfigHB8TimingSet().// Values that can be passed to EPIConfigHB16ModeSet()// Values that can be passed to EPIConfigHB8ModeSet()// Values that can be passed to EPIConfigGPModeSet()// Values that can be passed to EPIConfigSDRAMSet()// Values that can be passed to EPIModeSet()// epi.h - Prototypes and macros for the EPI module.pui8Addrui8Valuepui16Addrpui32Addrui32ErrFlagspui8Bufpui16Bufpui32Bufui32Channelui32DataSizeui32Mapui32Refreshui32CSpui32CRui32CRui32MaxWaitui32FrameCountui32Dividerui32Mode/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/epi.c"driverlib/epi.h""inc/hw_epi.h"ui32Intui32Base == EPI0_BASEui32Int != 0_EPIIntNumberGetui32Base + EPI_O_EISCui32Base + 0x0000021C540ui32ErrFlags < 0x20ui32Base + EPI_O_MISui32Base + 0x00000218ui32Base + EPI_O_RISui32Base + 0x00000214536532ui32Base + EPI_O_IMui32Base + 0x00000210528ui32IntFlags < 17ui32Base + EPI_O_WFIFOCNTui32Base + 0x00000204ui32Base + EPI_O_FIFOLVLui32Base + 0x00000200ui32Config == (ui32Config & 0x00030077)ui32CountReadui32Base + EPI_O_RFIFOCNTui32Base + EPI_O_READFIFO0ui32Base + 0x00000070ui32Count < 4096ui32Offset(EPI_O_RPSTD1 - EPI_O_RPSTD0)ui32Base + EPI_O_RPSTD0 + ui32Offsetui32Base + 0x00000028 + ui32Offsetui32Channel < 2(EPI_O_RSIZE1 - EPI_O_RSIZE0)ui32Base + EPI_O_RSIZE0 + ui32Offsetui32Base + 0x00000020 + ui32Offsetui32Base + EPI_O_RADDR0 + ui32Offsetui32Base + 0x00000024 + ui32Offsetui32DataSize < 4ui32Address < 0x20000000ui32Base + EPI_O_ADDRMAPui32Map < 0x1000629145604232052735~EPI_GPCFG_FRMCNT_Mui32Base + EPI_O_GPCFGui32FrameCount < 16ui32MaxWait < 256776ui32Base + ui32Offsetui32Base + EPI_O_HBPSRAMui32Base + 0x00000360864ui32CS < 420971510x1fffffui32Base + (EPI_O_HB16TIME + (ui32CS << 2))ui32Base + (0x00000310 + (ui32CS << 2))784ui32Base + (EPI_O_HB8TIME + (ui32CS << 2))24310488192097152314597136702593735795EPI_HB16_CS_MASK4291231500~EPI_HB16_CS_MASKEPI_HB8_CS_MASK4291297036~EPI_HB8_CS_MASKui32Base + EPI_O_HB16CFG26710886456324294902015~EPI_HB16CFG_MAXWAIT_Mui32Base + EPI_O_HB16CFGui32Base + EPI_O_HB8CFG2~EPI_HB8CFG_MAXWAIT_Mui32Base + EPI_O_HB8CFG4160815103~EPI_SDRAMCFG_RFSH_Mui32Base + EPI_O_SDRAMCFGui32Refresh < 2048ui32Base + EPI_O_DMATXCNTui32Base + 0x00000208520ui32Count <= 1024ui32Base + EPI_O_BAUDui32Base + EPI_O_BAUD2ui32Base + EPI_O_CFG(ui32Mode == EPI_MODE_GENERAL) || (ui32Mode == EPI_MODE_SDRAM) || (ui32Mode == EPI_MODE_HB8) || (ui32Mode == EPI_MODE_HB16) || (ui32Mode == EPI_MODE_DISABLE)(EPI_HB8_CS_MASK | EPI_HB16_BURST_TRAFFIC)(EPI_HB8_MODE_FIFO | EPI_HB8_RDWAIT_3 | EPI_HB8_WRWAIT_3 | EPI_HB8_RDHIGH | EPI_HB8_WRHIGH | EPI_HB8_ALE_HIGH)// Disable the EPI interface interrupt.// Get the interrupt number for the EPI interface.//! EPI interrupt occurs.//! This function disables and clears the handler to be called when the//! \param ui32Base is the EPI module base address.//! Removes a registered interrupt handler for the EPI module.// Enable the EPI interface interrupt.//! with the EPIIntEnable() function.//! generates an interrupt.  Specific EPI interrupts must still be enabled//! This sets and enables the handler to be called when the EPI module//! interrupt is activated.//! Registers an interrupt handler for the EPI module.// By default, assume EPI is not supported.//! \return Returns the EPI interrupt number or 0 if the interrupt does not//! This function returns the interrupt number for the EPI module with the base//! \param ui32Base is the base address of the EPI module.//! Returns the interrupt number for a given EPI base address.// Write the error flags to the register to clear the pending errors.//! \return Returns None.//! off a transaction longer than the configured maximum wait time//! - \b EPI_INT_ERR_TIMEOUT occurs when the external clock enable held//! - \b EPI_INT_ERR_RSTALL occurs when a read stalled//! FIFO was full//! - \b EPI_INT_ERR_WTFULL occurs when a write stalled when the transaction//! source//! - \b EPI_INT_ERR_DMARDIC clears the EPI_INT_DMA_RX_DONE as an interrupt//! - \b EPI_INT_ERR_DMAWRIC clears the EPI_INT_DMA_TX_DONE as an interrupt//! parameter can be the logical OR of any of the following values://! This function clears the specified pending EPI errors.  The \e ui32ErrFlags//! \param ui32ErrFlags is a bit mask of the error sources to be cleared.//! Clears pending EPI error sources.// Read the error status and return to caller.//! OR of any of the following://! \return Returns a bit mask of error flags, which can be the logical//! function can be used to determine the cause of the error.//! the function EPIIntStatus() has the flag \b EPI_INT_ERR set, then this//! This function returns the error status of the EPI.  If the return value of//! Gets the EPI error interrupt status.//! - \b EPI_INT_DMA_RX_DONE interrupt when the read DMA completes.//! - \b EPI_INT_DMA_TX_DONE interrupt when the transmit DMA completes.//! - \b EPI_INT_ERR interrupt when an error condition occurs.//! - \b EPI_INT_RXREQ interrupt when read FIFO is above the trigger level.//! - \b EPI_INT_TXREQ interrupt when transmit FIFO is below the trigger level.//! of any of the following values://! \return Returns the masked or raw EPI interrupt status, as a bit field//! the raw or masked interrupt status.//! This function returns the EPI interrupt status.  It can return either//! \b false to get the raw interrupt status.//! \param bMasked is set \b true to get the masked interrupt status, or//! Gets the EPI interrupt status.// Write the interrupt flags mask to the mask register.//! generation.  The \e ui32IntFlags parameter can be the logical OR of any of//! This function disables the specified EPI sources for interrupt//! \param ui32IntFlags is a bit mask of the interrupt sources to be disabled.//! Disables EPI interrupt sources.//! The \e ui32IntFlags parameter can be the logical OR of any of the following//! This function enables the specified EPI sources to generate interrupts.//! \param ui32IntFlags is a bit mask of the interrupt sources to be enabled.//! Enables EPI interrupt sources.// Read the FIFO count and return it to the caller.//! \return The number of empty slots in the transaction FIFO.//! that would stall.//! FIFO.  It can be used in a polling method to avoid attempting a write//! This function returns the number of slots available in the transaction//! Reads the number of empty slots in the write transaction FIFO.// Load the configuration into the FIFO config reg.//!     - \b EPI_FIFO_CONFIG_RX_FULL sets the FIFO RX trigger level to full.//!     - \b EPI_FIFO_CONFIG_RX_7_8 sets the FIFO RX trigger level to 7/8.//!     - \b EPI_FIFO_CONFIG_RX_3_4 sets the FIFO RX trigger level to 3/4.//!     - \b EPI_FIFO_CONFIG_RX_1_2 sets the FIFO RX trigger level to 1/2.//!     - \b EPI_FIFO_CONFIG_RX_1_4 sets the FIFO RX trigger level to 1/4.//!     - \b EPI_FIFO_CONFIG_RX_1_8 sets the FIFO RX trigger level to 1/8.//! - FIFO RX trigger level, select one of://!     - \b EPI_FIFO_CONFIG_TX_3_4 sets the FIFO TX trigger level to 3/4.//!     - \b EPI_FIFO_CONFIG_TX_1_2 sets the FIFO TX trigger level to 1/2.//!     - \b EPI_FIFO_CONFIG_TX_1_4 sets the FIFO TX trigger level to 1/4.//!     - \b EPI_FIFO_CONFIG_TX_EMPTY sets the FIFO TX trigger level to empty.//! - FIFO TX trigger level, select one of://! stalled due to an interleaved write or other reason//! - \b EPI_FIFO_CONFIG_RSTALLERR enables an error interrupt when a read is//! attempted and the write FIFO is full//! - \b EPI_FIFO_CONFIG_WTFULLERR enables an error interrupt when a write is//! generation.  The parameter \e ui32Config is the logical OR of the//! This function configures the FIFO trigger levels and error//! \param ui32Config is the FIFO configuration.//! Configures the read FIFO.// Return the count of items read to the caller.// Update the caller's buffer pointer and the count of items read.// Read from the FIFO and store in the caller supplied buffer.// the caller's specified count is not exceeded.// Read from the FIFO while there are any items to read, and//! \return The number of items read from the FIFO.//! count of items is returned.//! count is reached as specified in the parameter \e ui32Count.  The actual//! data from the FIFO until there is no more data in the FIFO or the maximum//! the values in a caller-supplied buffer.  The function reads and stores//! This function reads 8-bit data items from the read FIFO and stores//! stored.//! \param pui8Buf is the caller-supplied buffer where the read data is//! \param ui32Count is the maximum count of items to read.//! Read available data from the read FIFO, as 8-bit data items.// Read from the FIFO and store in the caller-supplied buffer.//! This function reads 16-bit data items from the read FIFO and stores//! \param pui16Buf is the caller-supplied buffer where the read data is//! Read available data from the read FIFO, as 16-bit data items.// Read from the FIFO while there are any items to read and//! This function reads 32-bit data items from the read FIFO and stores//! \param pui32Buf is the caller supplied buffer where the read data is//! Read available data from the read FIFO, as 32-bit data items.//! \return The number of items available to read in the read FIFO.//! EPINonBlockingReadStart().//! which is configured by the functions EPINonBlockingReadConfigure() and//! the read FIFO.  The read FIFO is filled by a non-blocking read transaction//! This function gets the number of items that are available to read in//! Get the count of items available in the read FIFO.// Read the count remaining and return the value to the caller.// Compute the offset needed to select the correct channel regs.//! \return The number of items remaining in the non-blocking read transaction.//! transaction.//! This function gets the remaining count of items for a non-blocking read//! \param ui32Channel is the read channel (0 or 1).//! Get the count remaining for a non-blocking transaction.// Write a 0 to the read count register, which cancels the transaction.//! in progress.//! This function cancels a non-blocking read transaction that is already//! Stops a non-blocking read transaction.// Write to the read count register.//! function again.//! transaction can be started from the next address by calling this//! Once a read transaction is completed and the FIFO drained, another//! total specified count of data items has been read.//! and resumes reading when the application drains the FIFO, until the//! into the read FIFO.  The EPI stops reading when the FIFO fills up//! called, the EPI module begins reading data from the external device//! with the function EPINonBlockingReadConfigure().  Once this function is//! This function starts a non-blocking read that was previously configured//! \param ui32Count is the number of items to read (1-4095).//! Starts a non-blocking read transaction.// Write the starting address register for the channel.// Write the data size register for the channel.//! that was used for a non-blocking read (per channel).//! times.  Until it is changed, the EPI module stores the last address//! are in a sequence, it is not necessary to call this function multiple//! EPINonBlockingReadStart().  If the addresses to be read from the device//! Once configured, the non-blocking read is started by calling//! to the external device.  The start of the device is address 0.//! The parameter \e ui32Address is the starting address for the read, relative//! or 32-bit sized data transfers.//! \b EPI_NBCONFIG_SIZE_16, or \b EPI_NBCONFIG_SIZE_32 for 8-bit, 16-bit,//! The parameter \e ui8DataSize is one of \b EPI_NBCONFIG_SIZE_8,//! to perform a non-blocking read.//! method for continuous reading.  It is not necessary to use both channels//! transaction.  Two channels are available that can be used in a ping-pong//! This function is used to configure a non-blocking read channel for a//! \param ui32Address is the starting address to read.//! \param ui32DataSize is the size of the data items to read.//! Configures a non-blocking read transaction.// Set the value of the address mapping register.//! to determine if these features are available.//! varies based on the Tiva part in use.  Please consult the data sheet//! \note The availability of \b EPI_ADDR_RAM_QUAD_MODE and \b EPI_ADDR_CODE_*//! - \b EPI_ADDR_CODE_BASE_1 sets external code base to 0x10000000.//! - \b EPI_ADDR_CODE_BASE_NONE sets external code base to not mapped.//! range 0x0000000 to 0xFFFFFFF.//! - \b EPI_ADDR_CODE_SIZE_256MB sets an external code size of 256 Mbytes,//! 0x000000 to 0xFFFFFF.//! - \b EPI_ADDR_CODE_SIZE_16MB sets an external code size of 16 Mbytes, range//! 0x0000 to 0xFFFF.//! - \b EPI_ADDR_CODE_SIZE_64KB sets an external code size of 64 Kbytes, range//! 0x00 to 0xFF.//! - \b EPI_ADDR_CODE_SIZE_256B sets an external code size of 256 bytes, range//! CS2n to 0xA0000000, and CS3n to 0xC0000000.//! - \b EPI_ADDR_RAM_QUAD_MODE maps CS0n to 0x60000000, CS1n to 0x80000000,//!     - \b EPI_ADDR_RAM_BASE_8 sets the RAM space address to 0x80000000.//!     - \b EPI_ADDR_RAM_BASE_6 sets the RAM space address to 0x60000000.//!     - \b EPI_ADDR_RAM_BASE_NONE sets the RAM space address to none.//! - RAM base address, select one of://!     - \b EPI_ADDR_RAM_SIZE_256MB sets the RAM address space to 256 Mbytes.//!     - \b EPI_ADDR_RAM_SIZE_16MB sets the RAM address space to 16 Mbytes.//!     - \b EPI_ADDR_RAM_SIZE_64KB sets the RAM address space to 64 Kbytes.//!     - \b EPI_ADDR_RAM_SIZE_256B sets the RAM address space to 256 bytes.//! - RAM address space, select one of://! 0xC0000000.//!     - \b EPI_ADDR_PER_BASE_C sets the peripheral base address to//! 0xA0000000.//!     - \b EPI_ADDR_PER_BASE_A sets the peripheral base address to//!     - \b EPI_ADDR_PER_BASE_NONE sets the peripheral base address to none.//! - Peripheral base address, select one of://! Mbytes.//!     - \b EPI_ADDR_PER_SIZE_256MB sets the peripheral address space to 256//!     - \b EPI_ADDR_PER_SIZE_16MB sets the peripheral address space to 16//! Kbytes.//!     - \b EPI_ADDR_PER_SIZE_64KB sets the peripheral address space to 64//! bytes.//!     - \b EPI_ADDR_PER_SIZE_256B sets the peripheral address space to 256//! - Peripheral address space size, select one of://! The parameter \e ui32Map is the logical OR of the following://! device within the processor peripheral and/or memory space.//! interface, which then determines the base address of the external memory or//! This function is used to configure the address mapping for the external//! \param ui32Map is the address mapping configuration.//! Configures the address map for the external interface.// Write the non-moded configuration register.// Fill in the frame count field of the configuration word.//! whether the frame signal is a pulse or a 50/50 duty cycle.//! framing signal, if the framing signal is used.  The behavior depends on//! The parameter \e ui32FrameCount is the number of clocks used to form the//!     - \b EPI_GPMODE_DSIZE_32 sets a data bus size of 32 bits.//!     - \b EPI_GPMODE_DSIZE_24 sets a data bus size of 24 bits.//!     - \b EPI_GPMODE_DSIZE_16 sets a data bus size of 16 bits.//!     - \b EPI_GPMODE_DSIZE_8 sets a data bus size of 8 bits.//! - Data bus size, select one of://!     - \b EPI_GPMODE_ASIZE_20 sets an address bus size of 20 bits.//!     - \b EPI_GPMODE_ASIZE_12 sets an address bus size of 12 bits.//!     - \b EPI_GPMODE_ASIZE_4 sets an address bus size of 4 bits.//!     - \b EPI_GPMODE_ASIZE_NONE sets no address bus.//! - Address bus size, select one of://!   single-cycle write is used.//! - \b EPI_GPMODE_WRITE2CYCLE a two-cycle write is used, otherwise a//!   is a pulse.//! - \b EPI_GPMODE_FRAME50 framing signal is 50/50 duty cycle, otherwise it//!   otherwise it is free-running.//! - \b EPI_GPMODE_CLKGATE clock is stopped when there is no transaction,//! - \b EPI_GPMODE_CLKPIN interface clock as output on a pin.//! parameter \e ui32Config is the logical OR of the following://! general-purpose operation as chosen with the function EPIModeSet().  The//! This function is used to configure the interface when used in//! \param ui32MaxWait is currently not used.//! is used (0-15).//! \param ui32FrameCount is the frame size in clocks, if the frame signal//! \param ui32Config is the interface configuration.//! Configures the interface for general-purpose mode operation.// Only the lower 16 bits are valid on a read.// Return the EPI PSRAM configuration register contents.// Wait for PSRAM read enable to deassert if necessary.// Determine the register offset based on the ui32CS provided.//! \return none.//! available.//! in use.  Please consult the data sheet to determine if this feature is//! \note The availability of PSRAM support varies based on the Tiva part//! valid range of 0-3.//! The \e ui32CS parameter specifies the chip select to configure and has a//! The \e ui32Base parameter is the base address for the EPI hardware module.//! should be called prior to calling this function.//! The Host-bus 16 interface mode should be set up and EPIPSRAMConfigRegRead()//! de-asserted.//! is read once the EPI PSRAM configuration register read enable signal is//! This function retrieves the EPI PSRAM configuration register.  The register//! \param ui32CS is the chip select target.//! Retrieves the contents of the EPI PSRAM configuration register.// register contents.// Notify caller the provided storage holds the EPI PSRAM configuration// Copy the PSRAM configuration register value to the provided storage.// Verify PSRAM read enable is not asserted.//! \b false if it was not.//! \return \b true if the value was copied to the provided storage and//! storage used to hold the register value.//! valid range of 0-3.  The \e pui32CR parameter is a pointer to provided//! is no longer asserted.  Otherwise the provided storage is not modified.//! to the provided storage if the PSRAM read configuration register enable//! This function copies the contents of the EPI PSRAM configuration register//! \param pui32CR is the provided storage used to hold the register value.// Set the PSRAM configuration register read enable.//! be used to retrieve the configuration register value.//! The EPIPSRAMConfigRegGet() and EPIPSRAMConfigRegGetNonBlocking() can//! Host-bus 16 interface mode should be configured prior to calling this//! This function requests a read of the PSRAM's configuration register.  The//! Requests a configuration register read from the PSRAM.// Set the PSRAM configuration register write enable.// valid on a write.// Setup for the PSRAM configuration register write.  Only 21 bits are//! consulting the PSRAM's data sheet.//! valid range of 0-3.  The parameter \e ui32CR value is determined by//! should be configured prior to calling this function.//! configuration register enable signal.  The Host-bus 16 interface mode//! This function sets the PSRAM's configuration register by using the PSRAM//! \param ui32CR is the PSRAM configuration register value.//! Sets the PSRAM configuration register.// Write the target chip select HostBus16 timing register.//! the data sheet to determine if this feature is available.//! interface mode varies based on the Tiva part in use.  Please consult//! \note The availability of unique chip select timings within Host-bus 16//!     reduction.//!     - \b EPI_HB16_RDWAIT_MINUS_ENABLE enables a 1 EPI clock read wait state//!     state reduction.//!     - \b EPI_HB16_RDWAIT_MINUS_DISABLE disables the additional read wait//! - Read wait state timing reduction, select one of://!     - \b EPI_HB16_WRWAIT_MINUS_ENABLE enables a 1 EPI clock write wait//!     - \b EPI_HB16_WRWAIT_MINUS_DISABLE disables the additional write wait//! - Write wait state timing reduction, select one of://!     to create a delay of 2 EPI clocks.//!     - \b EPI_HB16_CAP_WIDTH_2 defines the inter-transfer capture width//!     create a delay of 1 EPI clock//!     - \b EPI_HB16_CAP_WIDTH_1 defines the inter-transfer capture width to//! - Host bus transfer delay, select one of://!     - \b EPI_HB16_PSRAM_8192 defines the PSRAM row size to 8192 bytes.//!     - \b EPI_HB16_PSRAM_4096 defines the PSRAM row size to 4096 bytes.//!     - \b EPI_HB16_PSRAM_2048 defines the PSRAM row size to 2048 bytes.//!     - \b EPI_HB16_PSRAM_1024 defines the PSRAM row size to 1024 bytes.//!     - \b EPI_HB16_PSRAM_512 defines the PSRAM row size to 512 bytes.//!     - \b EPI_HB16_PSRAM_256 defines the PSRAM row size to 256 bytes.//!     - \b EPI_HB16_PSRAM_128 defines the PSRAM row size to 128 bytes.//!     - \b EPI_HB16_PSRAM_NO_LIMIT defines no row size limitation.//! - PSRAM size limitation, select one of://!     to start 3 EPI clocks after signaled.//!     - \b EPI_HB16_IN_READY_DELAY_3 sets the stall on input ready (EPIS032)//!     to start 2 EPI clocks after signaled.//!     - \b EPI_HB16_IN_READY_DELAY_2 sets the stall on input ready (EPIS032)//!     to start 1 EPI clock after signaled.//!     - \b EPI_HB16_IN_READY_DELAY_1 sets the stall on input ready (EPIS032)//! - Input ready stall delay, select one of://! valid range of 0-3.  The parameter \e ui32Config is the logical OR of the//! Host-bus 16 interface mode.//! This function is used to set individual chip select timings for the//! \param ui32Config is the configuration settings.//! \param ui32CS is the chip select value to configure.//! interface.//! Sets the individual chip select timing settings for the Host-bus 16// Write the target chip select HostBus8 timing register.//! \note The availability of unique chip select timings within Host-bus 8//!reduction.//! - \b EPI_HB8_RDWAIT_MINUS_ENABLE enables a 1 EPI clock read wait state//! reduction.//! - \b EPI_HB8_RDWAIT_MINUS_DISABLE disables the additional read wait state//! - \b EPI_HB8_WRWAIT_MINUS_ENABLE enables a 1 EPI clock write wait state//! - \b EPI_HB8_WRWAIT_MINUS_DISABLE disables the additional write wait state//!     - \b EPI_HB8_CAP_WIDTH_2 defines the inter-transfer capture width//!     create a delay of 1 EPI clock.//!     - \b EPI_HB8_CAP_WIDTH_1 defines the inter-transfer capture width to//!     - \b EPI_HB8_IN_READY_DELAY_3 sets the stall on input ready (EPIS032)//!     - \b EPI_HB8_IN_READY_DELAY_2 sets the stall on input ready (EPIS032)//!     - \b EPI_HB8_IN_READY_DELAY_1 sets the stall on input ready (EPIS032)//! Host-bus 8 interface mode.//! Sets the individual chip select timing settings for the Host-bus 8// Write the target chip select HostBus16 configuration fields.// Preserve the bits that will not be modified.//! Please consult the data sheet to determine if this feature is available.//! Host-bus 16 interface mode varies based on the Tiva part in use.//! \note The availability of the unique chip select configuration within the//!   ALE.//!   \b EPI_HB16_MODE_ADMUX and a chip select configuration that utilizes an//! - \b EPI_HB16_BURST_TRAFFIC enables burst traffic.  Only valid with//! - \b EPI_HB16_ALE_LOW sets address latch active low.//! - \b EPI_HB16_ALE_HIGH sets the address latch active high (default).//!     - \b EPI_HB16_RDWAIT_3 sets read wait state to 8 EPI clocks.//!     - \b EPI_HB16_RDWAIT_2 sets read wait state to 6 EPI clocks.//!     - \b EPI_HB16_RDWAIT_1 sets read wait state to 4 EPI clocks.//!     - \b EPI_HB16_RDWAIT_0 sets read wait state to 2 EPI clocks (default).//! - Read wait state when \b EPI_HB16_BAUD is used, select one of://!     - \b EPI_HB16_WRWAIT_3  sets write wait state to 8 EPI clocks.//!     - \b EPI_HB16_WRWAIT_2 sets write wait state to 6 EPI clocks.//!     - \b EPI_HB16_WRWAIT_1 sets write wait state to 4 EPI clocks.//!     - \b EPI_HB16_WRWAIT_0 sets write wait state to 2 EPI clocks (default).//! - Write wait state when \b EPI_HB16_BAUD is used, select one of://!   active low.//! - \b EPI_HB16_RDHIGH sets active high read strobe, otherwise it is//! - \b EPI_HB16_WRHIGH sets active high write strobe, otherwise it is//!       empty, D[15:0].  This feature is only available on CS0n and CS1n.//!     - \b EPI_HB16_MODE_FIFO adds XFIFO with sense of XFIFO full and XFIFO//!       address switch for multiple reads instead of OEn strobing, D[15:0].//!     - \b EPI_HB16_MODE_SRAM same as \b EPI_HB8_MODE_ADDEMUX, but uses//!     - \b EPI_HB16_MODE_ADDEMUX sets up data and address separate, D[15:0].//!     - \b EPI_HB16_MODE_ADMUX sets data and address muxed, AD[15:0].//! - Host-bus 16 submode, select one of://! valid range of  0-3.  The parameter \e ui32Config is the logical OR the//! The  \e ui32CS parameter specifies the chip select to configure and has a//! option to be available.//! the \b EPI_HB16_CSBAUD flag for the individual chip select configuration//! Host-bus 16 interface mode.  EPIConfigHB16Set() must have been set up with//! This function is used to configure individual chip select settings for the//! Sets the individual chip select configuration for the Host-bus 16// Write the target chip select HostBus8 configuration fields.//! Host-bus 8 interface mode varies based on the Tiva part in use.//! \note The availability of a unique chip select configuration within//! - \b EPI_HB8_ALE_LOW sets address latch active low.//! - \b EPI_HB8_ALE_HIGH sets the address latch active high (default).//!     - \b EPI_HB8_RDWAIT_3 sets read wait state to 8 EPI clocks.//!     - \b EPI_HB8_RDWAIT_2 sets read wait state to 6 EPI clocks.//!     - \b EPI_HB8_RDWAIT_1 sets read wait state to 4 EPI clocks.//!     - \b EPI_HB8_RDWAIT_0 sets read wait state to 2 EPI clocks (default).//! - Read wait state when \b EPI_HB8_BAUD is used, select one of://!     - \b EPI_HB8_WRWAIT_3 sets write wait state to 8 EPI clocks.//!     - \b EPI_HB8_WRWAIT_2 sets write wait state to 6 EPI clocks.//!     - \b EPI_HB8_WRWAIT_1 sets write wait state to 4 EPI clocks.//!     - \b EPI_HB8_WRWAIT_0 sets write wait state to 2 EPI clocks (default).//! - Write wait state when \b EPI_HB8_BAUD is used, select one of://! - \b EPI_HB8_RDHIGH sets active high read strobe, otherwise it is//! - \b EPI_HB8_WRHIGH sets active high write strobe, otherwise it is//!       empty, D[7:0].  This is only available for CS0n and CS1n.//!     - \b EPI_HB8_MODE_FIFO adds XFIFO with sense of XFIFO full and XFIFO//!       switch for multiple reads instead of OEn strobing, D[7:0].//!     - \b EPI_HB8_MODE_SRAM as \b EPI_HB8_MODE_ADDEMUX, but uses address//!     - \b EPI_HB8_MODE_ADDEMUX sets up data and address separate, D[7:0].//!     - \b EPI_HB8_MODE_ADMUX sets data and address muxed, AD[7:0].//! - Host-bus 8 submode, select one of://! the \b EPI_HB8_CSBAUD flag for the individual chip select configuration//! Host-bus 8 interface mode.  EPIConfigHB8Set() must have been setup with//! Sets the individual chip select configuration for the Host-bus 8 interface.// Write the main HostBus16 configuration register.// Fill in the max wait field of the configuration word.// Determine the CS and word access modes.//! desired are available.//! part in use.  Please consult the data sheet to determine if the features//! \note  Availability of configuration options varies based on the Tiva//! signals.  A value of 0 means to wait forever.//! transaction is being held off by by the FIFO using one of these ready//! parameter determines the maximum number of clocks to wait when the//! FIFO is used along with RXFULL or TXEMPTY ready signals, then this//! The parameter \e ui32MaxWait is used if the FIFO mode is chosen.  If a//!         EPI_HB16_MODE_SRAM.//!   \note Dual or quad chip select configurations cannot be used with//!       as CS3n.//!       (ALE), EPIS026 as CS0n, EPIS027 as CS1n, EPIS034 as CS2n and EPIS033//!     - \b EPI_HB16_CSCFG_ALE_QUAD_CS sets EPIS030 as an  address latch//!       EPIS034 as CS2n and EPIS033 as CS3n.//!     - \b EPI_HB16_CSCFG_QUAD_CS sets EPIS030 as CS0n, EPIS027 as CS1n,//!       latch (ALE) and EPIS027 is used as a chip select.//!     - \b EPI_HB16_CSCFG_ALE_SINGLE_CS sets EPIS030 to operate as an address//!       external address map.//!       determined from the most significant address bit for the respective//!       EPIS027 as CS0n and EPIS026 as CS1n with the asserted chip select//!     - \b EPI_HB16_CSCFG_ALE_DUAL_CS sets EPIS030 as an address latch (ALE),//!       significant address bit for the respective external address map.//!       as CS1n with the asserted chip select determined from the most//!     - \b EPI_HB16_CSCFG_DUAL_CS sets EPIS030 to operate as CS0n and EPIS027//!       (ALE).//!     - \b EPI_HB16_CSCFG_ALE sets EPIS030 to operate as an address latch//!     - \b EPI_HB16_CSCFG_CS sets EPIS030 to operate as a chip select signal.//! - Chip select configuration, select one of://! configuration provided in \e ui32Config is used for all chip selects.//! calling EPIConfigHB16CSSet() if \b EPI_HB16_CSBAUD is used.  Otherwise, the//! configurations.  CS0n, CS1n, CS2n, and CS3n can each be configured by//! The use of \b EPI_HB16_CSBAUD also allows for unique chip select//! lower 16 bits passed to EPIDividerSet() if this option is absent.//! used to to configure the divider for CS2n and CS3n.  They both also use the//! selects.  If \b EPI_HB16_CSBAUD is configured, EPIDividerCSSet() should be//! In addition, some parts support CS2n and CS3n for a total of 4 chip//!   parameter passed to EPIDividerSet().//!   use the baud rate resulting from the divider in the lower 16 bits of the//!   passed in the upper 16 bits.  If this option is absent, both chip selects//!   bits of the divider passed to EPIDividerSet() and CS1n uses the divider//!   on each chip select.  CS0n uses the baud rate specified by the lower 16//! - \b EPI_HB16_CSBAUD use different baud rates when accessing devices//!   specified, data must be read and written using only 16-bit transfers.//!   operate as byte selects allowing 8-bit transfers.  If this flag is not//! - \b EPI_HB16_BSEL enables byte selects.  In this mode, two EPI signals//!     - \b EPI_HB16_ALE_LOW sets address latch active low.//!     - \b EPI_HB16_ALE_HIGH sets the address latch active high (default).//! - Address latch logic, select one of://! - \b EPI_HB16_IN_READY_EN_INVERTED sets EPIS032 as ready/stall signal,//!   high.//! - \b EPI_HB16_IN_READY_EN sets EPIS032 as a ready/stall signal, active//! - \b EPI_HB16_CLOCK_INVERT inverts the EPI clock.//!   available to read or write.//! - \b EPI_HB16_CLOCK_GATE_IDLE holds the EPI clock low when no data is//! consult the data sheet to determine if this feature is available.//! \note \b EPI_HB16_WORD_ACCESS is not available on all parts.  Please//!   absent, all data transfers use bits [15:0].//!   correct byte lanes allowing data to be stored in bits [31:16].  If//! - \b EPI_HB16_WORD_ACCESS use Word Access mode to route bytes to the//!     - \b EPI_HB16_RDWAIT_0 sets read wait state to 2 EPI clocks.//! - Read wait state, select one of://!     - \b EPI_HB16_WRWAIT_3 sets write wait state to 8 EPI clocks.//!     - \b EPI_HB16_WRWAIT_0 sets write wait state to 2 EPI clocks.//! - Write wait state, select one of://! - \b EPI_HB16_RDHIGH use active high read strobe, otherwise it is//! - \b EPI_HB16_WRHIGH use active high write strobe, otherwise it is//! - \b EPI_HB16_USE_RXFULL enables RXFULL signal with FIFO.//! - \b EPI_HB16_USE_TXEMPTY enables TXEMPTY signal with FIFO.//!       and XFIFO empty, D[15:0].  This submode uses no address or ALE.//!     - \b EPI_HB16_MODE_FIFO addes XFIFO controls with sense of XFIFO full//!     - \b EPI_HB16_MODE_SRAM sets as \b EPI_HB16_MODE_ADDEMUX but uses//!       D[15:0].//!     - \b EPI_HB16_MODE_ADDEMUX sets up data and address as separate,//! \e ui32Config is the logical OR of the following://! operation as chosen with the function EPIModeSet().  The parameter//! This function is used to configure the interface when used in Host-bus 16//! if a FIFO ready signal is holding off the transaction.//! \param ui32MaxWait is the maximum number of external clocks to wait//! Configures the interface for Host-bus 16 operation.// Write the main HostBus8 configuration register.//! FIFO is used aint32_t with RXFULL or TXEMPTY ready signals, then this//!         EPI_HB8_MODE_SRAM.//!     EPIS026 as CS0n, EPIS027 as CS1n, EPIS034 as CS2n and EPIS033 as CS3n.//!   - \b EPI_HB8_CSCFG_ALE_QUAD_CS sets EPIS030 as an address latch (ALE),//!     EPIS034 as CS2n and EPIS033 as CS3n.//!   - \b EPI_HB8_CSCFG_QUAD_CS sets EPIS030 as CS0n, EPIS027 as CS1n,//!     latch (ALE) and EPIS027 is used as a chip select.//!   - \b EPI_HB8_CSCFG_ALE_SINGLE_CS sets EPIS030 to operate as an address//!     external address map.//!     determined from the most significant address bit for the respective//!     EPIS027 as CS0n and EPIS026 as CS1n with the asserted chip select//!   - \b EPI_HB8_CSCFG_ALE_DUAL_CS sets EPIS030 as an address latch (ALE),//!     significant address bit for the respective external address map.//!     as CS1n with the asserted chip select determined from the most//!   - \b EPI_HB8_CSCFG_DUAL_CS sets EPIS030 to operate as CS0n and EPIS027//!     (ALE).//!   - \b EPI_HB8_CSCFG_ALE sets EPIS030 to operate as an address latch//!   - \b EPI_HB8_CSCFG_CS sets EPIS030 to operate as a chip select signal.//! enabled.//! configuration provided in \e ui32Config is used for all chip selects//! calling EPIConfigHB8CSSet() if \b EPI_HB8_CSBAUD is used.  Otherwise, the//! The use of \b EPI_HB8_CSBAUD also allows for unique chip select//! selects.  If \b EPI_HB8_CSBAUD is configured, EPIDividerCSSet() should be//!   the baud rate resulting from the divider in the lower 16 bits of the//!   in the upper 16 bits.  If this option is absent, both chip selects use//!   of the divider passed to EPIDividerSet() and CS1n uses the divider passed//!   chip select.  CS0n uses the baud rate specified by the lower 16 bits//! - \b EPI_HB8_CSBAUD use different baud rates when accessing devices on each//! - \b EPI_HB8_ALE_LOW sets address latch active low//! - \b EPI_HB8_ALE_HIGH sets the address latch active high (default)//!   low//! - \b EPI_HB8_IN_READY_EN_INVERT sets EPIS032 as ready/stall signal, active//! - \b EPI_HB8_IN_READY_EN sets EPIS032 as a ready/stall signal, active high//! - \b EPI_HB8_CLOCK_INVERT inverts the EPI clock//!   is available to read or write//! - \b EPI_HB8_CLOCK_GATE_IDLE sets the EPI clock to be held low when no data//!   all data transfers use bits [7:0].//!   correct byte lanes allowing data to be stored in bits [31:8].  If absent,//! - \b EPI_HB8_WORD_ACCESS - use Word Access mode to route bytes to the//!   - \b EPI_HB8_RDWAIT_3 sets read wait state to 8 EPI clocks//!   - \b EPI_HB8_RDWAIT_2 sets read wait state to 6 EPI clocks//!   - \b EPI_HB8_RDWAIT_1 sets read wait state to 4 EPI clocks//!   - \b EPI_HB8_RDWAIT_0 sets read wait state to 2 EPI clocks (default)//!   - \b EPI_HB8_WRWAIT_3  sets write wait state to 8 EPI clocks//!   - \b EPI_HB8_WRWAIT_2 sets write wait state to 6 EPI clocks//!   - \b EPI_HB8_WRWAIT_1 sets write wait state to 4 EPI clocks//!   - \b EPI_HB8_WRWAIT_0 sets write wait state to 2 EPI clocks (default)//!   active low//! - \b EPI_HB8_USE_RXFULL enables RXFULL signal with FIFO//! - \b EPI_HB8_USE_TXEMPTY enables TXEMPTY signal with FIFO//!     empty, D[7:0]//!   - \b EPI_HB8_MODE_FIFO adds XFIFO with sense of XFIFO full and XFIFO//!     switch for multiple reads instead of OEn strobing, D[7:0]//!   - \b EPI_HB8_MODE_SRAM as \b EPI_HB8_MODE_ADDEMUX, but uses address//!   - \b EPI_HB8_MODE_ADDEMUX sets up data and address separate, D[7:0]//!   - \b EPI_HB8_MODE_ADMUX sets data and address muxed, AD[7:0]//! This function is used to configure the interface when used in host-bus 8//! if a FIFO ready signal is holding off the transaction, 0-255.//! Configures the interface for Host-bus 8 operation.// Write the SDRAM configuration register.// Fill in the refresh count field of the configuration word.//! clock ticks.  It is an 11-bit value with a range of 0 - 2047 counts.//! The parameter \e ui16Refresh sets the refresh counter in units of core//! - \b EPI_SDRAM_SIZE_512MBIT size is a 512 Mbit device (64 MB).//! - \b EPI_SDRAM_SIZE_256MBIT size is a 256 Mbit device (32 MB).//! - \b EPI_SDRAM_SIZE_128MBIT size is a 128 Mbit device (16 MB).//! - \b EPI_SDRAM_SIZE_64MBIT size is a 64 Mbit device (8 MB).//! The SDRAM device size is specified with one of the following://! - \b EPI_SDRAM_FULL_POWER normal operating state.//! - \b EPI_SDRAM_LOW_POWER enter low power, self-refresh state.//! The low power mode is specified with one of the following://!   100 MHz//! - \b EPI_SDRAM_CORE_FREQ_50_100 defines core clock as 50 MHz < clk <=//! - \b EPI_SDRAM_CORE_FREQ_30_50 defines core clock as 30 MHz < clk <= 50 MHz//! - \b EPI_SDRAM_CORE_FREQ_15_30 defines core clock as 15 MHz < clk <= 30 MHz//! - \b EPI_SDRAM_CORE_FREQ_0_15 defines core clock as 0 MHz < clk <= 15 MHz//! The processor core frequency must be specified with one of the following://! \e ui32Config is the logical OR of several sets of choices://! mode is chosen with the function EPIModeSet().  The parameter//! This function is used to configure the SDRAM interface, when the SDRAM//! \param ui32Refresh is the refresh count in core clocks (0-2047).//! \param ui32Config is the SDRAM interface configuration.//! Configures the SDRAM mode of operation.// Assign the DMA TX count value provided.//! feature is available.//! Tiva part in use.  Please consult the data sheet to determine if this//! \note The availability of the EPI DMA TX count varies based on the//! should be set to values less than or equal to 1024.//! a single uDMA transfer has a maximum length of 1024 units so \e ui32Count//! Note that, although the EPI peripheral can handle counts of up to 65535,//! asserts an EPI uDMA transmit.//! A non-zero transmit count in combination with a FIFO threshold trigger//! This function is used to help configure the EPI uDMA transmit operations.//! \param ui32Count is the number of units to transmit by uDMA to WRFIFO.//! Sets the transfer count for uDMA transmit operations on EPI.// Write the divider value to the register bitfield.//! \note The availability of CS2n and CS3n varies based on the Tiva part//! and a value of 4 results in one sixth of the system clock rate.//! the system clock, value of 2 or 3 yields one quarter of the system clock//! For example, a divider value of 1 results in an EPI clock rate of half//! EPIClk = (Divider == 0) ? SysClk : (SysClk / (((Divider / 2) + 1) * 2))//! the following formula.//! value is used to derive the EPI clock rate from the system clock based on//! to determine the clock rate of the external interface.  The \e ui32Divider//! This function sets the clock divider(s) for the specified CS that is used//! the external interface (0-65535).//! \param ui32Divider is the value of the clock divider to be applied to//! \param ui32CS is the chip select to modify and has a valid range of 0-3.//! Sets the clock divider for the specified CS in the EPI module.// Write the divider value to the register.//! CS0n and the upper 16 bits define the divider for CS1n.//! contain two dividers.  The lower 16 bits define the divider to be used with//! are required for each chip select, the \e ui32Divider parameter must//! In cases where a dual chip select mode is in use and different clock rates//! formula.//! derive the EPI clock rate from the system clock based on the following//! clock rate of the external interface.  The \e ui32Divider value is used to//! This function sets the clock divider(s) that is used to determine the//! Sets the clock divider for the EPI module's CS0n/CS1n.// Write the mode word to the register.//! for \b EPI_MODE_DISABLE, which is used to disable the module.//! Selection of any of the above modes enables the EPI module, except//! - \b EPI_MODE_DISABLE - disable the EPI module//! - \b EPI_MODE_HB16 - use with host-bus 16-bit interface//! - \b EPI_MODE_HB8 - use with host-bus 8-bit interface//! - \b EPI_MODE_SDRAM - use with SDRAM device//! - \b EPI_MODE_GENERAL - use for general-purpose mode operation//! \e ui32Mode must be one of the following://! This functions sets the operating mode of the EPI module.  The parameter//! \param ui32Mode is the usage mode of the EPI module.//! Sets the usage mode of the EPI module.//! \return The 8-bit byte stored at address \e pui8Addr.//! need not use this function.//! address space is not affected and applications using this address mapping//! typically used to store the LCD controller frame buffer.  The 0x60000000//! per access.  This erratum affects only the 0x10000000 address space//! will impact performance due to an additional overhead of at least 2 cycles//! Use of this function on a device not affected by the erratum is safe but//! correctly. The function is defined as ``inline'' in epi.h.//! EPI access but using this function will allow EPI accesses to complete//! corruption depending upon memory accesses immediately before or after the//! the EPI#01 erratum.  Direct access to memory in these cases can cause data//! configured to use the address space at 0x10000000 on devices affected by//! This function must be used when reading bytes from EPI-attached memory//! \param pui8Addr is the address which is to be read.//! Safely reads a byte from the EPI 0x10000000 address space.//! This function must be used when writing bytes to EPI-attached memory//! \param ui8Value is the 8-bit byte to write.//! \param pui8Addr is the address which is to be written.//! Safely writes a byte to the EPI 0x10000000 address space.//! \return The 16-bit word stored at address \e pui16Addr.//! This function must be used when reading half-words from EPI-attached memory//! \param pui16Addr is the address which is to be read.//! Safely reads a half-word from the EPI 0x10000000 address space.//! This function must be used when writing half-words to EPI-attached memory//! \param ui16Value is the 16-bit half-word to write.//! \param pui16Addr is the address which is to be written.//! Safely writes a half-word to the EPI 0x10000000 address space.//! \return The 32-bit word stored at address \e pui32Addr.//! This function must be used when reading words from EPI-attached memory//! \param pui32Addr is the address which is to be read.//! Safely reads a word from the EPI 0x10000000 address space.//! This function must be used when writing words to EPI-attached memory//! \param ui32Value is the 32-bit word to write.//! \param pui32Addr is the address which is to be written.//! Safely writes a word to the EPI 0x10000000 address space.// available in exactly one object module (this one).// Ensure that erratum workaround inline functions have a public version// Helper masks for chip select configuration options.//! \addtogroup epi_api// epi.c - Driver for the EPI module./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/flash.c1074778124107477811210747781202755788800275578880821474836490x800000011074782688107478269210747826961074782700pui32User0 != 0pui32User1 != 0pui32User2 != 0pui32User3 != 0ui32ProtectREui32ProtectPEui32Bankg_pui32FMPRERegs[ui32Bank]const uint32_t[16]unsigned long[16]g_pui32FMPPERegs[ui32Bank]0x1-1(-1)!(ui32Address & (FLASH_PROTECT_SIZE - 1))(eProtect == FlashReadWrite) || (eProtect == FlashReadOnly) || (eProtect == FlashExecuteOnly)ui32FMPREui32FMPPE(FLASH_PROTECT_SIZE * 32)(FLASH_PROTECT_SIZE * 32) - 1((FLASH_PROTECT_SIZE * 32) - 1)(FlashExecuteOnly)(FlashReadOnly)(FlashReadWrite)51315379729(FLASH_FCMISC_AMISC | FLASH_FCMISC_VOLTMISC |
                           FLASH_FCMISC_INVDMISC | FLASH_FCMISC_PROGMISC)FLASH_FWBN + (ui32Address & 0x7c)0x400FD100 + (ui32Address & 0x7c)0x7f(0x7f)4294967168~(0x7f)0x7c1074778160107477836810747781442755788801(FLASH_FCRIS_ARIS | FLASH_FCRIS_VOLTRIS |
                             FLASH_FCRIS_INVDRIS | FLASH_FCRIS_PROGRIS)!(ui32Address & 3)!(ui32Count & 3)2561(FLASH_FCMISC_AMISC | FLASH_FCMISC_VOLTMISC |
                           FLASH_FCMISC_ERMISC)2755788802(FLASH_FCRIS_ARIS | FLASH_FCRIS_VOLTRIS |
                             FLASH_FCRIS_ERRIS)!(ui32Address & (FLASH_ERASE_SIZE - 1))const uint32_t[]unsigned long[]g_pui32FMPRERegs1074782720107478272410747827281074782732107478273610747827401074782744107478274810747827521074782756107478276010747827641074782768107478277210747827761074782780g_pui32FMPPERegs1074783232107478323610747832401074783244107478324810747832521074783256107478326010747832641074783268107478327210747832761074783280107478328410747832881074783292//! interrupt from being triggered again immediately upon exit.//! This function must be called in the interrupt handler to keep the//! - \b FLASH_INT_PROGRAM_ERR occurs when a program operation fails.//! - \b FLASH_INT_ERASE_ERR occurs when an erase operation fails.//! contains a 0 to a 1.//! - \b FLASH_INT_DATA_ERR occurs when an operation attempts to program a bit that//! the flash operation and the operation was terminated.//! - \b FLASH_INT_VOLTAGE_ERR occurs when the voltage was out of spec during//! the EEPROM interrupt can be determined by reading the EEDONE register.//! - \b FLASH_INT_EEPROM occurs when an EEPROM interrupt occurs. The source of//! - \b FLASH_INT_PROGRAM occurs when a programming or erase cycle completes.//! on a block of flash that is marked as read-only or execute-only.//! - \b FLASH_INT_ACCESS occurs when a program or erase action was attempted//! ui32IntFlags parameter can be the logical OR of any of the following//! no longer assert.  The//! The specified flash controller interrupt sources are cleared, so that they//! Clears flash controller interrupt sources.//! FLASH_INT_PROGRAM_ERR.//! FLASH_INT_VOLTAGE_ERR, FLASH_INT_DATA_ERR, FLASH_INT_ERASE_ERR, and//! \b FLASH_INT_ACCESS, \b FLASH_INT_PROGRAM, \b FLASH_INT_EEPROM,//! \return The current interrupt status, enumerated as a bit field of//! allowed to reflect to the processor can be returned.//! Either the raw interrupt status or the status of interrupts that are//! This function returns the interrupt status for the flash controller.//! interrupt; disabled sources have no effect on the processor.//! Only the sources that are enabled can be reflected to the processor//! This function disables the indicated flash controller interrupt sources.//! The ui32IntFlags parameter can be the logical OR of any of the following//! Disables individual flash controller interrupt sources.//! This function enables the indicated flash controller interrupt sources.//! Enables individual flash controller interrupt sources.//! controller so that the interrupt handler is no longer called.//! This function clears the handler to be called when the flash interrupt//! Unregisters the interrupt handler for the flash interrupt.// Enable the flash interrupt.//! is automatically enabled when the handler is registered.//! interrupt when a program or erase operation has completed.  The interrupt//! or trying to read from an execute-only block.  It can also generate an//! flash access occurs, such as trying to program or erase a read-only block,//! occurs.  The flash controller can generate an interrupt when an invalid//! This function sets the handler to be called when the flash interrupt//! interrupt occurs.//! \param pfnHandler is a pointer to the function to be called when the flash//! Registers an interrupt handler for the flash interrupt.// Success.// Wait until the write has completed.// Tell the flash controller to commit a USER Register.// USER Register 3 is 11.// USER Register 2 is 10 and// USER Register 1 is 01,// USER Register 0 is 00,// The value of the least significant bits for// The 2 least signigicant bits, specify the exact User Register to save.// Setting the MSB of FMA will trigger a permanent save of a USER Register.//! \return Returns 0 on success, or -1 if a hardware error is encountered.//! not be interrupted with a power loss.//! \note To ensure data integrity of the user registers, the commits should//! This function does not return until the protection has been saved.//! power cycle does not change the flash protection.//! settings permanent.  This operation is non-reversible; a chip reset or//! This function makes the currently programmed user register 0, 1, 2 and 3//! Saves the user registers.// Tell the flash controller to write the USER1 Register.// register.  Bit 0 will indicate User 0 (0) or User 1 (1).// Setting the MSB of FMA will trigger a permanent save of a USER//! does not change the flash protection.//! permanent.  This operation is non-reversible; a chip reset or power cycle//! This function makes the currently programmed user register 0 and 1 settings//! Saves the user registers 0 and 1.// Save the new values into the user registers.//! the specified values.//! This function sets the contents of the user registers 0, 1, 2 and 3 to//! \param ui32User3 is the value to store in USER Register 3.//! \param ui32User2 is the value to store in USER Register 2.//! \param ui32User1 is the value to store in USER Register 1.//! \param ui32User0 is the value to store in USER Register 0.//! Sets the user registers 0 to 3// Get and store the current value of the user registers.// Verify that the pointers are valid.//! stores them in the specified locations.//! This function reads the contents of user registers 0, 1, 2 and 3, and//! \param pui32User3 is a pointer to the location to store USER Register 3.//! \param pui32User2 is a pointer to the location to store USER Register 2.//! \param pui32User1 is a pointer to the location to store USER Register 1.//! \param pui32User0 is a pointer to the location to store USER Register 0.//! Gets all the user registers.//! This function sets the contents of the user registers 0 and 1 to//! Sets the user registers.//! This function reads the contents of user registers 0 and 1, and//! Gets the user registers.// Tell the flash controller to write the flash protection register.// Save the entire bank of 8 flash protection registers.//! This function makes the currently programmed flash protection settings//! Saves the flash protection settings.// Set the new protection for the specified flash bank.// The block is already read/write, so there is nothing to do.// read/write.// The block can not be made read/write if it is not already// Make this block read/write.// We're done handling this protection.// Make this block read only.// The block can not be made read only if it is execute only.// Turn off the read and program bits for this block.// Make this block execute only.// Set the protection based on the requested protection.// Get the current protection for the specified flash bank.// block number.// the "raw" block number, and convert ui32Address to a "relative"// ui32Address contains a "raw" block number.  Derive the Flash Bank from// Convert the address into a block number.//! protection was specified.//! \return Returns 0 on success, or -1 if an invalid address or an invalid//! FlashProtectSave() function.//! flash interrupt).  To make the flash protection permanent, use the//! protection environment to check for inappropriate flash access (via the//! This protocol allows the application to be executed in the desired flash//! Changes to the flash protection are maintained only until the next reset.//! result in a failure (and are prevented by the hardware).//! block protection less stringent (that is, read-only to read/write)//! execute-only cannot have their protection modified.  Attempts to make the//! Blocks that are read-only can be made execute-only.  Blocks that are//! option.  Blocks that are read/write can be made read-only or execute-only.//! to the device data sheet to determine the granularity for each protection//! This function sets the protection for the specified block of flash.  Refer//! of \b FlashReadWrite, \b FlashReadOnly, or \b FlashExecuteOnly.//! \param eProtect is the protection to be applied to the block.  Can be one//! \param ui32Address is the start address of the flash block to be protected.//! Sets the protection setting for a block of flash.// This block is read/write; it can be read, erased, and programmed.// programmed).// This block is marked as read only (that is, it can not be erased or// fetch interface).// or programmed, and the only reads allowed are via the instruction// This block is marked as execute only (that is, it can not be erased// is specified by the address.// Check the appropriate protection bits for the block of memory that// flash bank.// Read the appropriate flash protection registers for the specified// from ui32Address for subsequent reference.// Calculate the Flash Bank from Base Address, and mask off the Bank//! FlashProtectSet() for possible values.//! \return Returns the protection setting for this block.  See//! processor and debugger data reads are not allowed.//! blocks can be read and executed.  Execute-only blocks can only be executed;//! Read/write blocks can be read, executed, erased, and programmed.  Read-only//! protection option. A block can be read/write, read-only, or execute-only.//! Refer to the device data sheet to determine the granularity for each//! This function gets the current protection for the specified block of flash.//! \param ui32Address is the start address of the flash block to be queried.//! Gets the protection setting for a block of flash.// Return an error if an access violation occurred.// Wait until the write buffer has been programmed.// Program the contents of the write buffer into flash.// Write this word into the write buffer.// Loop over the words in this 32-word block.// Set the address of this block of words.// Loop over the words to be programmed.// Clear the flash access and error interrupts.//! \return Returns 0 on success, or -1 if a programming error is encountered.//! This function does not return until the data has been programmed.//! verify the programmed contents, if such verification is required.//! and byte count must both be multiples of four.  It is up to the caller to//! Because the flash is programmed one word at a time, the starting address//! This function programs a sequence of words into the on-chip flash.//! multiple of four.//! \param ui32Count is the number of bytes to be programmed.  Must be a//! be a multiple of four.//! \param ui32Address is the starting address in flash to be programmed.  Must//! \param pui32Data is a pointer to the data to be programmed.//! Programs flash.// Return an error if an access violation or erase error occurred.// Wait until the block has been erased.// Erase the block.//! specified or the block is write-protected.//! \return Returns 0 on success, or -1 if an invalid block address was//! This function does not return until the block has been erased.//! device datasheet to determine the block size in use.//! 1-KB blocks but TM4C129x devices use 16-KB blocks. Please consult the//! The flash block size is device-class dependent.  All TM4C123x devices use//! be erased.//! block is filled with 0xFF bytes.  Read-only and execute-only blocks cannot//! This function erases a block of the on-chip flash.  After erasing, the//! \param ui32Address is the start address of the flash block to be erased.//! Erases a block of flash.// Memory Protection Read Enable (FMPRE) register.// An array that maps the specified memory bank to the appropriate Flash// Memory Protection Program Enable (FMPPE) register.//! \addtogroup flash_api// flash.c - Driver for programming the on-chip flash./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/fpu.h/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/fpu.c"driverlib/fpu.h"FPURoundingModeSetNVIC_FPDSC0xE000EF3C375815762812582912NVIC_FPDSC_RMODE_M(NVIC_FPDSC_RMODE_M)4282384383~(NVIC_FPDSC_RMODE_M)FPUFlushToZeroModeSetNVIC_FPDSC_FZ(NVIC_FPDSC_FZ)4278190079~(NVIC_FPDSC_FZ)FPUNaNModeSetNVIC_FPDSC_DN(NVIC_FPDSC_DN)4261412863~(NVIC_FPDSC_DN)FPUHalfPrecisionModeSetNVIC_FPDSC_AHP(NVIC_FPDSC_AHP)4227858431~(NVIC_FPDSC_AHP)FPUStackingDisableNVIC_FPCC0xE000EF343758157620NVIC_FPCC_ASPENNVIC_FPCC_LSPEN(NVIC_FPCC_ASPEN | NVIC_FPCC_LSPEN)1073741823~(NVIC_FPCC_ASPEN | NVIC_FPCC_LSPEN)FPULazyStackingEnableFPUStackingEnable3221225471~NVIC_FPCC_LSPENFPUDisableNVIC_CPAC0xE000ED8837581571923145728NVIC_CPAC_CP10_MNVIC_CPAC_CP11_M(NVIC_CPAC_CP10_M | NVIC_CPAC_CP11_M)4279238655~(NVIC_CPAC_CP10_M | NVIC_CPAC_CP11_M)NVIC_CPAC_CP10_DISNVIC_CPAC_CP11_DISFPUEnableNVIC_CPAC_CP10_FULLNVIC_CPAC_CP11_FULL// Set the rounding mode.//! instructions, the default mode is used.//! \note Unless this function is called prior to executing any floating-point//! - \b FPU_ROUND_ZERO - round toward zero//! - \b FPU_ROUND_NEG_INF - round toward negative infinity//! - \b FPU_ROUND_POS_INF - round toward positive infinity//! - \b FPU_ROUND_NEAREST - round toward the nearest value//! The following rounding modes are available (as specified by \e ui32Mode)://! value.  The default mode is \b FPU_ROUND_NEAREST.//! a floating-point operation, the result is rounded toward the specified//! This function selects the rounding mode for floating-point results.  After//! \param ui32Mode is the rounding mode.//! Selects the rounding mode for floating-point results.// Set the flush-to-zero mode.//! (as well as IEEE compliance).//! zero, greatly improving the execution speed at the expense of some accuracy//! is fully IEEE compliant.  When enabled, values close to zero are treated as//! floating-point unit.  When disabled (the default), the floating-point unit//! This function enables or disables the flush-to-zero mode of the//! \b FPU_FLUSH_TO_ZERO_DIS or \b FPU_FLUSH_TO_ZERO_EN.//! \param ui32Mode is the flush-to-zero mode; which is either//! Selects the flush-to-zero mode.// Set the NaN mode.//! the default NaN.//! computations.  NaNs can either propagate (the default), or they can return//! This function selects the handling of NaN results during floating-point//! \b FPU_NAN_PROPAGATE or \b FPU_NAN_DEFAULT.//! \param ui32Mode is the mode for NaN results; which is either//! Selects the NaN mode.// Set the half-precision floating-point format.//! default setting is the IEEE format.//! encode infinity (positive or negative) or NaN (quiet or signaling).  The//! alternative representation has a larger range but does not have a way to//! representation and the Cortex-M processor alternative representation.  The//! This function selects between the IEEE half-precision floating-point//! which is either \b FPU_HALF_IEEE or \b FPU_HALF_ALTERNATE.//! \param ui32Mode is the format for half-precision floating-point value,//! Selects the format of half-precision floating-point values.// unit.// Disable automatic and lazy state preservation for the floating-point//! floating-point context of the main thread of execution.//! floating-point operations performed in an interrupt handler destroy the//! an interrupt is handled.  When floating-point context stacking is disabled,//! This function disables the stacking of floating-point registers s0-s15 when//! Disables the stacking of floating-point registers.// Enable automatic and lazy state preservation for the floating-point//! state is saved if floating-point instructions are used).//! to use floating-point in interrupt handlers (because the floating-point//! the floating-point state is not saved on interrupt entry) and the ability//! This method provides a compromise between fast interrupt response (because//! saved (as the result of executing a floating-point instruction).//! interrupt handler, the floating-point context is only restored if it was//! first saved into the space reserved on the stack.  On completion of the//! executed from within the interrupt context, the floating-point context is//! floating-point state is not saved.  If a floating-point instruction is//! reserved on the stack for the floating-point context, but the//! when an interrupt is handled.  When lazy stacking is enabled, space is//! This function enables the lazy stacking of floating-point registers s0-s15//! Enables the lazy stacking of floating-point registers.// is always stacked when floating-point instructions are used).// disable lazy state preservation (meaning that the floating-point state// Enable automatic state preservation for the floating-point unit, and//! response latency.//! stacking operation from 8 words to 26 words, also increasing the interrupt//! On the other hand, stacking the floating-point registers increases the//! values of s0-s15 are not likely to be preserved for the interrupted code.//! instructions cannot be safely executed in an interrupt handler because the//! If the floating-point registers are not stacked, floating-point//! restored.//! stack space.  Upon return from the interrupt, the floating-point context is//! the floating-point context and the floating-point state is saved into this//! an interrupt is handled.  When enabled, space is reserved on the stack for//! This function enables the stacking of floating-point registers s0-s15 when//! Enables the stacking of floating-point registers.// Disable the coprocessors used by the floating-point unit.//! instructions from executing (generating a NOCP usage fault instead).//! This function disables the floating-point unit, preventing floating-point//! Disables the floating-point unit.// Enable the coprocessors used by the floating-point unit.//! in a NOCP usage fault.//! performing any hardware floating-point operations; failure to do so results//! instructions to be executed.  This function must be called prior to//! This function enables the floating-point unit, allowing the floating-point//! Enables the floating-point unit.//! \addtogroup fpu_api//         processor.// fpu.c - Routines for manipulating the floating-point unit in the Cortex-M/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/inc/hw_gpio.hGPIO_PC_EDM1_SGPIO_PC_EDM2_SGPIO_PC_EDM3_SGPIO_PC_EDM4_SGPIO_PC_EDM5_SGPIO_PC_EDM6_SGPIO_PC_EDM7_SGPIO_PC_EDM0_PLUS2MAGPIO_PC_EDM0_6MAGPIO_PC_EDM0_DISABLEGPIO_PC_EDM0_MGPIO_PC_EDM1_MGPIO_PC_EDM2_MGPIO_PC_EDM3_MGPIO_PC_EDM4_MGPIO_PC_EDM5_MGPIO_PC_EDM6_MGPIO_PC_EDM7_MGPIO_PP_EDEGPIO_WAKESTAT_STAT4GPIO_WAKELVL_WAKELVL4GPIO_WAKEPEN_WAKEP4GPIO_DR12R_DRV12_12MAGPIO_DR12R_DRV12_MGPIO_SI_SUMGPIO_LOCK_KEY0x4C4F434BGPIO_LOCK_LOCKEDGPIO_LOCK_UNLOCKEDGPIO_LOCK_MGPIO_ICR_GPIO_SGPIO_ICR_GPIO_MGPIO_ICR_DMAICGPIO_MIS_GPIO_SGPIO_MIS_GPIO_MGPIO_MIS_DMAMISGPIO_RIS_GPIO_SGPIO_RIS_GPIO_MGPIO_RIS_DMARISGPIO_IM_GPIO_SGPIO_IM_GPIO_MGPIO_IM_DMAIMEGPIO_O_PCGPIO_O_PPGPIO_O_WAKESTAT0x00000548GPIO_O_WAKELVL0x00000544GPIO_O_WAKEPENGPIO_O_DR12R0x0000053CGPIO_O_SI0x00000538GPIO_O_DMACTL0x00000534GPIO_O_ADCCTL0x00000530GPIO_O_PCTL0x0000052CGPIO_O_AMSEL0x00000528GPIO_O_CR0x00000524GPIO_O_LOCK0x00000520GPIO_O_DEN0x0000051CGPIO_O_SLR0x00000518GPIO_O_PDR0x00000514GPIO_O_PUR0x00000510GPIO_O_ODR0x0000050CGPIO_O_DR8R0x00000508GPIO_O_DR4R0x00000504GPIO_O_DR2RGPIO_O_AFSEL0x00000420GPIO_O_ICR0x0000041CGPIO_O_MISGPIO_O_RISGPIO_O_IMGPIO_O_IEV0x0000040CGPIO_O_IBE0x00000408GPIO_O_IS0x00000404GPIO_O_DIRGPIO_O_DATA__HW_GPIO_H__// __HW_GPIO_H__// bit adds an additional 4 mA// GPIODR8R of GPIODR12R register// and setting the corresponding// GPIODR4R register bit adds 2 mA// setting the corresponding// A 2 mA driver is always enabled;// provided// An additional 6 mA option is// function as normal// Select (GPIODRnR) registers// are maintained. GPIO n Drive// Drive values of 2, 4 and 8 mA// Extended Drive Mode Bit 0// Extended Drive Mode Bit 1// Extended Drive Mode Bit 2// Extended Drive Mode Bit 3// Extended Drive Mode Bit 4// Extended Drive Mode Bit 5// Extended Drive Mode Bit 6// Extended Drive Mode Bit 7// The following are defines for the bit fields in the GPIO_O_PC register.// Extended Drive Enable// The following are defines for the bit fields in the GPIO_O_PP register.// P[4] Wake Status// The following are defines for the bit fields in the GPIO_O_WAKESTAT// P[4] Wake Level// The following are defines for the bit fields in the GPIO_O_WAKELVL register.// P[4] Wake Enable// The following are defines for the bit fields in the GPIO_O_WAKEPEN register.// programmed to 0x3// GPIOPC EDM bit field is// is set and the appropriate// only valid if the GPIOPP EDE bit// 12-mA drive. This encoding is// The corresponding GPIO pin has// Output Pad 12-mA Drive Enable// The following are defines for the bit fields in the GPIO_O_DR12R register.// Summary Interrupt// The following are defines for the bit fields in the GPIO_O_SI register.// Unlocks the GPIO_CR register// and may not be modified// The GPIOCR register is locked// and may be modified// The GPIOCR register is unlocked// GPIO Lock// The following are defines for the bit fields in the GPIO_O_LOCK register.// GPIO Interrupt Clear// GPIO uDMA Interrupt Clear// The following are defines for the bit fields in the GPIO_O_ICR register.// GPIO Masked Interrupt Status// GPIO uDMA Done Masked Interrupt// The following are defines for the bit fields in the GPIO_O_MIS register.// GPIO Interrupt Raw Status// GPIO uDMA Done Interrupt Raw// The following are defines for the bit fields in the GPIO_O_RIS register.// GPIO Interrupt Mask Enable// GPIO uDMA Done Interrupt Mask// The following are defines for the bit fields in the GPIO_O_IM register.// GPIO Peripheral Configuration// GPIO Peripheral Property// GPIO Wake Status// GPIO Wake Level// GPIO Wake Pin Enable// GPIO 12-mA Drive Select// GPIO Select Interrupt// GPIO DMA Control// GPIO ADC Control// GPIO Port Control// GPIO Analog Mode Select// GPIO Commit// GPIO Digital Enable// GPIO Slew Rate Control Select// GPIO Pull-Down Select// GPIO Pull-Up Select// GPIO Open Drain Select// GPIO 8-mA Drive Select// GPIO 4-mA Drive Select// GPIO 2-mA Drive Select// GPIO Alternate Function Select// GPIO Raw Interrupt Status// GPIO Interrupt Mask// GPIO Interrupt Event// GPIO Interrupt Both Edges// GPIO Interrupt Sense// GPIO Direction// GPIO Data// The following are defines for the GPIO register offsets.// hw_gpio.h - Defines and Macros for GPIO hardware./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/gpio.h/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/gpio.c"driverlib/gpio.h""inc/hw_gpio.h"GPIOUnlockPinui32Port + GPIO_O_LOCKui32Port + 0x0000052013121280262987ui32Port + GPIO_O_CRui32Port + 0x000005241316_GPIOBaseValid(ui32Port)GPIOADCTriggerDisableui32Port + GPIO_O_ADCCTLui32Port + 0x000005301328GPIOADCTriggerEnableGPIODMATriggerDisableui32Port + GPIO_O_DMACTLui32Port + 0x000005341332GPIODMATriggerEnableGPIOPinConfigureui32Shift0xff1074782316const uint32_t[36]unsigned long[36]ui32Base + GPIO_O_PCTLui32Base + 0x0000052C1324((ui32PinConfig >> 16) & 0xff) < 18((ui32PinConfig >> 8) & 0xe3) == 0GPIOPinWakeStatusui32Port + GPIO_O_WAKESTATui32Port + 0x000005481352GPIOPinTypeWakeLowGPIO_DIR_MODE_INGPIO_STRENGTH_2MA264GPIO_PIN_TYPE_WAKE_LOWGPIOPinTypeWakeHighGPIO_PIN_TYPE_WAKE_HIGHGPIOPinTypeUSBDigitalGPIO_DIR_MODE_HWGPIO_PIN_TYPE_STDGPIOPinTypeUSBAnalogGPIO_PIN_TYPE_ANALOGGPIOPinTypeUARTGPIOPinTypeTraceGPIOPinTypeTimerGPIOPinTypeSSIGPIOPinTypeQEIGPIO_PIN_TYPE_STD_WPUGPIOPinTypePWMGPIOPinTypeOneWireGPIOPinTypeLCDGPIO_STRENGTH_8MAGPIOPinTypeI2CSCLGPIOPinTypeI2CGPIO_PIN_TYPE_ODGPIOPinTypeHibernateRTCCLKGPIOPinTypeGPIOOutputODGPIO_DIR_MODE_OUTGPIOPinTypeGPIOOutputGPIOPinTypeGPIOInputGPIOPinTypeEthernetMIIGPIOPinTypeEthernetLEDGPIOPinTypeEPIui32Portui8Pinsui32PinConfigGPIOPinTypeDIVSCLKGPIOPinTypeComparatorOutputGPIOPinTypeComparatorGPIOPinTypeCANGPIOPinTypeADCGPIOPinWriteui32Port + (GPIO_O_DATA + (ui8Pins << 2))ui32Port + (0x00000000 + (ui8Pins << 2))GPIOPinReadGPIOIntUnregisterPin(ui32Port == GPIO_PORTP_BASE) || (ui32Port == GPIO_PORTQ_BASE)(ui32Pin > 0) && (ui32Pin < 8)GPIOIntRegisterPinpfnIntHandler != 0GPIOIntUnregisterGPIOIntRegisterGPIOIntClearui32Port + GPIO_O_ICRui32Port + 0x0000041C1052GPIOIntStatusui32Port + GPIO_O_MISui32Port + 0x00000418ui32Port + GPIO_O_RISui32Port + 0x00000414GPIOIntDisableui32Port + GPIO_O_IMui32Port + 0x00000410GPIOIntEnableGPIOPadConfigGetui32PinTypeui32Strengthui32Port + GPIO_O_DR2Rui32Port + 0x00000500ui32Port + GPIO_O_DR4Rui32Port + 0x000005041284ui32Port + GPIO_O_DR8Rui32Port + 0x000005081288ui32Port + GPIO_O_SLRui32Port + 0x000005181304ui32Port + GPIO_O_DR12Rui32Port + 0x0000053Cui32Port + GPIO_O_PCui32Port + 0x00000FC413400x10ui32Port + GPIO_O_ODRui32Port + 0x0000050C1292ui32Port + GPIO_O_PURui32Port + 0x000005101296ui32Port + GPIO_O_PDRui32Port + 0x000005141300ui32Port + GPIO_O_DENui32Port + 0x0000051C1308ui32Port + GPIO_O_WAKEPENui32Port + 0x00000540ui32Port + GPIO_O_WAKELVLui32Port + 0x00000544134413480x200ui8Pin < 8GPIOPadConfigSetui8Bitui8Valui32PinpfnIntHandlerui8Pinpui32Strengthpui32PinType0x300ui32Port + GPIO_O_AMSELui32Port + 0x000005281320(ui32Strength == GPIO_STRENGTH_2MA) || (ui32Strength == GPIO_STRENGTH_4MA) || (ui32Strength == GPIO_STRENGTH_6MA) || (ui32Strength == GPIO_STRENGTH_8MA) || (ui32Strength == GPIO_STRENGTH_8MA_SC) || (ui32Strength == GPIO_STRENGTH_10MA) || (ui32Strength == GPIO_STRENGTH_12MA)(ui32PinType == GPIO_PIN_TYPE_STD) || (ui32PinType == GPIO_PIN_TYPE_STD_WPU) || (ui32PinType == GPIO_PIN_TYPE_STD_WPD) || (ui32PinType == GPIO_PIN_TYPE_OD) || (ui32PinType == GPIO_PIN_TYPE_WAKE_LOW) || (ui32PinType == GPIO_PIN_TYPE_WAKE_HIGH) || (ui32PinType == GPIO_PIN_TYPE_ANALOG)GPIOIntTypeGetui32IBEui32ISui32IEVui32SIui32Port + GPIO_O_IBEui32Port + 0x000004081032ui32Port + GPIO_O_ISui32Port + 0x000004041028ui32Port + GPIO_O_IEVui32Port + 0x0000040C1036ui32Port + GPIO_O_SIui32Port + 0x000005381336GPIOIntTypeSet(0x01)~(0x01)((ui32IntType & 0xF) == GPIO_FALLING_EDGE) || ((ui32IntType & 0xF) == GPIO_RISING_EDGE) || ((ui32IntType & 0xF) == GPIO_BOTH_EDGES) || ((ui32IntType & 0xF) == GPIO_LOW_LEVEL) || ((ui32IntType & 0xF) == GPIO_HIGH_LEVEL)((ui32IntType & 0x000F0000) == 0) || (((ui32IntType & 0x000F0000) == GPIO_DISCRETE_INT) && ((ui32Port == GPIO_PORTP_BASE) || (ui32Port == GPIO_PORTQ_BASE)))GPIODirModeGetui32Dirui32AFSELui32Port + GPIO_O_DIRui32Port + 0x00000400ui32Port + GPIO_O_AFSELui32Port + 0x000004201056GPIODirModeSet(ui32PinIO == GPIO_DIR_MODE_IN) || (ui32PinIO == GPIO_DIR_MODE_OUT) || (ui32PinIO == GPIO_DIR_MODE_HW)_GPIOIntNumberGetui32Rowsconst uint32_t[2]unsigned long[2]const uint32_t(*)[2]unsigned long(*)[2]ppui32GPIOIntMapconst uint32_t[24][2]unsigned long[24][2]const uint_fast32_tg_ui32GPIOIntMapBlizzardRowsconst uint32_t[27][2]unsigned long[27][2]g_ui32GPIOIntMapSnowflakeRowsg_pui32GPIOBaseAddrs1073758208GPIO_PORTA_BASE1074102272GPIO_PORTA_AHB_BASE1073762304GPIO_PORTB_BASE1074106368GPIO_PORTB_AHB_BASE1073766400GPIO_PORTC_BASE1074110464GPIO_PORTC_AHB_BASE1073770496GPIO_PORTD_BASE1074114560GPIO_PORTD_AHB_BASE1073889280GPIO_PORTE_BASE1074118656GPIO_PORTE_AHB_BASE1073893376GPIO_PORTF_BASE1074122752GPIO_PORTF_AHB_BASE1073897472GPIO_PORTG_BASE1074126848GPIO_PORTG_AHB_BASE1073901568GPIO_PORTH_BASE1074130944GPIO_PORTH_AHB_BASE1073991680GPIO_PORTJ_BASE1074135040GPIO_PORTJ_AHB_BASE1074139136GPIO_PORTK_BASE1074143232GPIO_PORTL_BASE1074147328GPIO_PORTM_BASE1074151424GPIO_PORTN_BASE1074155520GPIO_PORTP_BASE1074159616GPIO_PORTQ_BASE1074163712GPIO_PORTR_BASE1074167808GPIO_PORTS_BASE1074171904GPIO_PORTT_BASE216sizeof(g_ppui32GPIOIntMapSnowflake)sizeof(g_ppui32GPIOIntMapSnowflake[0])sizeof(g_ppui32GPIOIntMapSnowflake) /
     sizeof(g_ppui32GPIOIntMapSnowflake[0])(sizeof(g_ppui32GPIOIntMapSnowflake) /
     sizeof(g_ppui32GPIOIntMapSnowflake[0]))const uint32_t[][2]unsigned long[][2]g_ppui32GPIOIntMapSnowflakesizeof(g_ppui32GPIOIntMapBlizzard)sizeof(g_ppui32GPIOIntMapBlizzard[0])sizeof(g_ppui32GPIOIntMapBlizzard) / sizeof(g_ppui32GPIOIntMapBlizzard[0])g_ppui32GPIOIntMapBlizzardui32IntTypeui32PinIO// Commit the pin to keep it in GPIO mode// Unlock the port by using the device LOCK key//! not protected by the GPIOCR register.//! commit the change.  This function will have no effect on pins which are//! been locked, the following procedure is required to unlock the pin and//! functionality such as JTAG operation.  To be able to use pins which have//! This function is used to unlock pins which were locked for specific//! \param ui8Pins is the bit-packed representation of the pin(s).//! \param ui32Port is the base address of the GPIO port.//! Unlocks a GPIO pin which had been previously locked.// Set the pin as a DMA trigger.//! enabled via a call to GPIOADCTriggerEnable().//! sequence.  This function can be used to disable this feature if it was//! This function disables a GPIO pin to be used as a trigger to start an ADC//! Disable a GPIO pin as a trigger to start an ADC capture.//! \b ADC_TRIGGER_EXTERNAL parameter.//! the ADC module, the ADCSequenceConfigure() function must be called with the//! enabled for the selected pin.  To enable the use of a GPIO pin to trigger//! ADC sequence.  The GPIO pin still generates interrupts if the interrupt is//! sequence.  Any GPIO pin can be configured to be an external trigger for an//! This function enables a GPIO pin to be used as a trigger to start an ADC//! Enables a GPIO pin as a trigger to start an ADC capture.//! was enabled via a call to GPIODMATriggerEnable().//! uDMA transaction.  This function can be used to disable this feature if it//! This function disables a GPIO pin from being used as a trigger to start a//! Disables a GPIO pin as a trigger to start a DMA transaction.//! enabled for the selected pin.//! the uDMA.  The GPIO pin still generates interrupts if the interrupt is//! transaction.  Any GPIO pin can be configured to be an external trigger for//! This function enables a GPIO pin to be used as a trigger to start a uDMA//! Enables a GPIO pin as a trigger to start a DMA transaction.// Write the requested pin muxing value for this GPIO pin.// Extract the shift from the input value.// AHB aperture as appropriate.// Get the base address of the GPIO module, selecting either the APB or the// Extract the base address index from the input value.//! assignment to the higher letter port is ignored.//! pins, the signal is assigned to the port with the lowest letter and the//! \note If the same signal is assigned to two different GPIO port//! correct pin mappings for the TM4C129XNCZAD device.//! For example, \b PART_TM4C129XNCZAD must be defined in order to get the//! defines are included so that they match the device that is being used.//! <tt>pin_map.h</tt>.  The \b PART_<partno> defines controls which set of//! The available mappings are supplied on a per-device basis in//! configure a pin, a GPIOPinType*() function should also be called.//! many of them can be associated with more than one GPIO pin).  To fully//! only be associated with a single GPIO pin at a time (despite the fact that//! time can be associated with a GPIO pin, and each peripheral function should//! associated with a particular GPIO pin.  Only one peripheral function at a//! This function configures the pin mux that selects the peripheral function//! of the \b GPIO_P??_??? values.//! \param ui32PinConfig is the pin configuration value, specified as only one//! Configures the alternate function of a GPIO pin.//! \return Returns the wake pin status.//! datasheet for information on affected pins.//! example application for the mechanism required and consult your part//! registers before this function can be called.  Please see the ``gpio_jtag''//! using direct register writes to the relevant GPIO_O_LOCK and GPIO_O_CR//! locked against inadvertent reconfiguration.  These pins must be unlocked//! JTAG/SWD interface and any pin capable of acting as an NMI input, are//! \note A subset of GPIO pins on Tiva devices, notably those used by the//! to ensure that the device you are using supports GPIO wake pins.//! \note This function is not available on all devices, consult the data sheet//! bitfield shows low or high pin state via a value of 0 or 1.//! This function returns the GPIO wake pin status values.  The returned//! Retrieves the wake pins status.// Set the pad(s) for wake-high operation.// Make the pin(s) inputs.//! represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.//! set identifies the pin to be accessed, and where bit 0 of the byte//! The pin(s) are specified using a bit-packed byte, where each bit that is//! configuration for those pin(s).//! hibernate wake-low inputs.  This function provides the proper//! The GPIO pins must be properly configured in order to function correctly as//! Configures pin(s) for use as a hibernate wake-on-low source.//! hibernate wake-high inputs.  This function provides the proper//! Configures pin(s) for use as a hibernate wake-on-high source.// Set the pad(s) for standard push-pull operation.// Make the pin(s) be peripheral controlled.//! function call is also required to properly configure a pin for the USB//! configures a USB pin for proper operation.  Note that a GPIOPinConfigure()//! \note This function cannot be used to turn any pin into a USB pin; it only//! functionality.//! USB pins are analog in nature or are not used in devices without OTG//! This function should only be used with EPEN and PFAULT pins as all other//! upon the board setup (for example, using the on-chip pull-ups).//! the digital USB pin(s); other configurations may work as well depending//! function correctly.  This function provides a typical configuration for//! USB digital pins must be properly configured for the USB peripheral to//! Configures pin(s) for use by the USB peripheral.// Set the pad(s) for analog operation.// Make the pin(s) be inputs.//! any USB analog pin(s).//! function correctly.  This function provides the proper configuration for//! USB analog pins must be properly configured for the USB peripheral to//!  pin for the UART function.//! GPIOPinConfigure() function call is also required to properly configure a//! only configures a UART pin for proper operation.  Note that a//! \note This function cannot be used to turn any pin into a UART pin; it//! board setup (for example, using the on-chip pull-ups).//! those pin(s); other configurations may work as well depending upon the//! The UART pins must be properly configured for the UART peripheral to//! Configures pin(s) for use by the UART peripheral.//! pin for the Trace function.//! only configures a trace pin for proper operation.  Note that a//! \note This function cannot be used to turn any pin into a trace pin; it//! those pin(s).//! The Trace pins must be properly configured for the Trace peripheral to//! Configures pin(s) for use by the Trace peripheral.//! pin for the CCP function.//! only configures a timer pin for proper operation.  Note that a//! \note This function cannot be used to turn any pin into a timer pin; it//! The CCP pins must be properly configured for the timer peripheral to//! Configures pin(s) for use by the Timer peripheral.//! function call is also required to properly configure a pin for the SSI//! configures a SSI pin for proper operation.  Note that a GPIOPinConfigure()//! \note This function cannot be used to turn any pin into a SSI pin; it only//! setup (for example, using the on-chip pull-ups).//! pin(s); other configurations may work as well depending upon the board//! correctly.  This function provides a typical configuration for those//! The SSI pins must be properly configured for the SSI peripheral to function//! Configures pin(s) for use by the SSI peripheral.// Set the pad(s) for standard push-pull operation with a weak pull-up.//! function call is also required to properly configure a pin for the QEI//! configures a QEI pin for proper operation.  Note that a GPIOPinConfigure()//! \note This function cannot be used to turn any pin into a QEI pin; it only//! setup (for example, not using the on-chip pull-ups).//! The QEI pins must be properly configured for the QEI peripheral to function//! Configures pin(s) for use by the QEI peripheral.//! function call is also required to properly configure a pin for the PWM//! configures a PWM pin for proper operation.  Note that a GPIOPinConfigure()//! \note This function cannot be used to turn any pin into a PWM pin; it only//! The PWM pins must be properly configured for the PWM peripheral to function//! Configures pin(s) for use by the PWM peripheral.//! pin for the 1-Wire function.//! only configures a 1-Wire pin for proper operation.  Note that a//! \note This function cannot be used to turn any pin into a 1-Wire pin; it//! The 1-Wire pin must be properly configured for the 1-Wire peripheral to//! Configures pin(s) for use by the 1-Wire module.// Set the pad(s) for standard push-pull operation and beefed up drive.//! controller function.//! function call is also required to properly configure a pin for the LCD//! configures an LCD pin for proper operation.  Note that a GPIOPinConfigure()//! \note This function cannot be used to turn any pin into an LCD pin; it only//! to function correctly.  This function provides a typical configuration for//! The LCD controller pins must be properly configured for the LCD controller//! Configures pin(s) for use by the LCD Controller.// Set the pad(s) for push-pull operation.//! pin for the I2C SCL function.//! only configures an I2C SCL pin for proper operation.  Note that a//! \note This function cannot be used to turn any pin into an I2C SCL pin; it//! The pin is specified using a bit-packed byte, where each bit that is//! pin.//! correctly.  This function provides the proper configuration for the SCL//! The I2C pins must be properly configured for the I2C peripheral to function//! \param ui8Pins is the bit-packed representation of the pin.//! Configures pin for use as SCL by the I2C peripheral.// Set the pad(s) for open-drain operation with a weak pull-up.//! pin for the I2C SDA function.//! only configures an I2C SDA pin for proper operation.  Note that a//! \note This function cannot be used to turn any pin into an I2C SDA pin; it//! correctly.  This function provides the proper configuration for the SDA//! Configures pin for use as SDA by the I2C peripheral.//! RTC Clock to be output from the device.//! function correctly. This function provides the proper configuration for the//! The hibernate output pin must be properly configured for the RTCCLK to//! Configures pin(s) for use as an Hibernate RTC Clock.// Make the pin(s) be outputs.//! pin(s).//! GPIO outputs.  This function provides the proper configuration for those//! Configures pin(s) for use as GPIO open drain outputs.//! Configures pin(s) for use as GPIO outputs.//! GPIO inputs.  This function provides the proper configuration for those//! Configures pin(s) for use as GPIO inputs.//! configure the pin for the Ethernet MII function.//! that a GPIOPinConfigure() function call is also required to properly//! pin; it only configures an Ethernet MII pin for proper operation.  Note//! \note This function cannot be used to turn any pin into an Ethernet MII//! configuration for the pins.//! are used to connect to an external PHY.  This function provides a typical//! The Ethernet peripheral on some parts provides a set of MII signals that//! Configures pin(s) for use by the Ethernet peripheral as MII signals.//! configure the pin for the Ethernet LED function.//! pin; it only configures an Ethernet LED pin for proper operation.  Note//! \note This function cannot be used to turn any pin into an Ethernet LED//! typical configuration for the pins.//! an LED (for example, for link status/activity).  This function provides a//! The Ethernet peripheral provides four signals that can be used to drive//! Configures pin(s) for use by the Ethernet peripheral as LED signals.//! external peripheral interface function.//! function call is also required to properly configure a pin for the//! interface pin for proper operation.  Note that a GPIOPinConfigure()//! peripheral interface pin; it only configures an external peripheral//! \note This function cannot be used to turn any pin into an external//! pull-ups).//! work as well depending upon the board setup (for example, using the on-chip//! provides a typical configuration for those pin(s); other configurations may//! external peripheral interface to function correctly.  This function//! The external peripheral interface pins must be properly configured for the//! Configures pin(s) for use by the external peripheral interface.//! function correctly. This function provides the proper configuration for//! The system control output pin must be properly configured for the DIVSCLK to//! Configures pin(s) for use as an clock to be output from the device.//! comparator to function correctly.  This function provides the proper//! The analog comparator output pins must be properly configured for the analog//! Configures pin(s) for use as an analog comparator output.//! to properly configure a pin for the analog comparator function.//! operation.  Note that a GPIOPinConfigure() function call is also required//! comparator input; it only configures an analog comparator pin for proper//! \note This function cannot be used to turn any pin into an analog//! The analog comparator input pins must be properly configured for the analog//! Configures pin(s) for use as an analog comparator input.//!  function.//! function call is also required to properly configure a pin for the CAN//! configures a CAN pin for proper operation.  Note that a GPIOPinConfigure()//! \note This function cannot be used to turn any pin into a CAN pin; it only//! The CAN pins must be properly configured for the CAN peripherals to//! Configures pin(s) for use as a CAN device.//! only configures an ADC input pin for proper operation.//! \note This function cannot be used to turn any pin into an ADC input; it//! provides the proper configuration for those pin(s).//! the analog-to-digital peripheral to function correctly.  This function//! The analog-to-digital converter input pins must be properly configured for//! Configures pin(s) for use as analog-to-digital converter inputs.// Write the pins.//! \e ui8Pins.  Writing to a pin configured as an input pin has no effect.//! Writes the corresponding bit values to the output pin(s) specified by//! \param ui8Val is the value to write to the pin(s).//! Writes a value to the specified pin(s).// Return the pin value(s).//! is returned as a 0.  Bits 31:8 should be ignored.//! GPIO port pin 1, and so on.  Any bit that is not specified by \e ui8Pins//! pin, where bit 0 of the byte represents GPIO port pin 0, bit 1 represents//! \return Returns a bit-packed byte providing the state of the specified//! for pin(s) that are not specified by \e ui8Pins are set to 0.//! Values are returned for both input and output pin(s), and the value//! The values at the specified pin(s) are read, as specified by \e ui8Pins.//! Reads the values present of the specified pin(s).// UnRegister the interrupt handler.// Disable the GPIO pin interrupt.// Get the interrupt number associated with the specified GPIO.//! interrupt in the interrupt controller.//! GPIO port.  This function also disables the corresponding GPIO pin//! This function unregisters the interrupt handler for the specified pin of a//! \param ui32Pin is the pin whose interrupt is to be unregistered.//! Removes an interrupt handler for an individual pin of a GPIO port.// Enable the GPIO pin interrupt.//! pin of a GPIO port.  This function also enables the corresponding GPIO pin//! \e pfnIntHandler is called when an interrupt is detected from the selected//! This function ensures that the interrupt handler specified by//! \param pfnIntHandler is a pointer to the GPIO port interrupt handling//! \param ui32Pin is the pin whose interrupt is to be registered.//! Registers an interrupt handler for an individual pin of a GPIO port.// Disable the GPIO interrupt.//! and interrupt sources must be disabled with GPIOIntDisable().//! GPIO port interrupt in the interrupt controller; individual GPIO interrupts//! GPIO port.  This function also disables the corresponding//! This function unregisters the interrupt handler for the specified//! Removes an interrupt handler for a GPIO port.// Enable the GPIO interrupt.//! sources must be enabled with GPIOIntEnable().//! in the interrupt controller; individual pin interrupts and interrupt//! GPIO port.  This function also enables the corresponding GPIO interrupt//! Registers an interrupt handler for a GPIO port.// Clear the interrupts.//! The \e ui32IntFlags parameter is the logical OR of the \b GPIO_INT_*//! Clears the specified interrupt sources.// Return the interrupt status.//! The value returned is the logical OR of the \b GPIO_INT_* values that are//! \return Returns the current interrupt status for the specified GPIO module.//! Gets interrupt status for the specified GPIO port.// Disable the interrupts.//! - \b GPIO_INT_DMA - interrupt due to DMA activity on this GPIO module.//! - \b GPIO_INT_PIN_7 - interrupt due to activity on Pin 7.//! - \b GPIO_INT_PIN_6 - interrupt due to activity on Pin 6.//! - \b GPIO_INT_PIN_5 - interrupt due to activity on Pin 5.//! - \b GPIO_INT_PIN_4 - interrupt due to activity on Pin 4.//! - \b GPIO_INT_PIN_3 - interrupt due to activity on Pin 3.//! - \b GPIO_INT_PIN_2 - interrupt due to activity on Pin 2.//! - \b GPIO_INT_PIN_1 - interrupt due to activity on Pin 1.//! - \b GPIO_INT_PIN_0 - interrupt due to activity on Pin 0.//! This function disables the indicated GPIO interrupt sources.  Only the//! Disables the specified GPIO interrupts.// Enable the interrupts.//! interrupts that are left enabled also trigger the individual interrupts.//! to handle the interrupt.  If this is not done then any individual GPIO pin//! the ports are routed to the INT_GPIOP0 or INT_GPIOQ0 which must be enabled//! in the NVIC using the IntDisable() function.  The summary interrupts for//! using GPIOIntEnable() and all but the interrupt for pin 0 must be disabled//! individual interrupts for these ports must be enabled in the GPIO module//! P or Q (GPIOIntTypeSet() with GPIO_DISCRETE_INT not enabled), then all//! \note If this call is being used to enable summary interrupts on GPIO port//! This function enables the indicated GPIO interrupt sources.  Only the//! \param ui32IntFlags is the bit mask of the interrupt sources to enable.//! Enables the specified GPIO interrupts.// Get the pin type.// Get the drive strength for this pin.// Convert from a pin number to a bit position.//! pull-up or down resistor.//! only meaningful data returned is whether the pin is terminated with a//! function also works for pin(s) configured as input pin(s); however, the//! \e pui32PinType correspond to the values used in GPIOPadConfigSet().  This//! selected GPIO port.  The values returned in \e pui32Strength and//! This function gets the pad configuration for a specified pin on the//! \param pui32PinType is a pointer to storage for the output drive type.//! \param pui32Strength is a pointer to storage for the output drive strength.//! \param ui8Pin is the pin number.//! Gets the pad configuration for a pin.// Set the analog mode select register.// harmless writes on older devices.// registers only appear in TM4C129x and later device classes, but are// Set the wake pin enable register and the wake level register.  These// Set the pin type.// devices.// TM4C129x and later device classes, but is a harmless write on older// Set the 12-mA drive select register.  This register only appears in// Set the output drive strength.// write on older devices.// This register only appears in TM4C129x devices, but is a harmless// Set the GPIO peripheral configuration register first as required.//! settings are only available on some Tiva devices.//! hibernation wake source.  The pin sense level can be high or low.  These//! The \b GPIO_PIN_TYPE_WAKE_* settings specify the pin to be used as a//! input.//! specifies a weak pull-down, and \b GPIO_PIN_TYPE_ANALOG specifies an analog//! specifies an open-drain pin, \b *_WPU specifies a weak pull-up, \b *_WPD//! where \b GPIO_PIN_TYPE_STD* specifies a push-pull pin, \b GPIO_PIN_TYPE_OD*//! - \b GPIO_PIN_TYPE_WAKE_LOW//! - \b GPIO_PIN_TYPE_WAKE_HIGH//! - \b GPIO_PIN_TYPE_ANALOG//! - \b GPIO_PIN_TYPE_OD//! - \b GPIO_PIN_TYPE_STD_WPD//! - \b GPIO_PIN_TYPE_STD_WPU//! - \b GPIO_PIN_TYPE_STD//! The parameter \e ui32PinType can be one of the following values://! mA.//! Some Tiva devices also support output drive strengths of 6, 10, and 12//! slew control.//! strength, and \b GPIO_OUT_STRENGTH_8MA_SC specifies 8 mA output drive with//! where \b GPIO_STRENGTH_xMA specifies either 2, 4, or 8 mA output drive//! - \b GPIO_STRENGTH_12MA//! - \b GPIO_STRENGTH_10MA//! - \b GPIO_STRENGTH_6MA//! - \b GPIO_STRENGTH_8MA_SC//! - \b GPIO_STRENGTH_8MA//! - \b GPIO_STRENGTH_4MA//! - \b GPIO_STRENGTH_2MA//! The parameter \e ui32Strength can be one of the following values://! is the configuration of the pull-up or pull-down termination.//! pad is configured as requested, but the only real effect on the input//! on the selected GPIO port.  For pin(s) configured as input ports, the//! This function sets the drive strength and type for the specified pin(s)//! \param ui32PinType specifies the pin type.//! \param ui32Strength specifies the output drive strength.//! Sets the pad configuration for the specified pin(s).// Return the pin interrupt type.//! \return Returns one of the flags described for GPIOIntTypeSet().//! is returned and can include the \b GPIO_DISCRETE_INT flag.//! high-level detected interrupt.  The type of interrupt detection mechanism//! both-edges detected interrupt, or it can be configured as a low-level or//! GPIO port.  The pin can be configured as a falling-edge, rising-edge, or//! This function gets the interrupt type for a specified pin on the selected//! Gets the interrupt type for a pin.// on all parts or ports but is safe to write in all cases.// Set or clear the discrete interrupt feature.  This is not available// Set the pin interrupt type.//! the GPIO inputs remain stable for the duration of this function.//! \note In order to avoid any spurious interrupts, the user must ensure that//! discrete interrupts.//! consult the data sheet to ensure that the device and the GPIO port supports//! The \b GPIO_DISCRETE_INT is not available on all devices or all GPIO ports,//! port.//! - \b GPIO_DISCRETE_INT sets discrete interrupts for each pin on a GPIO//! \e ui32IntType parameter://! In addition to the above flags, the following flag can be OR'd in to the//! - \b GPIO_HIGH_LEVEL sets detection to high level//! - \b GPIO_LOW_LEVEL sets detection to low level//! - \b GPIO_BOTH_EDGES sets detection to both edges//! - \b GPIO_RISING_EDGE sets detection to edge and trigger to rising//! - \b GPIO_FALLING_EDGE sets detection to edge and trigger to falling//! parameter://! One of the following flags can be used to define the \e ui32IntType//! specified pin(s) on the selected GPIO port.//! This function sets up the various interrupt trigger mechanisms for the//! \param ui32IntType specifies the type of interrupt trigger mechanism.//! Sets the interrupt type for the specified pin(s).// Return the pin direction and mode.//! GPIODirModeSet().//! \return Returns one of the enumerated data types described for//! type of control and direction are returned as an enumerated data type.//! output under software control, or it can be under hardware control.  The//! the selected GPIO port.  The pin can be configured as either an input or//! This function gets the direction and control mode for a specified pin on//! Gets the direction and mode of a pin.// Set the pin direction and mode.//! pad(s) in order for them to propagate the signal to/from the GPIO.//! \note GPIOPadConfigSet() must also be used to configure the corresponding//! specifies that the pin is placed under hardware control.//! programmed as a software controlled output, and \b GPIO_DIR_MODE_HW//! software controlled input, \b GPIO_DIR_MODE_OUT specifies that the pin is//! where \b GPIO_DIR_MODE_IN specifies that the pin is programmed as a//! - \b GPIO_DIR_MODE_HW//! - \b GPIO_DIR_MODE_OUT//! - \b GPIO_DIR_MODE_IN//! The parameter \e ui32PinIO is an enumerated data type that can be one of//! pin to be under hardware control.//! as either input or output under software control, or it configures the//! This function configures the specified pin(s) on the selected GPIO port//! \param ui32PinIO is the pin direction and/or mode.//! \param ui32Port is the base address of the GPIO port//! Sets the direction and mode of the specified pin(s).// The base address could not be found, so return an error.// Return the corresponding interrupt number.// See if this base address matches.// numbers.// Loop through the table that maps I2C base addresses to interrupt//! \return Returns a GPIO interrupt number, or 0 if \e ui32Port is invalid.//! interrupt number.//! Given a GPIO base address, this function returns the corresponding//! Gets the GPIO interrupt number.//! This function determines if a GPIO port base address is valid.//! Checks a GPIO base address.// are provided.// The base addresses of all the GPIO modules.  Both the APB and AHB apertures// A mapping of GPIO port address to interrupt number.//! \addtogroup gpio_api// gpio.c - API for GPIO ports/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/sys/_types.h<stddef.h><sys/lock.h><machine/_types.h><sys/config.h><newlib.h>__va_list__useconds_t__suseconds_t__nlink_t__socklen_t__sa_family_t__timer_t__clockid_t__time_t__clock_t_iconv_t_flock_t_mbstate_t__ssize_t_ssize_t__size_t_fpos_t__key_t__loff_t__off_t_off64_t__mode_t__ino_t__id_t__gid_t__uid_t__dev_t__pid_t_off_t__fsfilcnt_t__fsblkcnt_t__blksize_t__blkcnt_t__value__count__wchb__wch_TIMER_T_unsigned long_CLOCKID_T__TIME_T_long_CLOCK_T___need_wint_tunsignedsigned_SYS__TYPES_H__machine_blkcnt_t_defined__machine_blksize_t_defined__machine_fsblkcnt_t_defined__machine_fsfilcnt_t_defined__machine_off_t_defineddefined(__XMK__)__machine_dev_t_defined__machine_uid_t_defined__machine_gid_t_defined__machine_id_t_defined__machine_ino_t_defined(defined(__i386__) && (defined(GO32) || defined(__MSDOS__))) || \__machine_mode_t_defineddefined(__i386__) && (defined(GO32) || defined(__MSDOS__))defined(__sparc__) && !defined(__sparc_v9__)__svr4____machine_off64_t_defineddefined(__CYGWIN__) && !defined(__LP64__)__machine_key_t_defined__machine_fpos_t_defined__LARGE64_FILES__machine_fpos64_t_defined__machine_size_t_defined__SIZE_TYPE__defined(__INT_MAX__) && __INT_MAX__ == 2147483647__machine_ssize_t_defined__machine_mbstate_t_defined__machine_flock_t_defined__machine_iconv_t_defined__machine_sa_family_t_defined__machine_socklen_t_defined__GNUCLIKE_BUILTIN_VARARGSunsigned int/* _SYS__TYPES_H *//* __GNUCLIKE_BUILTIN_VARARGS *//* microseconds (unsigned) *//* microseconds (signed) *//* time() *//* clock() *//* Iconv descriptor type *//* Value so far.  *//* Conversion state information.  *//* If __SIZE_TYPE__ is defined (gcc) we define ssize_t based on size_t.
   We simply change "unsigned" to "signed" for this single definition
   to make sure ssize_t and size_t only differ by their signedness. *//* Defined by GCC provided <stddef.h> *//* (and must be `long' for now) *//* XXX must match off_t in <sys/types.h> *//*
 * We need fpos_t for the following, but it doesn't have a leading "_",
 * so we use _fpos_t instead.
 *//* This file defines various typedefs needed by the system calls that support
   the C library.  Basically, they're just the POSIX versions with an '_'
   prepended.  Targets shall use <machine/_types.h> to define their own
   internal types if desired.

   There are three define patterns used for type definitions.  Lets assume
   xyz_t is a user type.

   The internal type definition uses __machine_xyz_t_defined.  It is defined by
   <machine/_types.h> to disable a default definition in <sys/_types.h>. It
   must not be used in other files.

   User type definitions are guarded by __xyz_t_defined in glibc and
   _XYZ_T_DECLARED in BSD compatible systems.
*//* ANSI C namespace clean utility typedefs *//home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/sys/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/lib/gcc/arm-none-eabi/5.4.1/include/stddef.hoffsetof(TYPE,MEMBER)__builtin_offsetof (TYPE, MEMBER)__need_NULLNULL((void *)0)__need_wchar_t__need_size_t__need_ptrdiff_t(!defined(_STDDEF_H) && !defined(_STDDEF_H_) && !defined(_ANSI_STDDEF_H) \(!defined(__need_wchar_t) && !defined(__need_size_t)	\__sys_stdtypes_hdefined (__BSD_NET2__) || defined (____386BSD____) || (defined (__FreeBSD__) && (__FreeBSD__ < 5)) || defined(__NetBSD__)defined (__FreeBSD__) && (__FreeBSD__ >= 5)defined(_ANSI_H_) || defined(_MACHINE_ANSI_H_) || defined(_X86_64_ANSI_H_)  || defined(_I386_ANSI_H_)!defined(_SIZE_T_) && !defined(_BSD_SIZE_T_)!defined(_PTRDIFF_T_) && !defined(_BSD_PTRDIFF_T_)!defined(_WCHAR_T_) && !defined(_BSD_WCHAR_T_)_BSD_WCHAR_T_defined (__need_ptrdiff_t) || defined (_STDDEF_H_)defined (__need_size_t) || defined (_STDDEF_H_)defined (__need_wchar_t) || defined (_STDDEF_H_)defined (__sequent__) && defined (_PTRDIFF_T_)defined (_TYPE_ptrdiff_t) && (defined (__need_ptrdiff_t) || defined (_STDDEF_H_))defined (_TYPE_size_t) && (defined (__need_size_t) || defined (_STDDEF_H_))defined (_TYPE_wchar_t) && (defined (__need_wchar_t) || defined (_STDDEF_H_))defined (_STDDEF_H) || defined (__need_ptrdiff_t)_PTRDIFF_T_T_PTRDIFF__T_PTRDIFF__PTRDIFF_T_PTRDIFF_T__BSD_PTRDIFF_T____int_ptrdiff_t_h_GCC_PTRDIFF_T_PTRDIFF_T_DECLARED__PTRDIFF_TYPE__defined (_STDDEF_H) || defined (__need_size_t)__size_t____SIZE_T___SIZE_T_SYS_SIZE_T_H_T_SIZE__T_SIZE__SIZE_T_SIZE_T__BSD_SIZE_T__SIZE_T_DEFINED__SIZE_T_DEFINED_BSD_SIZE_T_DEFINED__SIZE_T_DECLARED___int_size_t_h_GCC_SIZE_T_SIZET_(defined (__FreeBSD__) && (__FreeBSD__ >= 5)) \defined (__VMS__)!(defined (__GNUG__) && defined (size_t))__BEOS__defined (_STDDEF_H) || defined (__need_wchar_t)__wchar_t____WCHAR_T___WCHAR_T_T_WCHAR__T_WCHAR__WCHAR_T_WCHAR_T__BSD_WCHAR_T_DEFINED__BSD_RUNE_T_DEFINED__WCHAR_T_DECLARED_WCHAR_T_DEFINED__WCHAR_T_DEFINED_WCHAR_T_H___int_wchar_t_h__INT_WCHAR_T_H_GCC_WCHAR_T_BSD_RUNE_T_!defined (_ANSI_SOURCE) && !defined (_POSIX_SOURCE)defined (__FreeBSD__) && (__FreeBSD__ < 5)__BSD_VISIBLE_RUNE_T_DECLARED__WCHAR_TYPE__defined (__need_wint_t)_WINT_T__WINT_TYPE__defined(_ANSI_H_) || defined(_MACHINE_ANSI_H_) || defined(_X86_64_ANSI_H_) || defined(_I386_ANSI_H_)_GCC_PTRDIFF_T__GCC_SIZE_T__GCC_WCHAR_T_defined (_STDDEF_H) || defined (__need_NULL)__GNUG___STDDEF_H(defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L) \_GCC_MAX_ALIGN_Tdefined(__cplusplus) && __cplusplus >= 201103L_GXX_NULLPTR_T__STDC_VERSION__199901L/* !_STDDEF_H && !_STDDEF_H_ && !_ANSI_STDDEF_H && !__STDDEF_H__
	  || __need_XXX was not defined before *//* _STDDEF_H was defined this time *//* C++11.  *//* C11 or C++11.  *//* Type whose alignment is supported in every context and is at least
   as great as that of any standard type not using alignment
   specifiers.  *//* Offset of member MEMBER in a struct of type TYPE. *//* NULL not defined and <stddef.h> or need NULL.  *//* G++ *//* C++ *//* in case <stdio.h> has defined it. *//* A null pointer constant.  *//* __sys_stdtypes_h *//* _ANSI_H_ || _MACHINE_ANSI_H_ || _X86_64_ANSI_H_ || _I386_ANSI_H_ *//*  The following ones are the real ones.  *//*  The references to _GCC_PTRDIFF_T_, _GCC_SIZE_T_, and _GCC_WCHAR_T_
    are probably typos and should be removed before 2.8 is released.  *//*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  *//*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  *//*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  *//* _STDDEF_H or __need_wchar_t.  *//* __wchar_t__ *//* __WCHAR_T__ *//* _BSD_RUNE_T_DEFINED_ *//* _WCHAR_T_DECLARED *//* FreeBSD 5 can't be handled well using "traditional" logic above
   since it no longer defines _BSD_RUNE_T_ yet still desires to export
   rune_t in some cases... *//* Why is this file so hard to maintain properly?  In contrast to
   the comment above regarding BSD/386 1.1, on FreeBSD for as long
   as the symbol has existed, _BSD_RUNE_T_ must not stay defined or
   redundant typedefs will occur when stdlib.h is included after this file. *//* Darwin *//* On BSD/386 1.1, at least, machine/ansi.h defines _BSD_WCHAR_T_
   instead of _WCHAR_T_, and _BSD_RUNE_T_ (which, unlike the other
   symbols in the _FOO_T_ family, stays defined even after its
   corresponding type is defined).  If we define wchar_t, then we
   must undef _WCHAR_T_; for BSD/386 1.1 (and perhaps others), if
   we undef _WCHAR_T_, then we must also define rune_t, since 
   headers like runetype.h assume that if machine/ansi.h is included,
   and _BSD_WCHAR_T_ is not defined, then rune_t is available.
   machine/ansi.h says, "Note that _WCHAR_T_ and _RUNE_T_ must be of
   the same type." *//* Cray Unicos/Mk *//* BeOS *//* FreeBSD 5 *//* Define this type if we are doing the whole job,
   or if we want this type in particular.  *//* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  *//* _STDDEF_H or __need_size_t.  *//* __size_t__ *//* __SIZE_T__ *//* _SIZE_T *//* _SYS_SIZE_T_H *//* _T_SIZE_ *//* _T_SIZE *//* __SIZE_T *//* _SIZE_T_ *//* _BSD_SIZE_T_ *//* _SIZE_T_DEFINED_ *//* _SIZE_T_DEFINED *//* _BSD_SIZE_T_DEFINED_ *//* _SIZE_T_DECLARED *//* ___int_size_t_h *//* _GCC_SIZE_T *//* _SIZET_ *//* __size_t *//* !(defined (__GNUG__) && defined (size_t)) *//* __BEOS__ *//* __size_t is also a typedef on VMS.  *//* __size_t is a typedef on FreeBSD 5, must not trash it. *//* in case <sys/types.h> has defined it. *//* Unsigned type of `sizeof' something.  *//* _STDDEF_H or __need_ptrdiff_t.  *//* If this symbol has done its job, get rid of it.  *//* _PTRDIFF_T *//* _T_PTRDIFF_ *//* _T_PTRDIFF *//* __PTRDIFF_T *//* _PTRDIFF_T_ *//* _BSD_PTRDIFF_T_ *//* ___int_ptrdiff_t_h *//* _GCC_PTRDIFF_T *//* _PTRDIFF_T_DECLARED *//* DragonFly *//* Signed type of difference of two pointers.  *//* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  *//* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  *//* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  *//* defined(_ANSI_H_) || defined(_MACHINE_ANSI_H_) || defined(_X86_64_ANSI_H_) || defined(_I386_ANSI_H_) *//* Undef _FOO_T_ if we are supposed to define foo_t.  *//* On BSD/386 1.1, at least, machine/ansi.h defines _BSD_WCHAR_T_
   instead of _WCHAR_T_. *//* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ *//* On FreeBSD 5, machine/ansi.h does not exist anymore... *//* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  *//* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  *//* snaroff@next.com says the NeXT needs this.  *//* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  *//*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 *//* Copyright (C) 1989-2015 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  *//home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/lib/gcc/arm-none-eabi/5.4.1/include/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/lib/gcc/arm-none-eabi/5.4.1/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/lib/gcc/arm-none-eabi/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/lib/gcc/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/lib/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/machine/time.h_CLOCKS_PER_SEC__MACHTIME_H_defined(__rtems__) || defined(__VISIUM__)defined(__aarch64__) || defined(__arm__) || defined(__thumb__)__SPU____thumb____arm__/* _MACHTIME_H_ *//home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/machine/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/machine/types.h_SYS_TYPES_H/* !_SYS_TYPES_H *//*
 * Newlib targets may provide an own version of this file in their machine
 * directory to add custom user types for <sys/types.h>.
 *//home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/sys/types.h<machine/types.h><sys/features.h><sys/_stdint.h><sys/_types.h><sys/cdefs.h><_ansi.h>sbintime_tsuseconds_tuseconds_ttimer_tclockid_tnlink_tmode_tssize_tkey_tpid_tgid_tuid_tdev_toff_tino_tid_tfsfilcnt_tfsblkcnt_tcaddr_tdaddr_ttime_tclock_tblksize_tblkcnt_tregister_tu_int64_tu_int32_tu_int16_tu_int8_t__need_inttypes_SUSECONDS_T_DECLARED_USECONDS_T_DECLARED_TIMER_T_DECLARED__timer_t_defined_CLOCKID_T_DECLARED__clockid_t_defined_NLINK_T_DECLARED_MODE_T_DECLARED_SSIZE_T_DECLARED_KEY_T_DECLARED_PID_T_DECLARED_GID_T_DECLARED_UID_T_DECLARED_DEV_T_DECLARED_OFF_T_DECLARED_INO_T_DECLARED_ID_T_DECLARED_FSBLKCNT_T_DECLARED__caddr_t_defined__daddr_t_defined_TIME_T_DECLARED__time_t_defined_CLOCK_T_DECLARED__clock_t_defined_BLKSIZE_T_DECLARED_BLKCNT_T_DECLARED__BIT_TYPES_DEFINED_____int8_t_defined___int16_t_defined___int32_t_defined___int64_t_defineddefined(__rtems__) || defined(__XMK__)_IN_ADDR_T_DECLARED_IN_PORT_T_DECLARED__MISC_VISIBLE_BSDTYPES_DEFINED__u_char_defined__u_short_defined__u_int_defined__u_long_defined!defined(__clock_t_defined) && !defined(_CLOCK_T_DECLARED)!defined(__time_t_defined) && !defined(_TIME_T_DECLARED)!defined(__clockid_t_defined) && !defined(_CLOCKID_T_DECLARED)!defined(__timer_t_defined) && !defined(_TIMER_T_DECLARED)!defined(__CYGWIN__)defined(_POSIX_THREADS)defined(__rtems__)defined(_POSIX_THREAD_CPUTIME)defined(_POSIX_THREAD_PROCESS_SHARED)defined(_POSIX_THREAD_PRIO_PROTECT)defined(_UNIX98_THREAD_MUTEX_ATTRIBUTES)defined(_POSIX_BARRIERS)defined(_POSIX_SPIN_LOCKS)defined(_POSIX_READER_WRITER_LOCKS)/* _SYS_TYPES_H *//* !__need_inttypes *//* __CYGWIN__ *//* defined(_POSIX_READER_WRITER_LOCKS) *//* allow this to be shared amongst processes *//* is this structure initialized? *//* POSIX RWLock Object *//* POSIX Reader/Writer Lock Types *//* defined(_POSIX_SPIN_LOCKS) *//* POSIX Spin Lock Object *//* POSIX Spin Lock Types *//* defined(_POSIX_BARRIERS) *//* POSIX Barrier Object *//* POSIX Barrier Types *//* defined(_POSIX_THREADS) *//* dynamic package initialization *//* has the initialization routine been run? *//* thread-specific data keys *//* Keys *//* a condition attribute object *//* specifiy clock for timeouts *//* identify a condition variable *//* Condition Variables *//* !defined(__XMK__) *//* allow mutex to be shared amongst processes *//* identify a mutex *//* !defined(_UNIX98_THREAD_MUTEX_ATTRIBUTES) *//*
 * Attempting to recursively lock a mutex of this type results
 * in undefined behavior. Attempting to unlock a mutex of this type
 * which was not locked by the calling thread results in undefined
 * behavior. Attempting to unlock a mutex of this type which is not locked
 * results in undefined behavior. An implementation may map this mutex to
 * one of the other mutex types.
 *//* 
 * This type of mutex provides error checking. A thread attempting
 * to relock this mutex without first unlocking it shall return with an
 * error. A thread attempting to unlock a mutex which another thread has
 * locked shall return with an error. A thread attempting to unlock an
 * unlocked mutex shall return with an error.
 *//*
 * A thread attempting to relock this mutex without first unlocking
 * it shall succeed in locking the mutex.  The relocking deadlock which
 * can occur with mutexes of type PTHREAD_MUTEX_NORMAL cannot occur with
 * this type of mutex.  Multiple locks of this mutex shall require the
 * same number of unlocks to release the mutex before another thread can
 * acquire the mutex. A thread attempting to unlock a mutex which another
 * thread has locked shall return with an error.  A thread attempting to
 * unlock an unlocked mutex shall return with an error.
 *//*
 * This type of mutex does not detect deadlock. A thread attempting to
 * relock this mutex without first unlocking it shall deadlock. Attempting
 * to unlock a mutex locked by a different thread results in undefined
 * behavior.  Attempting to unlock an unlocked mutex results in undefined
 * behavior.
 *//* The following defines are part of the X/Open System Interface (XSI). *//* Values for mutex type *//* Values for blocking protocol. *//* Mutexes *//*   located *//*   the memory where the resource is *//* visible too all processes with access to *//* visible within only the creating process *//* NOTE: P1003.1c/D10, p. 81 defines following values for process_shared.  *//* see time.h *//* P1003.4b/D8, p. 54 adds cputime_clock_allowed attribute.  *//* P1003.1c/D10, p. 141 *//* set from provided attribute object *//*   the calling thread. *//*   attributes are inherited from *//* scheduling policy and associated *//* P1003.1c/D10, p. 111 *//* P1003.1c/D10, p. 118-119 *//* identify a thread *//*
 *  2.5 Primitive System Data Types,  P1003.1c/D10, p. 19.
 *//*
 * Cygwin is using a complete distinct implementation of pthread objects and
 * pointers rather than structs.  This means we can't use the types defined
 * here, but rather in <machine/types.h>.
 *//* link count *//* permissions *//* IPC key *//* process id *//* group id *//* user id *//* device number or struct cdev *//* file offset *//*
 * All these should be machine specific - right now they are all broken.
 * However, for all of Cygnus' embedded targets, we want them to all be
 * the same.  Otherwise things like sizeof (struct stat) might depend on
 * how the file was compiled (e.g. -mint16 vs -mint32, etc.).
 *//* __i386__ && (GO32 || __MSDOS__) *//* inode number *//* can hold a uid_t or pid_t *//* for statvfs() *//* System V compatibility *//*__BSD_VISIBLE || __CYGWIN__ *//* also defined in mingw/gmon.h and in w32api/winsock[2].h *//* __BSD_VISIBLE *//* base type for internet address *//* <stddef.h> must be before <sys/_types.h> for __size_t considerations *//* __rtems__ || __XMK__ *//* deprecated *//*
 *  The following section is RTEMS specific and is needed to more
 *  closely match the types defined in the BSD sys/types.h.
 *  This is needed to let the RTEMS/BSD TCP/IP stack compile.
 *//* BSD types permitted by POSIX and always exposed as in Glibc.  Only provided
   for backward compatibility with BSD code.  The uintN_t standard types should
   be preferred in new code. *//* unified sys/types.h: 
   start with sef's sysvi386 version.
   merge go32 version -- a few ifdefs.
   h8300hms, h8300xray, and sysvnecv70 disagree on the following types:

   typedef int gid_t;
   typedef int uid_t;
   typedef int dev_t;
   typedef int ino_t;
   typedef int mode_t;
   typedef int caddr_t;

   however, these aren't "reasonable" values, the sysvi386 ones make far 
   more sense, and should work sufficiently well (in particular, h8300 
   doesn't have a stat, and the necv70 doesn't matter.) -- eichin
 *//home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/sys/_timespec.htimespectv_nsectv_sec_SYS__TIMESPEC_H_/* !_SYS__TIMESPEC_H_ *//* and nanoseconds *//* seconds *//*-
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)time.h	8.5 (Berkeley) 5/4/95
 * from: FreeBSD: src/sys/sys/time.h,v 1.43 2000/03/20 14:09:05 phk Exp
 *	$FreeBSD$
 *//home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/sys/timespec.h<sys/_timespec.h>itimerspecit_valueit_interval_SYS_TIMESPEC_H_/* _SYS_TIMESPEC_H_ *//*
 * Structure defined by POSIX.1b to be like a itimerval, but with
 * timespecs. Used in the timer_*() system calls.
 *//home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/time.h<sys/timespec.h><sys/types.h><machine/time.h><sys/reent.h>"_ansi.h"__tzinfo_type *__tzinfo_struct *__gettzinfo_tzset_r_reent *tm *localtime_rconst time_tconst time_t *long *const time_t *__restrict__tm *__restrict__gmtime_rctime_rasctime_rconst tmconst tm *const tm *__restrict__char *__restrict__strftimeconst charconst char *const char *__restrict__localtimegmtimectimeasctimetimetime_t *mktimedifftimeclock__tzinfo_type__tzinfo_struct__tzrule_type__tzrule_structtm__tzrule_type[2]__tzrule_struct[2]__tzrule__tzyear__tznorthoffsetchangesdnmchtm_isdsttm_ydaytm_wdaytm_yeartm_montm_mdaytm_hourtm_mintm_secTIMER_ABSTIMECLOCK_REALTIME(clockid_t)1CLOCK_DISALLOWEDCLOCK_ALLOWEDCLOCK_DISABLEDCLOCK_ENABLEDCLK_TCKCLOCKS_PER_SEC_TIME_H___POSIX_VISIBLE >= 200809__TM_GMTOFF__TM_ZONE_REENT_ONLY__XSI_VISIBLE__GNU_VISIBLE__POSIX_VISIBLEHAVE_GETDATE__XSI_VISIBLE >= 4__SVID_VISIBLE || __XSI_VISIBLEtzname__CYGWIN__defined(_POSIX_TIMERS)defined(_POSIX_CLOCK_SELECTION)defined(_POSIX_CPUTIME)defined(_POSIX_MONOTONIC_CLOCK)defined(_POSIX_CPUTIME) || defined(_POSIX_THREAD_CPUTIME)(_VOID)(void)(struct _reent *)(const time_t *__restrict, struct tm *__restrict)(const time_t *restrict, struct tm *restrict)(const time_t *, char *)(const struct tm *__restrict, char *__restrict)(const struct tm *restrict, char *restrict)(char *__restrict _s, size_t _maxsize, const char *__restrict _fmt, const struct tm *__restrict _t)(char *restrict _s, size_t _maxsize, const char *restrict _fmt, const struct tm *restrict _t)(const time_t *_timer)(const time_t *_time)(const struct tm *_tblock)(time_t *_timer)(struct tm *_timeptr)(time_t _time2, time_t _time1)/* _TIME_H_ *//* _POSIX_CPUTIME or _POSIX_THREAD_CPUTIME *//* CPU-time Clock Attribute Access, P1003.4b/D8, p. 56 *//* _POSIX_CPUTIME *//* Accessing a Process CPU-time CLock, P1003.4b/D8, p. 55 *//*  The identifier for the system-wide monotonic clock, which is defined
 *      as a clock whose value cannot be set via clock_settime() and which 
 *          cannot have backward clock jumps. *//*  When used in a clock or timer function call, this is interpreted as
    the identifier of the CPU_time clock associated with the THREAD
    making the function call.  *//* When used in a clock or timer function call, this is interpreted as
   the identifier of the CPU_time clock associated with the PROCESS
   making the function call.  *//* Manifest Constants, P1003.4b/D8, p. 55 *//* Flag indicating time is "absolute" with respect to the clock
   associated with a time.  *//* Manifest Constants, P1003.1b-1993, p. 262 *//*   accessible. *//*   thread shall not have a CPU-time clock *//* If a thread is created with this value, the *//*   shall be accessible. *//*   CPU-time clock attached to that thread *//* If a thread is created with this value a *//* values for the pthread cputime_clock_allowed attribute *//* clock is disabled *//* clock is enabled, i.e. counting execution time *//* values for the clock enable attribute *//* CPU-time Clock Attributes, P1003.4b/D8, p. 54 *//* _POSIX_CLOCK_SELECTION *//* _POSIX_TIMERS *//* High Resolution Sleep, P1003.1b-1993, p. 269 *//* Per-Process Timers, P1003.1b-1993, p. 267 *//* Delete a Per_process Timer, P1003.1b-1993, p. 266 *//* Create a Per-Process Timer, P1003.1b-1993, p. 264 *//* Clocks, P1003.1b-1993, p. 263 *//*__CYGWIN__*//* __POSIX_VISIBLE *//* POSIX defines the external tzname being defined in time.h *//* defines for the opengroup specifications Derived from Issue 1 of the SVID.  *//* HAVE_GETDATE *//* __GNU_VISIBLE *//* getdate_r returns the error code as above *//* __XSI_VISIBLE >= 4 *//* !_REENT_ONLY *//* getdate_err is set to one of the following values to indicate the error.
     1  the DATEMSK environment variable is null or undefined,
     2  the template file cannot be opened for reading,
     3  failed to get file status information,
     4  the template file is not a regular file,
     5  an error is encountered while reading the template file,
     6  memory allication failed (not enough memory available),
     7  there is no line in the template that matches the input,
     8  invalid input specification  *//* getdate functions *//* Match type of _timezone. *//* Get _CLOCKS_PER_SEC_ *//*
 * time.h
 * 
 * Struct and function declarations for dealing with time.
 */_s_maxsize_fmt_t_timer_time_tblock_timeptr_time2_time1/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/inc/hw_hibernate.hHIB_CC_SYSCLKENHIB_PP_WAKENCHIB_PP_TAMPERHIB_TPLOG7_TRIG0HIB_TPLOG7_TRIG1HIB_TPLOG7_TRIG2HIB_TPLOG7_TRIG3HIB_TPLOG7_XOSCHIB_TPLOG6_TIME_SHIB_TPLOG6_TIME_MHIB_TPLOG5_TRIG0HIB_TPLOG5_TRIG1HIB_TPLOG5_TRIG2HIB_TPLOG5_TRIG3HIB_TPLOG5_XOSCHIB_TPLOG4_TIME_SHIB_TPLOG4_TIME_MHIB_TPLOG3_TRIG0HIB_TPLOG3_TRIG1HIB_TPLOG3_TRIG2HIB_TPLOG3_TRIG3HIB_TPLOG3_XOSCHIB_TPLOG2_TIME_SHIB_TPLOG2_TIME_MHIB_TPLOG1_TRIG0HIB_TPLOG1_TRIG1HIB_TPLOG1_TRIG2HIB_TPLOG1_TRIG3HIB_TPLOG1_XOSCHIB_TPLOG0_TIME_SHIB_TPLOG0_TIME_MHIB_TPIO_EN0HIB_TPIO_LEV0HIB_TPIO_PUEN0HIB_TPIO_GFLTR0HIB_TPIO_EN1HIB_TPIO_LEV1HIB_TPIO_PUEN1HIB_TPIO_GFLTR1HIB_TPIO_EN2HIB_TPIO_LEV2HIB_TPIO_PUEN2HIB_TPIO_GFLTR2HIB_TPIO_EN3HIB_TPIO_LEV3HIB_TPIO_PUEN3HIB_TPIO_GFLTR3HIB_TPSTAT_XOSCFAILHIB_TPSTAT_XOSCSTHIB_TPSTAT_STATE_ERRORHIB_TPSTAT_STATE_CONFIGEDHIB_TPSTAT_STATE_DISABLEDHIB_TPSTAT_STATE_MHIB_TPCTL_TPENHIB_TPCTL_TPCLRHIB_TPCTL_MEMCLR_ALLHIB_TPCTL_MEMCLR_HIGH32HIB_TPCTL_MEMCLR_LOW32HIB_TPCTL_MEMCLR_NONEHIB_TPCTL_MEMCLR_MHIB_TPCTL_WAKEHIB_LOCK_HIBLOCK_SHIB_LOCK_HIBLOCK_KEY0xA3359554HIB_LOCK_HIBLOCK_MHIB_CALM1_DOM_SHIB_CALM1_DOM_MHIB_CALM0_SEC_SHIB_CALM0_MIN_SHIB_CALM0_HR_SHIB_CALM0_SEC_MHIB_CALM0_MIN_MHIB_CALM0_HR_MHIB_CALM0_AMPMHIB_CALLD1_DOM_SHIB_CALLD1_MON_SHIB_CALLD1_YEAR_SHIB_CALLD1_DOW_SHIB_CALLD1_DOM_MHIB_CALLD1_MON_MHIB_CALLD1_YEAR_MHIB_CALLD1_DOW_MHIB_CALLD0_SEC_SHIB_CALLD0_MIN_SHIB_CALLD0_HR_SHIB_CALLD0_SEC_MHIB_CALLD0_MIN_MHIB_CALLD0_HR_MHIB_CALLD0_AMPMHIB_CAL1_DOM_SHIB_CAL1_MON_SHIB_CAL1_YEAR_SHIB_CAL1_DOW_SHIB_CAL1_DOM_MHIB_CAL1_MON_MHIB_CAL1_YEAR_MHIB_CAL1_DOW_MHIB_CAL1_VALIDHIB_CAL0_SEC_SHIB_CAL0_MIN_SHIB_CAL0_HR_SHIB_CAL0_SEC_MHIB_CAL0_MIN_MHIB_CAL0_HR_MHIB_CAL0_AMPMHIB_CAL0_VALIDHIB_CALCTL_CALENHIB_CALCTL_CAL24HIB_DATA_RTD_SHIB_DATA_RTD_MHIB_IO_WUUNLKHIB_IO_WURSTENHIB_IO_IOWRCHIB_RTCSS_RTCSSC_SHIB_RTCSS_RTCSSM_SHIB_RTCSS_RTCSSC_M0x00007FFFHIB_RTCSS_RTCSSM_M0x7FFF0000HIB_RTCT_TRIM_SHIB_RTCT_TRIM_MHIB_IC_RTCALT0HIB_IC_LOWBATHIB_IC_EXTWHIB_IC_WCHIB_IC_PADIOWKHIB_IC_RSTWKHIB_IC_VDDFAILHIB_MIS_RTCALT0HIB_MIS_LOWBATHIB_MIS_EXTWHIB_MIS_WCHIB_MIS_PADIOWKHIB_MIS_RSTWKHIB_MIS_VDDFAILHIB_RIS_RTCALT0HIB_RIS_LOWBATHIB_RIS_EXTWHIB_RIS_WCHIB_RIS_PADIOWKHIB_RIS_RSTWKHIB_RIS_VDDFAILHIB_IM_RTCALT0HIB_IM_LOWBATHIB_IM_EXTWHIB_IM_WCHIB_IM_PADIOWKHIB_IM_RSTWKHIB_IM_VDDFAILHIB_CTL_RTCENHIB_CTL_HIBREQHIB_CTL_RTCWENHIB_CTL_PINWENHIB_CTL_CLK32ENHIB_CTL_VABORTHIB_CTL_VDD3ONHIB_CTL_BATWKENHIB_CTL_BATCHKHIB_CTL_VBATSEL_2_5VHIB_CTL_VBATSEL_2_3VHIB_CTL_VBATSEL_2_1VHIB_CTL_VBATSEL_1_9VHIB_CTL_VBATSEL_MHIB_CTL_OSCBYPHIB_CTL_OSCDRVHIB_CTL_OSCSELHIB_CTL_RETCLRHIB_CTL_WRCHIB_RTCLD_SHIB_RTCLD_MHIB_RTCM0_SHIB_RTCM0_MHIB_RTCC_SHIB_RTCC_MHIB_CC0x400FCFC8HIB_PP0x400FCFC0HIB_TPLOG70x400FC4FCHIB_TPLOG60x400FC4F8HIB_TPLOG50x400FC4F4HIB_TPLOG40x400FC4F0HIB_TPLOG30x400FC4ECHIB_TPLOG20x400FC4E8HIB_TPLOG10x400FC4E4HIB_TPLOG00x400FC4E0HIB_TPIO0x400FC410HIB_TPSTAT0x400FC404HIB_TPCTL0x400FC400HIB_LOCK0x400FC360HIB_CALM10x400FC334HIB_CALM00x400FC330HIB_CALLD10x400FC324HIB_CALLD00x400FC320HIB_CAL10x400FC314HIB_CAL00x400FC310HIB_CALCTL0x400FC300HIB_DATA0x400FC030HIB_IO0x400FC02CHIB_RTCSS0x400FC028HIB_RTCT0x400FC024HIB_IC0x400FC020HIB_MIS0x400FC01CHIB_RIS0x400FC018HIB_IM0x400FC014HIB_CTL0x400FC010HIB_RTCLD0x400FC00CHIB_RTCM00x400FC004HIB_RTCC0x400FC000__HW_HIBERNATE_H__// __HW_HIBERNATE_H__// RTCOSC to System Clock Enable// The following are defines for the bit fields in the HIB_CC register.// Wake Pin Presence// Tamper Pin Presence// The following are defines for the bit fields in the HIB_PP register.// Status of TMPR[0] Trigger// Status of TMPR[1] Trigger// Status of TMPR[2] Trigger// Status of TMPR[3] Trigger// Status of external 32// The following are defines for the bit fields in the HIB_TPLOG7 register.// Tamper Log Calendar Information// The following are defines for the bit fields in the HIB_TPLOG6 register.// The following are defines for the bit fields in the HIB_TPLOG5 register.// The following are defines for the bit fields in the HIB_TPLOG4 register.// The following are defines for the bit fields in the HIB_TPLOG3 register.// The following are defines for the bit fields in the HIB_TPLOG2 register.// The following are defines for the bit fields in the HIB_TPLOG1 register.// The following are defines for the bit fields in the HIB_TPLOG0 register.// TMPR0 Enable// TMPR0 Trigger Level// TMPR0 Internal Weak Pull-up// TMPR0 Glitch Filtering// TMPR1Enable// TMPR1 Trigger Level// TMPR1 Internal Weak Pull-up// TMPR1 Glitch Filtering// TMPR2 Enable// TMPR2 Trigger Level// TMPR2 Internal Weak Pull-up// TMPR2 Glitch Filtering// TMPR3 Enable// TMPR3 Trigger Level// TMPR3 Internal Weak Pull-up// TMPR3 Glitch Filtering// The following are defines for the bit fields in the HIB_TPIO register.// External Oscillator Failure// External Oscillator Status// Tamper pin event occurred// Tamper configured// Tamper disabled// Tamper Module Status// The following are defines for the bit fields in the HIB_TPSTAT register.// Tamper Module Enable// Tamper Event Clear// Clear all HIB memory on tamper// memory on tamper event// Clear upper 32 Bytes of HIB// Clear Lower 32 Bytes of HIB// tamper event// Do not Clear HIB memory on// HIB Memory Clear on Tamper Event// Event// Wake from Hibernate on a Tamper// The following are defines for the bit fields in the HIB_TPCTL register.// Hibernate Lock Key// HIbernate Lock// The following are defines for the bit fields in the HIB_LOCK register.// Day of Month// The following are defines for the bit fields in the HIB_CALM1 register.// Minutes// Hours// AM/PM Designation// The following are defines for the bit fields in the HIB_CALM0 register.// Month// Year Value// Day of Week// The following are defines for the bit fields in the HIB_CALLD1 register.// The following are defines for the bit fields in the HIB_CALLD0 register.// Valid Calendar Load// The following are defines for the bit fields in the HIB_CAL1 register.// The following are defines for the bit fields in the HIB_CAL0 register.// RTC Calendar/Counter Mode Select// Calendar Mode// The following are defines for the bit fields in the HIB_CALCTL register.// Hibernation Module NV Data// The following are defines for the bit fields in the HIB_DATA register.// I/O Wake Pad Configuration// Reset Wake Source Enable// I/O Write Complete// The following are defines for the bit fields in the HIB_IO register.// RTC Sub Seconds Count// RTC Sub Seconds Match// The following are defines for the bit fields in the HIB_RTCSS register.// RTC Trim Value// The following are defines for the bit fields in the HIB_RTCT register.// RTC Alert0 Masked Interrupt// Low Battery Voltage Interrupt// External Wake-Up Interrupt Clear// Write Complete/Capable Interrupt// Pad I/O Wake-Up Interrupt Clear// Reset Pad I/O Wake-Up Interrupt// VDD Fail Interrupt Clear// The following are defines for the bit fields in the HIB_IC register.// RTC Alert 0 Masked Interrupt// Low Battery Voltage Masked// External Wake-Up Masked// Write Complete/Capable Masked// Pad I/O Wake-Up Interrupt Mask// VDD Fail Interrupt Mask// The following are defines for the bit fields in the HIB_MIS register.// RTC Alert 0 Raw Interrupt Status// Low Battery Voltage Raw// External Wake-Up Raw Interrupt// Write Complete/Capable Raw// Pad I/O Wake-Up Raw Interrupt// Reset Pad I/O Wake-Up Raw// VDD Fail Raw Interrupt Status// The following are defines for the bit fields in the HIB_RIS register.// RTC Alert 0 Interrupt Mask// External Wake-Up Interrupt Mask// External Write Complete/Capable// The following are defines for the bit fields in the HIB_IM register.// RTC Timer Enable// Hibernation Request// RTC Wake-up Enable// External Wake Pin Enable// Clocking Enable// Power Cut Abort Enable// VDD Powered// Wake on Low Battery// Check Battery Status// 2.5 Volts// 2.3 Volts// 2.1 Volts (default)// 1.9 Volts// Comparator// Select for Low-Battery// Oscillator Bypass// Oscillator Drive Capability// Oscillator Select// GPIO Retention/Clear// Write Complete/Capable// The following are defines for the bit fields in the HIB_CTL register.// RTC Load// The following are defines for the bit fields in the HIB_RTCLD register.// RTC Match 0// The following are defines for the bit fields in the HIB_RTCM0 register.// RTC Counter// The following are defines for the bit fields in the HIB_RTCC register.// Hibernation Clock Control// Hibernation Peripheral// HIB Tamper Log 7// HIB Tamper Log 6// HIB Tamper Log 5// HIB Tamper Log 4// HIB Tamper Log 3// HIB Tamper Log 2// HIB Tamper Log 1// HIB Tamper Log 0// HIB Tamper I/O Control// HIB Tamper Status// HIB Tamper Control// Hibernation Lock// Hibernation Calendar Match 1// Hibernation Calendar Match 0// Hibernation Calendar Load// Hibernation Calendar Load 0// Hibernation Calendar 1// Hibernation Calendar 0// Hibernation Calendar Control// Hibernation Data// Hibernation IO Configuration// Hibernation RTC Sub Seconds// Hibernation RTC Trim// Hibernation Interrupt Clear// Hibernation Masked Interrupt// Hibernation Raw Interrupt Status// Hibernation Interrupt Mask// Hibernation Control// Hibernation RTC Load// Hibernation RTC Match 0// Hibernation RTC Counter// The following are defines for the Hibernation module register addresses.// Copyright (c) 2007-2020 Texas Instruments Incorporated.  All rights reserved.// hw_hibernate.h - Defines and Macros for the Hibernation module./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/hibernate.hHIBERNATE_TAMPER_EVENT_EXT_OSCHIBERNATE_TAMPER_EVENT_3HIBERNATE_TAMPER_EVENT_2HIBERNATE_TAMPER_EVENT_1HIBERNATE_TAMPER_EVENT_0HIBERNATE_TAMPER_IO_MATCH_LONGHIBERNATE_TAMPER_IO_MATCH_SHORTHIBERNATE_TAMPER_IO_WPU_ENABLEDHIBERNATE_TAMPER_IO_WPU_DISABLEDHIBERNATE_TAMPER_IO_TRIGGER_HIGHHIBERNATE_TAMPER_IO_TRIGGER_LOWHIBERNATE_TAMPER_STATUS_EXT_OSC_FAILEDHIBERNATE_TAMPER_STATUS_EXT_OSC_VALIDHIBERNATE_TAMPER_STATUS_EXT_OSC_INACTIVEHIBERNATE_TAMPER_STATUS_EXT_OSC_ACTIVEHIBERNATE_TAMPER_STATUS_EVENTHIBERNATE_TAMPER_STATUS_ACTIVEHIBERNATE_TAMPER_STATUS_INACTIVEHIBERNATE_TAMPER_EVENTS_ERASE_ALL_HIB_MEMHIBERNATE_TAMPER_EVENTS_ERASE_HIGH_HIB_MEMHIBERNATE_TAMPER_EVENTS_ERASE_LOW_HIB_MEMHIBERNATE_TAMPER_EVENTS_NO_ERASE_HIB_MEMHIBERNATE_TAMPER_EVENTS_HIB_WAKEHIBERNATE_TAMPER_EVENTS_NO_HIB_WAKEHIBERNATE_COUNTER_24HRHIBERNATE_COUNTER_12HRHIBERNATE_COUNTER_RTCHIBERNATE_OUT_SYSCLKHIBERNATE_OUT_WRSTALLHIBERNATE_OSC_DISABLEHIBERNATE_OSC_HIGHDRIVEHIBERNATE_OSC_LOWDRIVEHIBERNATE_OSC_LFIOSCHIBERNATE_INT_RTC_MATCH_0HIBERNATE_INT_LOW_BATHIBERNATE_INT_PIN_WAKEHIBERNATE_INT_WR_COMPLETEHIBERNATE_INT_GPIO_WAKEHIBERNATE_INT_RESET_WAKEHIBERNATE_INT_VDDFAILHIBERNATE_LOW_BAT_2_5VHIBERNATE_LOW_BAT_2_3VHIBERNATE_LOW_BAT_2_1VHIBERNATE_LOW_BAT_1_9VHIBERNATE_LOW_BAT_ABORTHIBERNATE_LOW_BAT_DETECTHIBERNATE_WAKE_TAMPER0x08000010HIBERNATE_WAKE_RESETHIBERNATE_WAKE_GPIOHIBERNATE_WAKE_LOW_BATHIBERNATE_WAKE_RTCHIBERNATE_WAKE_PIN__DRIVERLIB_HIBERNATE_H__HibernateTamperExtOscValidHibernateTamperExtOscRecoverHibernateTamperStatusGetHibernateTamperIODisableHibernateTamperIOEnableHibernateTamperDisableHibernateTamperLockHibernateTamperUnLockHibernateTamperEventsClearNoLockHibernateTamperEventsClearHibernateTamperEventsGetHibernateTamperEventsConfigHibernateTamperEnableHibernateCalendarMatchGetHibernateCalendarMatchSetHibernateCalendarGetHibernateCalendarSetHibernateCounterModeHibernateBatCheckDoneHibernateBatCheckStartHibernateClockConfigHibernateRTCSSGetHibernateRTCSSMatchGetHibernateRTCSSMatchSetHibernateIsActiveHibernateIntClearHibernateIntStatusHibernateIntUnregisterHibernateIntRegisterHibernateIntDisableHibernateIntEnableHibernateRequestHibernateDataGetHibernateDataSetHibernateRTCTrimGetHibernateRTCTrimSetHibernateRTCMatchGetHibernateRTCMatchSetHibernateRTCGetHibernateRTCSetHibernateLowBatGetHibernateLowBatSetHibernateWakeGetHibernateWakeSetHibernateRTCDisableHibernateRTCEnableHibernateDisableHibernateEnableExpClkHibernateGPIORetentionGetHibernateGPIORetentionDisableHibernateGPIORetentionEnable// __DRIVERLIB_HIBERNATE_H__// Tamper log event flags.// Configuration options used with HibernateTamperIOEnable().// Status flags returned by the HibernateTamperStatus() function.// Tamper event configuration options used with HibernateTamperEventsConfig().// The following defines are used with the HibernateCounterMode() API.// HibernateClockConfig() function.// Macros defining oscillator configuration options for the// Macros defining interrupt source bits for the interrupt functions.// Macros needed to configure low battery detect for HibernateLowBatSet()// Macros need to configure wake events for HibernateWakeSet()// hibernate.h - API definition for the Hibernation module.ui32Inputpui32RTCpui32EventpsTimeui32Matchui32Trimui32RTCValueui32LowBatFlagsui32WakeFlagsui32HibClk/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/_ansi.h/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/newlib.h/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/sys/config.h/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/machine/ieeefp.h/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/sys/cdefs.h/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/sys/reent.h/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/machine/_types.h/home/frost/Documents/ectf_2023/gcc-arm-none-eabi-5_4-2016q3-20160926-linux/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/sys/lock.h/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/hibernate.c"driverlib/hibernate.h""inc/hw_hibernate.h"<time.h>(HIBERNATE_TAMPER_STATUS_EXT_OSC_ACTIVE |
                                     HIBERNATE_TAMPER_STATUS_EXT_OSC_VALID)107477488027381978441074775044HIB_TPLOG0 + ((ui32Index << 3) + 4)0x400FC4E0 + ((ui32Index << 3) + 4)1074775264HIB_TPLOG0 + (ui32Index << 3)0x400FC4E0 + (ui32Index << 3)1074774784(HIB_CALCTL_CALEN | HIB_CALCTL_CAL24)10747748001269760X0001f00012<<12(12<<12)4294840319~0X0001f000ui32Index < 4(HIB_TPSTAT_XOSCST | HIB_TPSTAT_XOSCFAIL)10747750401074775056-2~HIB_TPIO_EN0(~HIB_TPIO_EN0)ui32Input < 4(HIB_TPIO_GFLTR0 | HIB_TPIO_PUEN0 |
                               HIB_TPIO_LEV0 | HIB_TPIO_EN0)~HIB_TPCTL_TPEN4294966527~HIB_TPCTL_MEMCLR_Mui32Dateui32Time10747748361074774832161282031616HWREG(HIB_CALCTL) & HIB_CALCTL_CALEN10747748041174405128323072_HibernateCalendarSet4290772991~HIB_CAL0_AMPM0 << HIB_CAL1_DOM_M1074774816107477482010747740321073742080(HIB_CTL_RETCLR | HIB_CTL_VDD3ON)3221225215~(HIB_CTL_RETCLR | HIB_CTL_VDD3ON)1074774048!(ui32IntFlags & ~(HIBERNATE_INT_PIN_WAKE | HIBERNATE_INT_LOW_BAT | HIBERNATE_INT_VDDFAIL | HIBERNATE_INT_RESET_WAKE | HIBERNATE_INT_GPIO_WAKE | HIBERNATE_INT_RTC_MATCH_0 | HIBERNATE_INT_WR_COMPLETE))10747740441074774040_HibernateIntNumberGet1074774036HIB_DATA + (ui32Idx * 4)0x400FC030 + (ui32Idx * 4)1074774064ui32Count <= 64pui32Data != 01074774052ui32Trim < 0x10000107477405632767ui32Match == 010747740201074774016107477402824736(HIB_CTL_VBATSEL_M | HIBERNATE_LOW_BAT_ABORT)(HIB_CTL_VBATSEL_M |
                                          HIBERNATE_LOW_BAT_ABORT)4294942559~(HIB_CTL_VBATSEL_M |
                                          HIBERNATE_LOW_BAT_ABORT)!(ui32LowBatFlags & ~(HIB_CTL_VBATSEL_M | HIBERNATE_LOW_BAT_ABORT))ui32Ctrl(HIBERNATE_WAKE_PIN | HIBERNATE_WAKE_RTC |
                            HIBERNATE_WAKE_LOW_BAT)10747740601048592(HIBERNATE_WAKE_RESET |
                                         HIBERNATE_WAKE_GPIO)(HIBERNATE_WAKE_PIN | HIBERNATE_WAKE_RTC |
                                 HIBERNATE_WAKE_LOW_BAT)(HIBERNATE_WAKE_PIN |
                                         HIBERNATE_WAKE_RTC |
                                         HIBERNATE_WAKE_LOW_BAT)4294966759~(HIBERNATE_WAKE_PIN |
                                         HIBERNATE_WAKE_RTC |
                                         HIBERNATE_WAKE_LOW_BAT)(HIBERNATE_WAKE_RESET | HIBERNATE_WAKE_GPIO)~HIB_IO_WUUNLK!(ui32WakeFlags & ~(HIBERNATE_WAKE_PIN | HIBERNATE_WAKE_RTC | HIBERNATE_WAKE_GPIO | HIBERNATE_WAKE_RESET | HIBERNATE_WAKE_LOW_BAT))~HIB_CTL_RTCENui32HIBCtl720896(HIBERNATE_OSC_HIGHDRIVE | HIBERNATE_OSC_LOWDRIVE |
                    HIBERNATE_OSC_LFIOSC | HIBERNATE_OSC_DISABLE)4294246399~(HIBERNATE_OSC_HIGHDRIVE | HIBERNATE_OSC_LOWDRIVE |
                    HIBERNATE_OSC_LFIOSC | HIBERNATE_OSC_DISABLE)(HIBERNATE_OSC_HIGHDRIVE |
                                HIBERNATE_OSC_LOWDRIVE |
                                HIBERNATE_OSC_LFIOSC |
                                HIBERNATE_OSC_DISABLE)1074778056(HIBERNATE_OUT_SYSCLK)(ui32Config & ~(HIBERNATE_OSC_HIGHDRIVE | HIBERNATE_OSC_LOWDRIVE | HIBERNATE_OSC_DISABLE)) == 0~HIB_CTL_CLK32EN_HibernateWriteCompleteHIBERNATE_CLOCK_OUTPUTCLASS_IS_TM4C129HIBERNATE_WAKE_IOLOOP_CYCLESDELAY_USECS//! stable, otherwise a \b false indicator is returned.//! \return Returns \b true if the external oscillator is both active and//! are using to determine if this feature is available.//! devices.  Please consult the data sheet for the Tiva device that you//! \note The hibernate tamper feature is not available on all Tiva//! HibernateTamperExtOscRecover().//! \b HIBERNATE_TAMPER_STATUS_EXT_OSC_FAILED status by calling//! and valid before attempting to recover from a//! This function should be used to verify the external oscillator is active//! Reports if the external oscillator signal is active and stable.// Lock the tamper registers.// Wait for write completion.// Set the XOSCFAIL clear bit.// Unlock the tamper registers.//! before calling this function.//! the hibernation clock input.  HibernateTamperExtOscValid() should be called//! function must not be called if the external oscillator is not used as//! \b HIBERNATE_TAMPER_STATUS_EXT_OSC_FAILED status is reported.  This//! This function is used to attempt to recover the external oscillator after a//! Attempts to recover the external oscillator.// Return success.// Add 12 hour since it is PM// and in 24hr mode.// Convert the hour to 24hr mode if the Calendar is enabled// Retrieve the calendar information.// Store the event data in the provided location.// No event data is available for this index.// Retrieve the event log data for the requested index if available.// Verify parameters.//! successfully and returns \b false if the values were not updated.//! \return Returns \b true if the \e pui32RTC and \e pui32Events were updated//! until cleared.  Events are only logged if unused log space is available.//! \note Tamper event logs are not consumed when read and remain available//! triggered the tamper event//! - \b HIBERNATE_TAMPER_EVENT_XOSC indicates an external oscillator failure//! signal 3//! - \b HIBERNATE_TAMPER_EVENT_3 indicates a tamper event was triggered on I/O//! signal 2//! - \b HIBERNATE_TAMPER_EVENT_2 indicates a tamper event was triggered on I/O//! signal 1//! - \b HIBERNATE_TAMPER_EVENT_1 indicates a tamper event was triggered on I/O//! signal 0//! - \b HIBERNATE_TAMPER_EVENT_0 indicates a tamper event was triggered on I/O//! The data returned in the \e pui32Events parameter could include any of the//! +----------------------------------------------------------------------+//! |  year   |  month  |  day of month  |  hours  |  minutes  |  seconds  |//! |  31:26  |  25:22  |     21:17      |  16:12  |   11:6    |    5:0    |//! returned is formatted as follows://! from the RTC enable.  If the RTC is configured for calendar mode, the data//! configured for counter mode, the returned data contains counted seconds//! configuration of the RTC within the Hibernation module.  If the RTC is//! The format of the returned \e pui32RTC data is dependent on the//! this log.//! and \e pui32Event parameter contains the tamper I/O event that triggered//! When this function returns, the \e pui32RTC value contains the time value//! to query and has a valid range of 0-3.//! feature.  The \e ui32Index specifies the zero-based index of the log entry//! This function is used to return a tamper log entry from the hibernate//! event.//! \param pui32Event is a pointer to the memory to store the logged tamper//! \param pui32RTC is a pointer to the memory to store the logged RTC data.//! \param ui32Index is the index of the log entry to return.//! Returns a tamper log entry.// Return the API status flags.// for this purpose.// The HW shows "disabled" with a zero value, use bit[0] as a flag// Retrieve the tamper status indicators.// Setup the oscillator status indicators.// Retrieve the raw register value.//! \return Returns a combination of the \b HIBERNATE_TAMPER_STATUS_* values.//! oscillator is providing a valid signal//! - \b HIBERNATE_TAMPER_STATUS_EXT_OSC_VALID indicates the external//! oscillator signal has transitioned from valid to invalid//! - \b HIBERNATE_TAMPER_STATUS_EXT_OSC_FAILED indicates the external//! And one of the values is included from this group://! oscillator is active//! - \b HIBERNATE_TAMPER_STATUS_EXT_OSC_ACTIVE indicates the external//! oscillator is not active//! - \b HIBERNATE_TAMPER_STATUS_EXT_OSC_INACTIVE indicates the external//! In addition, one of the values is included from this group://! - \b HIBERNATE_TAMPER_STATUS_EVENT indicates tamper event was detected//! and ready//! - \b HIBERNATE_TAMPER_STATUS_ACTIVE indicates tamper detection is enabled//! disabled//! - \b HIBERNATE_TAMPER_STATUS_INACTIVE indicates tamper detection is//! returns one of the values from this group of options://! This function is used to return the tamper feature status.  This function//! Returns the current tamper feature status.//! HibernateTamperEventsClearNoLock().//! function should be used after calling API//! This function is used to lock the temper control registers.  This//! Lock temper registers.//! function should be only used before calling API//! This function is used to unlock the temper control registers.  This//! Unlock temper registers.// Set the tamper event clear bit.//! the clear of current tamper event.//! handler to fix an issue when a new tamper event could be missed during//! This function is used to implement a software workaround in NMI interrupt//! occure only after the write complete bit is set.//! Therefore, care must be taken to ensure the next immediate write will//! This function doesn't block until the write is complete.//! called after to ensure that tamper control registers are locked.//! called before this function, and API HibernateTamperLock() should be//! the tamper control registers, so API HibernateTamperUnLock() should be//! This function is used to clear all tamper events without unlock/locking//! Clears the tamper feature events without Unlock and Lock.//! control NMI that resulted from the tamper event.//! HibernateTamperEventsClear() should be called prior to clearing the system//! HibernateTamperEventsGet() prior to requesting a event clear.//! entries.  Logged event data should be retrieved with//! clears the tamper feature event state indicator along with all tamper log//! This function is used to clear all tamper events.  This function always//! Clears the tamper feature events.// Clear the I/O enable bit.//! configuration by GPIO APIs.//! pins.  The tamper pins configured by using this function overrides any//! \note None of the GPIO API functions are needed to configure the tamper//! \e ui32Input parameter specifies the tamper signal to disable and has a//! This function is used to disable an input to the tamper feature.  The//! \param ui32Input is the tamper input to disable.//! Disables an input to the tamper feature.// Write to the register.// Set tamper I/O configuration for the requested input.// Mask out configuration options for the requested input.// Read the current tamper I/O configuration.//! - \b HIBERNATE_TAMPER_IO_TRIGGER_LOW sets the tamper event to active low//! - \b HIBERNATE_TAMPER_IO_TRIGGER_HIGH sets the tamper event to active high//! - \b HIBERNATE_TAMPER_IO_WPU_DISABLED turns off an internal weak pull up//! - \b HIBERNATE_TAMPER_IO_WPU_ENABLED turns on an internal weak pull up//! 3071 hibernation clocks//! - \b HIBERNATE_TAMPER_IO_MATCH_LONG configures the trigger to match after//! 2 hibernation clocks//! - \b HIBERNATE_TAMPER_IO_MATCH_SHORT configures the trigger to match after//! in the \e ui32Config parameter are://! features in the \b HIBERNATE_TAMPER_IO_* values.  The values that are valid//! valid range of 0-3.  The \e ui32Config parameter provides the set of tamper//! \e ui32Input parameter specifies the tamper signal to configure and has a//! This function is used to configure an input to the tamper feature.  The//! tamper feature.//! \param ui32Config holds the configuration options for a given input to the//! \param ui32Input is the tamper input to configure.//! Configures an input to the tamper feature.// Clear the tamper enable bit.//! previous configuration.//! HibernateTamperEnable() to quickly enable the tamper feature with its//! other configuration settings are left unmodified, allowing a call to//! This function is used to disable the tamper feature functionality.  All//! Disables the tamper feature.// Set the tamper enable bit.//! configured with a call to HibernateTamperIOEnable().//! a call to HibernateTamperEventsConfig() and the tamper inputs have been//! function should only be called after the global configuration is set with//! This function is used to enable the tamper feature functionality.  This//! Enables the tamper feature.// Set the on-event configuration.// Mask out the on-event configuration options.//! MCU from hibernation//! - \b HIBERNATE_TAMPER_EVENTS_NO_HIB_WAKE a tamper event does not wake the//! hibernation//! - \b HIBERNATE_TAMPER_EVENTS_HIB_WAKE a tamper event wakes the MCU from//! battery-backed RAM is not changed due to a tamper event//! - \b HIBERNATE_TAMPER_EVENTS_ERASE_NO_HIB_MEM the Hibernation module's//! Hibernation module's battery-backed RAM is cleared due to a tamper event//! - \b HIBERNATE_TAMPER_EVENTS_ERASE_LOW_HIB_MEM the lower half of the//! - \b HIBERNATE_TAMPER_EVENTS_ERASE_HIGH_HIB_MEM the upper half of the//! module's battery-backed RAM is cleared due to a tamper event//! - \b HIBERNATE_TAMPER_EVENTS_ERASE_ALL_HIB_MEM all of the Hibernation//! what happens to the system when a tamper event occurs://! application should choose from the following set of defines to determine//! \b HIBERNATE_TAMPER_EVENTS_* features to set these options.  The//! tamper feature.  The \e ui32Config parameter provides a combination of the//! This function is used to configure the event response options for the//! \param ui32Config specifies the configuration options for tamper events.//! Configures the tamper feature event response.// Fix up the hour in the non-24-hour mode and the time is in PM.// Match every day// Match every hour// Match every second// Match every minute// Populate the date and time fields in the psTime structure.// Get the time field.// Get the date field.//! updated.//! successfully and returns a non-zero value if the psTime structure was not//! \return Returns zero if the time and date match value were read//! using supports this feature in the Hibernation module.//! devices.  Please consult the data sheet to determine if the device you are//! \note The hibernate calendar mode is not available on all Tiva//! zero.//! The \e ui32Index value is reserved for future use and should always be//! in calendar mode using the HibernateCounterMode() function.//! This function can only be called when the Hibernation module is configured//! \e psTime parameter uses a 24-hour clock representation of time.//! structure provided by the \e psTime parameter.  Regardless of the mode, the//! This function returns the current date and time match value in the//! match value.//! \param psTime is the structure to fill with the current date and time//! \param ui32Index indicates which match register to access.//! Returns the Hibernation module's date and time match value in calendar// Set the Match value.//! results in a calendar match daily at the same time.//! that field.  For example, setting the day of month field to 0xFF//! every second, setting any of these fields to 0xFF causes a match for//! Calendar match can be enabled for every day, every hour, every minute or//! always be zero.//! function.  The \e ui32Index value is reserved for future use and should//! configured in calendar mode using the HibernateCounterMode()//! This function can only be called when the Hibernation module is//! the \e psTime parameter uses a 24-hour clock representation of time.//! match value in the Hibernation module's calendar.  Regardless of the mode,//! This function uses the \e psTime parameter to set the current date and time//! the current date and time match values.//! \param psTime is the structure that holds all of the information to set//! Sets the Hibernation module's date and time match value in calendar mode.// the month from 0 to 11 and the HIB lists it from 1 to 12.// We must subtract 1 from the month, since the time structure lists// second passes.// application call again since it knows how int32_t to wait until another// The date changed after reading the time so fail this call and let the// loops and should never hang.// Wait for the value to be valid, this should never be more than a few//! returns a non-zero value if the \e psTime structure was not updated.//! \return Returns zero if the time and date were read successfully and//! again to get the updated calendar information.//! handled in the application by waiting at least one second before calling//! of the day to the first second of the next day.  This exception must be//! when the function detects that the counter is passing from the last second//! The only case where this function fails and returns a non-zero value is//! calendar modes.//! calendar mode using the HibernateCounterMode() function with one of the//! function can only be called when the Hibernation module is configured in//! \e psTime parameter uses a 24-hour representation of the time.  This//! by the \e psTime parameter.  Regardless of the calendar mode, the//! This function returns the current date and time in the structure provided//! \param psTime is the structure that is filled with the current date and//! Returns the Hibernation module's date and time in calendar mode.// Load a new date/time.//! produce unexpected results.//! after the year 2000 only. Calendar years before 2000 (i.e. 1987) will //! year up to 2099, the HibernateCalendarSet() will accept calendar year //! valid values ranges from 0 to 99. In order to maximize the calendar //! The hibernate module contains a 7-bit register field to store the year with//! //! HibernateCounterMode() function with one of the calendar modes.//! the hibernate counter is configured in calendar mode using the//! 24-hour representation of the time.  This function can only be called when//! whether 24-hour or 12-hour mode is in use, the \e psTime structure uses a//! time when the Hibernation module is in calendar mode.  Regardless of//! This function uses the \e psTime parameter to set the current date and//! date and time.//! \param psTime is the structure that holds the information for the current//! Sets the Hibernation module's date and time in calendar mode.// Lock the hibernate counter load registers.// Load register requires unlock.// Set the requested time and date.// Unlock the hibernate counter load registers.// program 0 to match every day// Functionality.// Wday, month and year are not included in the match// We must add 1 to the month, since the time structure lists// Create the date in the correct register format.// All other times are normal and AM.// Need to set the PM bit if it is noon or later.// Match every hour.// always true.  We need to set 1F in the hw field.// If the hours are all 1s, it means the match for the hour is// In AM/PM time hours have to be capped at 12.// clear AMPM bit// for Calendar match, if it is every hour, AMPM bit should be clear// 24 Hour time is used directly for Calendar set.// Minutes and seconds are consistent in all modes.// Internal function to parse the time structure to set the calendar fields.// Wait for write completion// Set the requested configuration.//! HibernateCounterMode(HIBERNATE_COUNTER_24HR);//! // Configure the hibernate module counter to 24-hour calendar mode.//! \b Example: Configure hibernate counter to 24-hour calendar mode.//! \b HIBERNATE_COUNTER_24HR or \b HIBERNATE_COUNTER_12HR is specified.//! The HibernateCalendar functions can only be called when either//! - \b HIBERNATE_COUNTER_RTC specifies RTC counter mode.//! - \b HIBERNATE_COUNTER_12HR specifies 12-hour AM/PM calendar mode.//! - \b HIBERNATE_COUNTER_24HR specifies 24-hour calendar mode.//! the counter and must include only one of the following values://! \e ui32Config parameter is used to provide the configuration for//! as a standard RTC counter or to operate in a calendar mode.  The//! This function configures the Hibernate module's counter mode to operate//! counter.//! \param ui32Config is the configuration to use for the Hibernation module's//! Configures the Hibernation module's internal counter mode.// Read the current GPIO retention configuration.//! retention is disabled.//! \return Returns true if GPIO retention is enabled and false if GPIO//! device you are using supports this feature in the Hibernation module.//! Tiva devices.  Please consult the data sheet to determine if the//! \note The hibernation GPIO retention setting is not available on all//! hibernate module.//! This function returns the current setting for GPIO retention in the//! Returns the current setting for GPIO retention.// the hibernate power to the pads.// Reset the GPIO configuration after waking from hibernate and disable//! \note The hibernate GPIO retention setting is not available on all//! to allow the GPIO pins to be controlled by GPIO module.//! hibernation, this function must be called after returning from hibernation//! the HibernateGPIORetentionEnable() function is called before entering//! hibernation and allows the GPIO pins to be controlled by the system.  If//! This function disables the retention of the GPIO pin state during//! Disables GPIO retention after wake from hibernation.// Enable power to the pads and enable GPIO retention during hibernate.//! of the GPIO pin to the GPIO module.//! HibernateGPIORetentionDisable() function must be called to return control//! hibernation, the GPIO module must be reconfigured and then the//! output pins.  To maintain the current output level after waking from//! module itself is reset upon entering hibernation and no longer controls the//! hibernation and remain active even when waking from hibernation.  The GPIO//! This function enables the GPIO pin state to be maintained during//! Enables GPIO retention after wake from hibernation.// Read the control register, and return true if the module is enabled.//! not.//! \return Returns \b true if the module is already active, and \b false if//! a result.//! processor is waking from hibernation and the appropriate action to take as//! combinations of functions can be used by the software to determine if the//! HibernateDataGet() function can be used to restore state.  These//! to read the raw interrupt status to determine the cause of the wake.  The//! The software application should also use the HibernateIntStatus() function//! re-enabled, and its status can be queried immediately.//! If the Hibernation module is already active, then it does not need to be//! determine if the reset is due to a wake from hibernation or a cold start.//! already active.  This function can be called at a power-on reset to help//! This function queries the control register to determine if the module is//! Checks to see if the Hibernation module is already powered up.// Write the specified interrupt bits into the interrupt clear register.//! \e ui32IntFlags parameter to the HibernateIntEnable() function.//! The \e ui32IntFlags parameter has the same definition as the//! upon exit.//! be called within the interrupt handler or else the handler is called again//! This function clears the specified interrupt sources.  This function must//! \param ui32IntFlags is the bit mask of the interrupts to be cleared.//! Clears pending interrupts from the Hibernation module.// Read and return the Hibernation module raw or masked interrupt status.//! described in the HibernateIntEnable() function.//! \return Returns the interrupt status as a bit field with the values as//! Hence a wake from reset pin should take priority over wake from GPIO pin.//! value returned being HIBERNATE_INT_GPIO_WAKE | HIBERNATE_INT_RESET_WAKE.//! \note A wake from reset pin also signals a wake from GPIO pin with the//! interrupt.  Either the masked or raw interrupt status can be returned.//! caller can use this function to determine the cause of a hibernation//! This function returns the interrupt status of the Hibernation module.  The//! retrieve the masked interrupt status.//! \param bMasked is false to retrieve the raw interrupt status, and true to//! Gets the current interrupt status of the Hibernation module.// Disable the hibernate interrupt.// Get the interrupt number for the Hibernate module.//! interrupt handler is no longer called.//! controller.  The interrupt is disabled at the global level, and the//! This function unregisters the interrupt handler in the system interrupt//! Unregisters an interrupt handler for the Hibernation module interrupt.// Enable the hibernate module interrupt.//! HibernateIntEnable().//! interrupt sources must still be enabled with a call to//! controller.  The interrupt is enabled at the global level, but individual//! This function registers the interrupt handler in the system interrupt//! \param pfnHandler points to the function to be called when a hibernation//! Registers an interrupt handler for the Hibernation module interrupt.// Find the valid interrupt number for the hibernate module.//! \return Returns a hibernate interrupt number or 0 if the interrupt does not//! This function returns the interrupt number for the hibernate module.//! Returns the hibernate module interrupt number.// Clear the specified interrupt mask bits.//! Hibernation module.//! This function disables the specified interrupt sources from the//! \param ui32IntFlags is the bit mask of the interrupts to be disabled.//! Disables interrupts for the Hibernation module.// Set the specified interrupt mask bits.//! determine if these interrupt sources are available.//! Please consult the data sheet for the Tiva device that you are using to//! \b HIBERNATE_INT_VDDFAIL settings are not available on all Tiva devices.//! \note The \b HIBERNATE_INT_RESET_WAKE, \b HIBERNATE_INT_GPIO_WAKE, and//! - \b HIBERNATE_INT_GPIO_WAKE - wake from GPIO pin or reset pin interrupt.//! - \b HIBERNATE_INT_RESET_WAKE - wake from reset pin interrupt//! - \b HIBERNATE_INT_VDDFAIL - supply failure interrupt.//! - \b HIBERNATE_INT_RTC_MATCH_0 - RTC match 0 interrupt//! - \b HIBERNATE_INT_LOW_BAT - low-battery interrupt//! - \b HIBERNATE_INT_PIN_WAKE - wake from pin interrupt//! - \b HIBERNATE_INT_WR_COMPLETE - write complete interrupt//! The \e ui32IntFlags parameter must be the logical OR of any combination of//! This function enables the specified interrupt sources from the Hibernation//! \param ui32IntFlags is the bit mask of the interrupts to be enabled.//! Enables interrupts for the Hibernation module.// Set the bit in the control register to cut main power to the processor.//! and wait for the power to be removed.//! return.  The simplest way to handle it is to just enter an infinite loop//! For all these reasons, the caller must be prepared for this function to//! circuit design, that a request for hibernation may not actually occur.//! voltage is too low.  There may be other reasons related to the external//! battery is detected, then the power is not removed if the battery//! HibernateLowBatSet() function was used to configure an abort if low//! various reasons why the power may not be removed.  For example, if the//! and the caller should be prepared for this function to return.  There are//! reason, the processor continues to execute instructions for some time,//! power is actually removed, or it may not be removed at all.  For this//! Note that this function may return because some time may elapse before the//! for waking must have already been set by using the HibernateWakeSet()//! Prior to calling the function to request hibernation mode, the conditions//! can retrieve saved state information with the HibernateDataGet() function.//! power-on reset although the Hibernation module is not reset.  The processor//! \b WAKE pin).  When the power is restored, the processor goes through a//! the configured wake conditions occurs (such as RTC match or external//! The Hibernation module re-enables the external regulator when one of//! supply.//! Hibernation module remains powered from the battery or auxiliary power//! regulator, thus removing power from the processor and all peripherals.  The//! This function requests the Hibernation module to disable the external//! Requests hibernation mode.// required between reads.// Read a word from the battery-backed storage area.  No delay is// Loop through all the words to be restored, reading one at a time.//! from the battery-backed memory.//! points to a large enough memory block to hold all the data that is read//! HibernateDataSet() function.  The caller must ensure that \e pui32Data//! battery-backed memory that was previously stored with the//! This function retrieves a set of data from the Hibernation module//! \param ui32Count is the count of 32-bit words to read.//! Hibernation module is stored.//! \param pui32Data points to a location where the data that is read from the//! Reads a set of data from the battery-backed memory of the Hibernation// Write a word to the battery-backed storage area.// Loop through all the words to be stored, storing one at a time.//! HibernateDataGet() function.//! battery-backed memory.  The data can be restored by calling the//! the processor wakes.  Up to 16 32-bit words can be stored in the//! and can be used to store application state information that is needed when//! This memory is preserved when the power to the processor is turned off//! Stores a set of data in the Hibernation module battery-backed memory.//! \param ui32Count is the count of 32-bit words to store.//! memory of the Hibernation module.//! \param pui32Data points to the data that the caller wants to store in the//! Stores data in the battery-backed memory of the Hibernation module.// Return the value of the trim register to the caller.//! to making an adjustment by using the HibernateRTCTrimSet() function.//! function can be used to get the current value of the trim register prior//! This function gets the value of the pre-divider trim register.  This//! Gets the value of the RTC pre-divider trim register.// Write the new trim value to the trim register.//! can be adjusted up or down in order to fine-tune the RTC rate.//! the accuracy of the input time source.  The nominal value is 0x7FFF, and it//! adjustments to the pre-divider trim register to account for variations in//! to make corrections to the rate.  The software application can make//! applied to the pre-divider to allow fine-tuning of the RTC rate, in order//! rate.  Once every 64 seconds, the value of the pre-divider trim register is//! time source is divided by the pre-divider to achieve a one-second clock//! This function sets the value of the pre-divider trim register.  The input//! \param ui32Trim is the new value for the pre-divider trim register.//! Sets the value of the RTC pre-divider trim register.// Read the current second RTC count.//! \return The current RTC sub second count in 1/32768 seconds.//! use.//! the \e ui32Match parameter is zero, other values are reserved for future//! in 1/32768 of a second increments.  The only value that can be used with//! This function returns the current value of the sub second count for the RTC//! Returns the current value of the RTC sub second count.//! \return Returns the value of the requested sub section match register.//! values are reserved for future use.//! value that can be used with the \e ui32Match parameter is zero, other//! for the RTC.  The value returned is in 1/32768 second increments.  The only//! This function returns the current value of the sub second match register//! \param ui32Match is the index of the match register.//! Returns the value of the requested RTC sub second match register.// Wait for write complete to be signaled on later devices.// Write the new sub second match value to the sub second match register.//! parameter is zero, other values are reserved for future use.//! register.  The only value that can be used with the \e ui32Match//! counter is the same as the match combined with the sub second match//! from hibernation, and/or generate an interrupt when the value of the RTC//! of a second increments.  The Hibernation module can be configured to wake//! This function sets the sub second match register for the RTC in 1/32768//! \param ui32Value is the value for the sub second match register.//! Sets the value of the RTC sub second match register.// Return the value of the match register to the caller.//! \return Returns the value of the requested match register.//! This function gets the value of the match register for the RTC.  The only//! Gets the value of the requested RTC match register.// Write the new match value to the match register.//! register.//! interrupt when the value of the RTC counter is the same as the match//! module can be configured to wake from hibernation, and/or generate an//! This function sets a match register for the RTC.  The Hibernation//! \param ui32Value is the value for the match register.//! Sets the value of the RTC match register.// Return the value of the RTC counter register to the caller.//! \return Returns the value of the RTC counter in seconds.//! This function gets the value of the RTC and returns it to the caller.//! Gets the value of the real time clock (RTC) counter.// Unlock.// Write the new RTC value to the RTC load register.//! enabled by calling HibernateRTCEnable() before calling this function.//! count in seconds when a 32.768kHz clock source is in use.  The RTC must be//! This function sets the value of the RTC.  The RTC counter contains the//! \param ui32RTCValue is the new value for the RTC.//! Sets the value of the real time clock (RTC) counter.// those bits to the caller.// Read the supported low bat bits from the control register and return//! \return Returns a value indicating the configured low-battery detection.//! HibernateLowBatSet() function.//! The return value is a combination of the values described in the//! battery detection behavior.//! This function returns a value representing the currently configured low//! Gets the currently configured low-battery detection behavior.// according to the parameter.// Set the low-battery detect and abort bits in the control register,//! HibernateLowBatSet(HIBERNATE_LOW_BAT_ABORT | HIBERNATE_LOW_BAT_2_1V);//! \b Example: Abort hibernate if the voltage level is below 2.1 V.//! - \b HIBERNATE_LOW_BAT_2_5V - voltage low level is 2.5 V//! - \b HIBERNATE_LOW_BAT_2_3V - voltage low level is 2.3 V//! - \b HIBERNATE_LOW_BAT_2_1V - voltage low level is 2.1 V//! - \b HIBERNATE_LOW_BAT_1_9V - voltage low level is 1.9 V//! the following voltage level trigger values ://! The other setting in the \e ui32LowBatFlags allows the caller to set one of//!   hibernation if low-battery is detected//! - \b HIBERNATE_LOW_BAT_ABORT - detect a low-battery condition and abort//! - \b HIBERNATE_LOW_BAT_DETECT - detect a low-battery condition//! The \e ui32LowBatFlags parameter is one of the following values://! hibernation can be aborted if a low battery condition is detected.//! register, which can be enabled to trigger an interrupt.  Optionally,//! then a low-battery condition is indicated in the raw interrupt status//! allowed if a low battery is detected.  If low-battery detection is enabled,//! This function enables the low-battery detection and whether hibernation is//! \param ui32LowBatFlags specifies behavior of low-battery detection.//! Configures the low-battery detection.// the caller.// Read the wake bits from the control register and return those bits to//! \return Returns flags indicating the configured wake conditions.//! wake from hibernation on a tamper event.//! Hibernation module.  Refer the function \b HibernateTamperEventsConfig() to//! \note On some Tiva devices a tamper event acts as a wake source for the//! \b HIBERNATE_WAKE_RESET parameters are only available on some Tiva devices.//! \note The \b HIBERNATE_WAKE_LOW_BAT, \b HIBERNATE_WAKE_GPIO, and//! - \b HIBERNATE_WAKE_RESET - wake when a reset pin is asserted//! - \b HIBERNATE_WAKE_GPIO - wake when a GPIO pin is asserted//! level being detected//! - \b HIBERNATE_WAKE_LOW_BAT - wake from hibernation due to a low-battery//! - \b HIBERNATE_WAKE_RTC - wake when the RTC matches occurs//! - \b HIBERNATE_WAKE_PIN - wake when the external wake pin is asserted//! Hibernation module.  The return value is a combination of the following//! This function returns the flags representing the wake configuration for the//! Gets the currently configured wake conditions for the Hibernation module.// Clear the write unlock bit.// Spin until the write complete bit is set.// Set the requested flags.// retain their state.// Make sure that VDD3ON mode is enabled so that the pads can// powered.// the VDD3ON needs to be set to allow the pads to remained// If the reset or GPIOs are begin used as a wake source then the// Write the hibernate IO register if requested.// Set the specified wake flags in the control register.//! only available on some Tiva devices.//! \note The \b HIBERNATE_WAKE_GPIO and \b HIBERNATE_WAKE_RESET parameters are//! hibernation.//! be called to properly configure and enable a GPIO as a wake source for//! configuration functions GPIOPinTypeWakeHigh() or GPIOPinTypeWakeLow() must//! If the \b HIBERNATE_WAKE_GPIO flag is set, then one of the GPIO//! - \b HIBERNATE_WAKE_RESET - wake when a reset pin is asserted.//! - \b HIBERNATE_WAKE_GPIO - wake when a GPIO pin is asserted.//! level being detected.//! - \b HIBERNATE_WAKE_LOW_BAT - wake from hibernate due to a low-battery//! - \b HIBERNATE_WAKE_RTC - wake when the RTC match occurs.//! - \b HIBERNATE_WAKE_PIN - wake when the external wake pin is asserted.//! of the following://! wakes.  The \e ui32WakeFlags parameter is the logical OR of any combination//! This function enables the conditions under which the Hibernation module//! \param ui32WakeFlags specifies which conditions should be used for waking.//! Configures the wake conditions for the Hibernation module.// Read the current state of the battery check.//! non-zero if the check is still in process.//! \return The value is zero when the battery level check has completed or//! \b HIBERNATE_INT_LOW_BAT set.//! check if the battery was low by checking if the value returned has the//! the battery check and the HibernateIntStatus() function can be used to//! this function returns a value of zero, the Hibernation module has completed//! returns a non-zero value until the battery level check has completed.  Once//! call to the HibernateBatCheckStart() function has completed.  This function//! This function determines whether the forced battery check initiated by a//! Determines whether or not a forced battery check has completed.// Initiated a forced battery check.//! \note A hibernation request is held off if a battery check is in progress.//! that the battery level is low.//! \b HIBERNATE_INT_LOW_BAT interrupt and wait for an interrupt to indicate//! the battery level is low.  The application can also enable the//! has the \b HIBERNATE_INT_LOW_BAT set.  If \b HIBERNATE_INT_LOW_BAT is set,//! value before calling the HibernateIntStatus() to check if the return code//! HibernateBatCheckDone() function and wait for the function to return a zero//! to pass.  After calling this function, the application should call the//! battery voltage immediately rather than waiting for the next check interval//! This function forces the Hibernation module to initiate a check of the//! Forces the Hibernation module to initiate a check of the battery voltage.// Turn off the RTC enable bit.//! this function, the RTC features of the Hibernation module are not//! This function disables the RTC in the Hibernation module.  After calling//! Disables the RTC feature of the Hibernation module.// Turn on the RTC enable bit.//! using any of the RTC features of the Hibernation module.//! generate interrupts at certain times.  This function must be called before//! used to wake the processor from hibernation at a certain time, or to//! This function enables the RTC in the Hibernation module.  The RTC can be//! Enables the RTC feature of the Hibernation module.// controlling the output clocks from the hibernate module.// Write the output clock configuration for devices that support// Set the hibernation clocking configuration.// to switch to it.// Must be sure that the 32KHz clock is enabled if the hibernate is about// Set the new configuration bits.// Clear the current configuration bits.//! circuit.//! size of the filter capacitor that is used with the external crystal//! used.  These settings optimizes the oscillator drive strength to match the//! used, either the \b HIBERNATE_OSC_HIGHDRIVE or \b HIBERNATE_OSC_LOWDRIVE is//! instead of a 32.768-kHz crystal.  In the case where an external crystal is//! internal oscillator if an external clock source or no clock source is used//! The \b HIBERNATE_OSC_DISABLE option is used to disable and power down the//!      clock.//! - \b HIBERNATE_OUT_SYSCLK enables the hibernate clock output to the system//! The \e ui32Config parameter can have any combination of the following//! clocked by the ALT clock outputs from the Hibernation module.//! hibernate section in the datasheet to determine which peripherals can be//! clock settings allow clocking a subset of the peripherals.  See the//! hibernation is used to clock other peripherals in the system.  The ALT//! This \e ui32Config also configures how the clock output from the//! frequency oscillator as the clock to the Hibernation module.//! - \b HIBERNATE_OSC_LFIOSC enables the Hibernation module's internal low//! the Hibernation module.//! \b HIBERNATE_OSC_LFIOSC value enables the LFIOSC as the clock source to//! used when the system requires a real time counter.  Adding the//! Because of the low accuracy of this oscillator, this option should not be//! oscillator (LFIOSC) as the clock source for the Hibernation module.//! On some devices, there is an option to use an internal low frequency//! filter capacitor is used with a crystal.//! - \b HIBERNATE_OSC_LOWDRIVE specifies a lower drive strength when a 12-pF//! - \b HIBERNATE_OSC_HIGHDRIVE specifies a higher drive strength when a 24-pF//! devices that have an LFIOSC in the Hibernation module.//! is connected to the XOSC0 pin or to save power when the LFIOSC is used in//! is powered off.  This option is used when an externally supplied oscillator//! - \b HIBERNATE_OSC_DISABLE specifies that the internal oscillator//! module.  The \e ui32Config parameter can be one of the following values://! This function is used to configure the clock input for the Hibernation//! clock input listed below.//! \param ui32Config is one of the possible configuration options for the//! Configures the clock input for the Hibernation module.// Turn off the clock enable bit.//! called, none of the Hibernation module features are available.//! This function disables the Hibernation module.  After this function is//! Disables the Hibernation module for operation.// Wait for write complete following register load (above).// Turn on the clock enable bit.//! variable call holding the return value of SysCtlClockFreqSet()).//! code/execution overhead of a call to SysCtlClockGet() or fetch of the //! or it can be explicitly hard coded if it is constant and known (to save the//! devices or the value returned by SysCtlClockFreqSet() for TM4C129x devices,//! the system clock is the value returned by SysCtlClockGet() for TM4C123x//! The peripheral clock is the same as the processor clock.  The frequency of//! should be called before any of the Hibernation module features are used.//! This function enables the Hibernation module for operation.  This function//! \param ui32HibClk is the rate of the clock supplied to the Hibernation//! Enables the Hibernation module for operation.//! to perform another write to the module.//! polls this bit and returns as soon as it is set.  At this point, it is safe//! This mechanism is used to pace writes to the module.  This function merely//! The Hibernation module provides an indication when any write is completed.//! \param None.//! is set.//! Polls until the write complete (WRC) bit in the hibernate control register// pins.// A macro used to determine whether the target part supports Wake from IO// The number of processor cycles to execute one pass of the delay loop.// The delay in microseconds for writing to the Hibernation module registers.//! \addtogroup hibernate_api// hibernate.c - Driver for the Hibernation module/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/inc/hw_i2c.hI2C_PC_HSI2C_PP_HSI2C_FIFOSTATUS_TXFEI2C_FIFOSTATUS_TXFFI2C_FIFOSTATUS_TXBLWTRIGI2C_FIFOSTATUS_RXFEI2C_FIFOSTATUS_RXFFI2C_FIFOSTATUS_RXABVTRIGI2C_FIFOCTL_TXTRIG_SI2C_FIFOCTL_RXTRIG_SI2C_FIFOCTL_TXTRIG_MI2C_FIFOCTL_DMATXENAI2C_FIFOCTL_TXFLUSHI2C_FIFOCTL_TXASGNMTI2C_FIFOCTL_RXTRIG_MI2C_FIFOCTL_DMARXENAI2C_FIFOCTL_RXFLUSHI2C_FIFOCTL_RXASGNMTI2C_FIFODATA_DATA_SI2C_FIFODATA_DATA_MI2C_SACKCTL_ACKOENI2C_SACKCTL_ACKOVALI2C_SOAR2_OAR2_SI2C_SOAR2_OAR2_MI2C_SOAR2_OAR2ENI2C_SICR_DATAICI2C_SICR_STARTICI2C_SICR_STOPICI2C_SICR_DMARXICI2C_SICR_DMATXICI2C_SICR_TXICI2C_SICR_RXICI2C_SICR_TXFEICI2C_SICR_RXFFICI2C_SMIS_DATAMISI2C_SMIS_STARTMISI2C_SMIS_STOPMISI2C_SMIS_DMARXMISI2C_SMIS_DMATXMISI2C_SMIS_TXMISI2C_SMIS_RXMISI2C_SMIS_TXFEMISI2C_SMIS_RXFFMISI2C_SRIS_DATARISI2C_SRIS_STARTRISI2C_SRIS_STOPRISI2C_SRIS_DMARXRISI2C_SRIS_DMATXRISI2C_SRIS_TXRISI2C_SRIS_RXRISI2C_SRIS_TXFERISI2C_SRIS_RXFFRISI2C_SIMR_DATAIMI2C_SIMR_STARTIMI2C_SIMR_STOPIMI2C_SIMR_DMARXIMI2C_SIMR_DMATXIMI2C_SIMR_TXIMI2C_SIMR_RXIMI2C_SIMR_TXFEIMI2C_SIMR_RXFFIMI2C_SDR_DATA_SI2C_SDR_DATA_MI2C_SCSR_RREQI2C_SCSR_DAI2C_SCSR_TREQI2C_SCSR_TXFIFOI2C_SCSR_RXFIFOI2C_SCSR_FBRI2C_SCSR_OAR2SELI2C_SCSR_QCMDSTI2C_SCSR_QCMDRWI2C_SCSR_ACTDMATXI2C_SCSR_ACTDMARXI2C_SOAR_OAR_SI2C_SOAR_OAR_MI2C_MCR2_GFPW_31I2C_MCR2_GFPW_16I2C_MCR2_GFPW_8I2C_MCR2_GFPW_4I2C_MCR2_GFPW_3I2C_MCR2_GFPW_2I2C_MCR2_GFPW_1I2C_MCR2_GFPW_BYPASSI2C_MCR2_GFPW_MI2C_MBCNT_CNTL_SI2C_MBCNT_CNTL_MI2C_MBLEN_CNTL_SI2C_MBLEN_CNTL_MI2C_MBMON_SCLI2C_MBMON_SDAI2C_MCLKOCNT_CNTL_SI2C_MCLKOCNT_CNTL_MI2C_MCR_LPBKI2C_MCR_MFEI2C_MCR_SFEI2C_MCR_GFEI2C_MICR_ICI2C_MICR_CLKICI2C_MICR_DMARXICI2C_MICR_DMATXICI2C_MICR_NACKICI2C_MICR_STARTICI2C_MICR_STOPICI2C_MICR_ARBLOSTICI2C_MICR_TXICI2C_MICR_RXICI2C_MICR_TXFEICI2C_MICR_RXFFICI2C_MMIS_MISI2C_MMIS_CLKMISI2C_MMIS_DMARXMISI2C_MMIS_DMATXMISI2C_MMIS_NACKMISI2C_MMIS_STARTMISI2C_MMIS_STOPMISI2C_MMIS_ARBLOSTMISI2C_MMIS_TXMISI2C_MMIS_RXMISI2C_MMIS_TXFEMISI2C_MMIS_RXFFMISI2C_MRIS_RISI2C_MRIS_CLKRISI2C_MRIS_DMARXRISI2C_MRIS_DMATXRISI2C_MRIS_NACKRISI2C_MRIS_STARTRISI2C_MRIS_STOPRISI2C_MRIS_ARBLOSTRISI2C_MRIS_TXRISI2C_MRIS_RXRISI2C_MRIS_TXFERISI2C_MRIS_RXFFRISI2C_MIMR_IMI2C_MIMR_CLKIMI2C_MIMR_DMARXIMI2C_MIMR_DMATXIMI2C_MIMR_NACKIMI2C_MIMR_STARTIMI2C_MIMR_STOPIMI2C_MIMR_ARBLOSTIMI2C_MIMR_TXIMI2C_MIMR_RXIMI2C_MIMR_TXFEIMI2C_MIMR_RXFFIMI2C_MTPR_TPR_SI2C_MTPR_TPR_MI2C_MTPR_HSI2C_MTPR_PULSEL_31I2C_MTPR_PULSEL_16I2C_MTPR_PULSEL_8I2C_MTPR_PULSEL_4I2C_MTPR_PULSEL_3I2C_MTPR_PULSEL_2I2C_MTPR_PULSEL_1I2C_MTPR_PULSEL_BYPASSI2C_MTPR_PULSEL_MI2C_MDR_DATA_SI2C_MDR_DATA_MI2C_MCS_BUSYI2C_MCS_RUNI2C_MCS_STARTI2C_MCS_ERRORI2C_MCS_STOPI2C_MCS_ADRACKI2C_MCS_DATACKI2C_MCS_ACKI2C_MCS_HSI2C_MCS_ARBLSTI2C_MCS_QCMDI2C_MCS_IDLEI2C_MCS_BUSBSYI2C_MCS_BURSTI2C_MCS_CLKTOI2C_MCS_ACTDMATXI2C_MCS_ACTDMARXI2C_MSA_SA_SI2C_MSA_RSI2C_MSA_SA_M0x000000FEI2C_O_PCI2C_O_PPI2C_O_FIFOSTATUS0x00000F08I2C_O_FIFOCTL0x00000F04I2C_O_FIFODATAI2C_O_SACKCTLI2C_O_SOAR20x0000081CI2C_O_SICR0x00000818I2C_O_SMIS0x00000814I2C_O_SRIS0x00000810I2C_O_SIMR0x0000080CI2C_O_SDR0x00000808I2C_O_SCSR0x00000804I2C_O_SOARI2C_O_MCR2I2C_O_MBCNTI2C_O_MBLENI2C_O_MBMONI2C_O_MCLKOCNTI2C_O_MCRI2C_O_MICRI2C_O_MMISI2C_O_MRISI2C_O_MIMRI2C_O_MTPRI2C_O_MDRI2C_O_MCSI2C_O_MSA__HW_I2C_H__// __HW_I2C_H__// High-Speed Capable// The following are defines for the bit fields in the I2C_O_PC register.// The following are defines for the bit fields in the I2C_O_PP register.// TX FIFO Empty// TX FIFO Full// TX FIFO Below Trigger Level// RX FIFO Above Trigger Level// The following are defines for the bit fields in the I2C_O_FIFOSTATUS// TX FIFO Trigger// DMA TX Channel Enable// TX FIFO Flush// TX Control Assignment// RX FIFO Trigger// DMA RX Channel Enable// RX FIFO Flush// RX Control Assignment// The following are defines for the bit fields in the I2C_O_FIFOCTL register.// I2C TX FIFO Write Data Byte// The following are defines for the bit fields in the I2C_O_FIFODATA register.// I2C Slave ACK Override Enable// I2C Slave ACK Override Value// The following are defines for the bit fields in the I2C_O_SACKCTL register.// I2C Slave Own Address 2// I2C Slave Own Address 2 Enable// The following are defines for the bit fields in the I2C_O_SOAR2 register.// Data Interrupt Clear// Start Condition Interrupt Clear// Stop Condition Interrupt Clear// Receive DMA Interrupt Clear// Transmit DMA Interrupt Clear// Transmit Request Interrupt Mask// Receive Request Interrupt Mask// Transmit FIFO Empty Interrupt// Receive FIFO Full Interrupt Mask// The following are defines for the bit fields in the I2C_O_SICR register.// Data Masked Interrupt Status// Start Condition Masked Interrupt// Stop Condition Masked Interrupt// Receive DMA Masked Interrupt// Transmit DMA Masked Interrupt// Transmit FIFO Request Interrupt// Receive FIFO Request Interrupt// The following are defines for the bit fields in the I2C_O_SMIS register.// Data Raw Interrupt Status// Start Condition Raw Interrupt// Stop Condition Raw Interrupt// Receive DMA Raw Interrupt Status// Transmit DMA Raw Interrupt// Transmit Request Raw Interrupt// Receive FIFO Request Raw// Transmit FIFO Empty Raw// Receive FIFO Full Raw Interrupt// The following are defines for the bit fields in the I2C_O_SRIS register.// Data Interrupt Mask// Start Condition Interrupt Mask// Stop Condition Interrupt Mask// Receive DMA Interrupt Mask// Transmit DMA Interrupt Mask// The following are defines for the bit fields in the I2C_O_SIMR register.// Data for Transfer// The following are defines for the bit fields in the I2C_O_SDR register.// Receive Request// Device Active// TX FIFO Enable// RX FIFO Enable// First Byte Received// OAR2 Address Matched// Quick Command Status// Quick Command Read / Write// DMA TX Active Status// DMA RX Active Status// The following are defines for the bit fields in the I2C_O_SCSR register.// I2C Slave Own Address// The following are defines for the bit fields in the I2C_O_SOAR register.// 31 clocks// 16 clocks// 8 clocks// 4 clocks// 3 clocks// 2 clocks// 1 clock// Bypass// I2C Glitch Filter Pulse Width// The following are defines for the bit fields in the I2C_O_MCR2 register.// I2C Master Burst Count// The following are defines for the bit fields in the I2C_O_MBCNT register.// I2C Burst Length// The following are defines for the bit fields in the I2C_O_MBLEN register.// I2C SCL Status// I2C SDA Status// The following are defines for the bit fields in the I2C_O_MBMON register.// I2C Master Count// The following are defines for the bit fields in the I2C_O_MCLKOCNT register.// I2C Loopback// I2C Master Function Enable// I2C Slave Function Enable// I2C Glitch Filter Enable// The following are defines for the bit fields in the I2C_O_MCR register.// Master Interrupt Clear// Clock Timeout Interrupt Clear// Address/Data NACK Interrupt// START Detection Interrupt Clear// STOP Detection Interrupt Clear// Arbitration Lost Interrupt Clear// Receive FIFO Full Interrupt// The following are defines for the bit fields in the I2C_O_MICR register.// Masked Interrupt Status// Clock Timeout Masked Interrupt// Receive DMA Interrupt Status// Transmit DMA Interrupt Status// Address/Data NACK Interrupt Mask// START Detection Interrupt Mask// STOP Detection Interrupt Mask// Arbitration Lost Interrupt Mask// The following are defines for the bit fields in the I2C_O_MMIS register.// Master Raw Interrupt Status// Clock Timeout Raw Interrupt// Address/Data NACK Raw Interrupt// START Detection Raw Interrupt// STOP Detection Raw Interrupt// Arbitration Lost Raw Interrupt// The following are defines for the bit fields in the I2C_O_MRIS register.// Master Interrupt Mask// Clock Timeout Interrupt Mask// The following are defines for the bit fields in the I2C_O_MIMR register.// Timer Period// High-Speed Enable// Glitch Suppression Pulse Width// The following are defines for the bit fields in the I2C_O_MTPR register.// transferred during a transaction// This byte contains the data// The following are defines for the bit fields in the I2C_O_MDR register.// I2C Busy// I2C Master Enable// Generate START// Error// Generate STOP// Acknowledge Address// Acknowledge Data// Data Acknowledge Enable// Arbitration Lost// Quick Command// I2C Idle// Bus Busy// Burst Enable// Clock Timeout Error// The following are defines for the bit fields in the I2C_O_MCS register.// Receive not send// I2C Slave Address// The following are defines for the bit fields in the I2C_O_MSA register.// I2C Peripheral Configuration// I2C Peripheral Properties// I2C FIFO Status// I2C FIFO Control// I2C FIFO Data// I2C Slave ACK Control// I2C Slave Interrupt Clear// I2C Slave Masked Interrupt// I2C Slave Raw Interrupt Status// I2C Slave Interrupt Mask// I2C Slave Data// I2C Slave Control/Status// I2C Master Configuration 2// I2C Master Burst Length// I2C Master Bus Monitor// I2C Master Clock Low Timeout// I2C Master Configuration// I2C Master Interrupt Clear// I2C Master Masked Interrupt// I2C Master Raw Interrupt Status// I2C Master Interrupt Mask// I2C Master Timer Period// I2C Master Data// I2C Master Control/Status// I2C Master Slave Address// The following are defines for the I2C register offsets.// hw_i2c.h - Macros used when accessing the I2C master and slave hardware./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/i2c.hI2C_FIFO_TX_EMPTYI2C_FIFO_TX_FULLI2C_FIFO_TX_BELOW_TRIG_LEVELI2C_FIFO_RX_EMPTYI2C_FIFO_RX_FULLI2C_FIFO_RX_BELOW_TRIG_LEVELI2C_FIFO_CFG_RX_TRIG_8I2C_FIFO_CFG_RX_TRIG_7I2C_FIFO_CFG_RX_TRIG_6I2C_FIFO_CFG_RX_TRIG_5I2C_FIFO_CFG_RX_TRIG_4I2C_FIFO_CFG_RX_TRIG_3I2C_FIFO_CFG_RX_TRIG_2I2C_FIFO_CFG_RX_TRIG_1I2C_FIFO_CFG_RX_NO_TRIGI2C_FIFO_CFG_TX_TRIG_8I2C_FIFO_CFG_TX_TRIG_7I2C_FIFO_CFG_TX_TRIG_6I2C_FIFO_CFG_TX_TRIG_5I2C_FIFO_CFG_TX_TRIG_4I2C_FIFO_CFG_TX_TRIG_3I2C_FIFO_CFG_TX_TRIG_2I2C_FIFO_CFG_TX_TRIG_1I2C_FIFO_CFG_TX_NO_TRIGI2C_FIFO_CFG_RX_SLAVE_DMA0xa0000000I2C_FIFO_CFG_RX_MASTER_DMAI2C_FIFO_CFG_TX_SLAVE_DMA0x0000a000I2C_FIFO_CFG_TX_MASTER_DMAI2C_FIFO_CFG_RX_SLAVEI2C_FIFO_CFG_RX_MASTERI2C_FIFO_CFG_TX_SLAVEI2C_FIFO_CFG_TX_MASTERI2C_SLAVE_RX_FIFO_ENABLEI2C_SLAVE_TX_FIFO_ENABLEI2C_SLAVE_INT_DATAI2C_SLAVE_INT_STARTI2C_SLAVE_INT_STOPI2C_SLAVE_INT_RX_DMA_DONEI2C_SLAVE_INT_TX_DMA_DONEI2C_SLAVE_INT_TX_FIFO_REQI2C_SLAVE_INT_RX_FIFO_REQI2C_SLAVE_INT_TX_FIFO_EMPTYI2C_SLAVE_INT_RX_FIFO_FULLI2C_MASTER_INT_DATAI2C_MASTER_INT_TIMEOUTI2C_MASTER_INT_RX_DMA_DONEI2C_MASTER_INT_TX_DMA_DONEI2C_MASTER_INT_NACKI2C_MASTER_INT_STARTI2C_MASTER_INT_STOPI2C_MASTER_INT_ARB_LOSTI2C_MASTER_INT_TX_FIFO_REQI2C_MASTER_INT_RX_FIFO_REQI2C_MASTER_INT_TX_FIFO_EMPTYI2C_MASTER_INT_RX_FIFO_FULLI2C_MASTER_MAX_RETRIESI2C_SLAVE_ACT_QCMD_DATAI2C_SLAVE_ACT_QCMDI2C_SLAVE_ACT_OWN2SELI2C_SLAVE_ACT_RREQ_FBRI2C_SLAVE_ACT_TREQI2C_SLAVE_ACT_RREQI2C_SLAVE_ACT_NONEI2C_MASTER_ERR_CLK_TOUTI2C_MASTER_ERR_ARB_LOSTI2C_MASTER_ERR_DATA_ACKI2C_MASTER_ERR_ADDR_ACKI2C_MASTER_ERR_NONEI2C_MASTER_GLITCH_FILTER_32I2C_MASTER_GLITCH_FILTER_16I2C_MASTER_GLITCH_FILTER_8I2C_MASTER_GLITCH_FILTER_4I2C_MASTER_GLITCH_FILTER_3I2C_MASTER_GLITCH_FILTER_2I2C_MASTER_GLITCH_FILTER_1I2C_MASTER_GLITCH_FILTER_DISABLEDI2C_MASTER_CMD_FIFO_BURST_RECEIVE_ERROR_STOPI2C_MASTER_CMD_FIFO_BURST_RECEIVE_FINISHI2C_MASTER_CMD_FIFO_BURST_RECEIVE_CONTI2C_MASTER_CMD_FIFO_BURST_RECEIVE_START0x0000004aI2C_MASTER_CMD_FIFO_BURST_SEND_ERROR_STOPI2C_MASTER_CMD_FIFO_BURST_SEND_FINISHI2C_MASTER_CMD_FIFO_BURST_SEND_CONTI2C_MASTER_CMD_FIFO_BURST_SEND_START0x00000042I2C_MASTER_CMD_FIFO_SINGLE_RECEIVE0x00000046I2C_MASTER_CMD_FIFO_SINGLE_SENDI2C_MASTER_CMD_HS_MASTER_CODE_SENDI2C_MASTER_CMD_QUICK_COMMAND0x00000027I2C_MASTER_CMD_BURST_RECEIVE_ERROR_STOPI2C_MASTER_CMD_BURST_RECEIVE_FINISHI2C_MASTER_CMD_BURST_RECEIVE_CONTI2C_MASTER_CMD_BURST_RECEIVE_START0x0000000bI2C_MASTER_CMD_BURST_SEND_ERROR_STOPI2C_MASTER_CMD_BURST_SEND_STOPI2C_MASTER_CMD_BURST_SEND_FINISHI2C_MASTER_CMD_BURST_SEND_CONTI2C_MASTER_CMD_BURST_SEND_STARTI2C_MASTER_CMD_SINGLE_RECEIVEI2C_MASTER_CMD_SINGLE_SENDI2C_INT_SLAVEI2C_INT_MASTER__DRIVERLIB_I2C_H__I2CLoopbackEnableI2CSlaveStatusI2CSlaveIntStatusExI2CSlaveIntStatusI2CSlaveIntEnableExI2CSlaveIntDisableExI2CSlaveIntClearExI2CSlaveIntEnableI2CSlaveIntDisableI2CSlaveIntClearI2CSlaveAddressSetI2CSlaveInitI2CSlaveEnableI2CSlaveDisableI2CSlaveDataPutI2CSlaveDataGetI2CMasterSlaveAddrSetI2CMasterLineStateGetI2CSlaveACKValueSetI2CSlaveACKOverrideI2CMasterTimeoutSetI2CMasterIntClearExI2CMasterIntStatusExI2CMasterIntDisableExI2CMasterIntEnableExI2CMasterIntStatusI2CMasterIntEnableI2CMasterIntDisableI2CMasterIntClearI2CMasterInitExpClkI2CMasterErrI2CMasterEnableI2CMasterDisableI2CMasterDataPutI2CMasterDataGetI2CMasterControlI2CMasterBusyI2CMasterBusBusyI2CSlaveFIFODisableI2CSlaveFIFOEnableI2CMasterGlitchFilterConfigSetI2CMasterBurstCountGetI2CMasterBurstLengthSetI2CFIFODataGetNonBlockingI2CFIFODataGetI2CFIFODataPutNonBlockingI2CFIFODataPutI2CFIFOStatusI2CRxFIFOFlushI2CRxFIFOConfigSetI2CTxFIFOFlushI2CTxFIFOConfigSetI2CIntUnregisterI2CIntRegister// __DRIVERLIB_I2C_H__// I2C FIFO status.// I2C FIFO configuration macros.// I2C Slave FIFO configuration macros.// Data Interrupt// Start Condition Interrupt// Stop Condition Interrupt// RX DMA Complete Interrupt// TX DMA Complete Interrupt// TX FIFO Request Interrupt// RX FIFO Request Interrupt// TX FIFO Empty Interrupt// RX FIFO Full Interrupt// I2C Slave interrupts.// Clock Timeout Interrupt// Addr/Data NACK Interrupt// Arb Lost Interrupt// I2C Master interrupts.// Number of retries// Miscellaneous I2C driver definitions.// Master Quick Command value// Master has sent a Quick Command// Master requested secondary slave// Master has sent first byte// Master has requested data// Master has sent data// I2C Slave action requests// I2C Master error status.// I2C Master glitch filter configuration.// I2C Master commands.// Interrupt defines.// Defines for the API.// i2c.h - Prototypes for the I2C Driver.ui8AddrNumui8SlaveAddrbReceivebACKbEnableui32I2CClkbFastui32Cmdui8Length/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/i2c.c"driverlib/i2c.h""inc/hw_i2c.h"ui32Base + I2C_O_MCR_I2CBaseValid(ui32Base)ui32Base + I2C_O_SCSRui32Base + 0x000008042052ui32Base + I2C_O_MTPRui32Base + I2C_O_MCR2ui32Base + I2C_O_MBCNTui32Base + I2C_O_MBLEN_I2CBaseValid(ui32Base) && (ui8Length < 256)ui32Base + I2C_O_FIFOSTATUSui32Base + 0x00000F08ui32Base + I2C_O_FIFODATAui32Base + 0x00000F003848(1)ui32Base + I2C_O_FIFOCTLui32Base + 0x00000F043844ui32Base + I2C_O_SDRui32Base + 0x000008082056ui32Base + I2C_O_SACKCTLui32Base + 0x000008202080~I2C_SACKCTL_ACKOVAL~I2C_SACKCTL_ACKOENui32Base + I2C_O_MCLKOCNTui32Base + I2C_O_MDRui32Errui32Base + I2C_O_MCS(I2C_MASTER_ERR_NONE)(I2C_MCS_ERROR | I2C_MCS_ARBLST)(I2C_MCS_ARBLST | I2C_MCS_DATACK | I2C_MCS_ADRACK)(ui32Cmd == I2C_MASTER_CMD_SINGLE_SEND) || (ui32Cmd == I2C_MASTER_CMD_SINGLE_RECEIVE) || (ui32Cmd == I2C_MASTER_CMD_BURST_SEND_START) || (ui32Cmd == I2C_MASTER_CMD_BURST_SEND_CONT) || (ui32Cmd == I2C_MASTER_CMD_BURST_SEND_FINISH) || (ui32Cmd == I2C_MASTER_CMD_BURST_SEND_ERROR_STOP) || (ui32Cmd == I2C_MASTER_CMD_BURST_RECEIVE_START) || (ui32Cmd == I2C_MASTER_CMD_BURST_RECEIVE_CONT) || (ui32Cmd == I2C_MASTER_CMD_BURST_RECEIVE_FINISH) || (ui32Cmd == I2C_MASTER_CMD_BURST_RECEIVE_ERROR_STOP) || (ui32Cmd == I2C_MASTER_CMD_QUICK_COMMAND) || (ui32Cmd == I2C_MASTER_CMD_FIFO_SINGLE_SEND) || (ui32Cmd == I2C_MASTER_CMD_FIFO_SINGLE_RECEIVE) || (ui32Cmd == I2C_MASTER_CMD_FIFO_BURST_SEND_START) || (ui32Cmd == I2C_MASTER_CMD_FIFO_BURST_SEND_CONT) || (ui32Cmd == I2C_MASTER_CMD_FIFO_BURST_SEND_FINISH) || (ui32Cmd == I2C_MASTER_CMD_FIFO_BURST_SEND_ERROR_STOP) || (ui32Cmd == I2C_MASTER_CMD_FIFO_BURST_RECEIVE_START) || (ui32Cmd == I2C_MASTER_CMD_FIFO_BURST_RECEIVE_CONT) || (ui32Cmd == I2C_MASTER_CMD_FIFO_BURST_RECEIVE_FINISH) || (ui32Cmd == I2C_MASTER_CMD_FIFO_BURST_RECEIVE_ERROR_STOP) || (ui32Cmd == I2C_MASTER_CMD_HS_MASTER_CODE_SEND)ui32Base + I2C_O_MBMONui32Base + I2C_O_MSA!(ui8SlaveAddr & 0x80)ui32Base + I2C_O_SICRui32Base + 0x000008182072ui32Base + I2C_O_MICRui32Base + I2C_O_MMISui32Base + I2C_O_SMISui32Base + 0x00000814ui32Base + I2C_O_SRISui32Base + 0x0000081020682064ui32Base + I2C_O_MRISui32Base + I2C_O_SIMRui32Base + 0x0000080C2060~I2C_SLAVE_INT_DATAui32Base + I2C_O_MIMR(I2C_MCR_SFE)~(I2C_MCR_SFE)(I2C_MCR_MFE)~(I2C_MCR_MFE)ui32Base + I2C_O_SOARui32Base + 0x00000800ui32Base + I2C_O_SOAR2ui32Base + 0x0000081C2076!(ui8AddrNum > 1)ui32SCLFrequi32TPR4000001000002 * 10ui32Base + I2C_O_PPui32Base + 0x00000FC040322 * 33400000204000002 * 3 * 3400000(2 * 3 * 3400000)_I2CIntNumberGeti8Idxi8Rowsppui32I2CIntMapconst uint32_t[6][2]unsigned long[6][2]const int_fast8_tg_i8I2CIntMapRowsconst uint32_t[10][2]unsigned long[10][2]g_i8I2CIntMapSnowflakeRowssizeof(g_ppui32I2CIntMapSnowflake)sizeof(g_ppui32I2CIntMapSnowflake[0])sizeof(g_ppui32I2CIntMapSnowflake) / sizeof(g_ppui32I2CIntMapSnowflake[0])g_ppui32I2CIntMapSnowflake1073872896I2C0_BASE1073876992I2C1_BASE1073881088I2C2_BASE1073885184I2C3_BASE1074528256I2C4_BASE1074532352I2C5_BASE1074536448I2C6_BASE1074540544I2C7_BASE1074495488I2C8_BASE1074499584I2C9_BASEsizeof(g_ppui32I2CIntMap)sizeof(g_ppui32I2CIntMap[0])sizeof(g_ppui32I2CIntMap) / sizeof(g_ppui32I2CIntMap[0])g_ppui32I2CIntMap// Write the loopback enable bit to the register.//! I2CMasterDataGet(),I2CSlaveDataGet() can be used along with this function.//! without having to go through I/O's.  I2CMasterDataPut(), I2CSlaveDataPut(),//! transferred between the master and slave modules of the same I2C port,//! and slave modules are internally connected.  This allows data to be//! diagnostics and debug.  In this mode, the SDA and SCL signals from master//! This function configures an I2C port in internal loopback mode to help with//! \param ui32Base is the base address of the I2C module.//! Enables internal loopback mode for an I2C port.// Disable slave FIFOs.//! device data sheet to determine if this feature is supported.//! \note Not all Tiva devices have an I2C FIFO.  Please consult the//! this function, the FIFOs are disabled, but the Slave remains active.//! This function disables the FIFOs for the I2C Slave.  After calling this//! Disable FIFO usage for the I2C Slave.// Enable the FIFOs for the slave.//! I2CSlaveFIFOEnable() with the desired FIFO configuration.//! Therefore, application software should call I2CSlaveEnable() followed by//! I2CSlaveDisable or I2CSlaveFIFOEnable() overwrites the slave configuration.//! The Slave I2CSCSR register is write-only, so any call to I2CSlaveEnable(),//! field.//! \b I2C_SLAVE_RX_FIFO_ENABLE should be passed in to the \e ui32Config//! application appropriate combination of \b I2C_SLAVE_TX_FIFO_ENABLE and//! the FIFO hardware whether to interact with the I2C Master or Slave.  The//! I2CRxFIFOConfigSet(), which configure the FIFO trigger level and tell//! function should be used in combination with I2CTxFIFOConfigSet() and/or//! This function configures the I2C Slave to use the FIFO(s).  This//! \param ui32Config is the desired FIFO configuration of the I2C Slave.//! Enables FIFO usage for the I2C Slave.// Enable the glitch filter by setting the GFE bit// Configure the glitch filter pulse width// Configure the glitch filter if it is TM4C123// Configure the glitch filter field of MTPR if it is TM4C129//! \note Not all Tiva devices support this function.  Please consult the//! - \b I2C_MASTER_GLITCH_FILTER_32//! - \b I2C_MASTER_GLITCH_FILTER_16//! - \b I2C_MASTER_GLITCH_FILTER_8//! - \b I2C_MASTER_GLITCH_FILTER_4//! - \b I2C_MASTER_GLITCH_FILTER_3//! - \b I2C_MASTER_GLITCH_FILTER_2//! - \b I2C_MASTER_GLITCH_FILTER_1//! - \b I2C_MASTER_GLITCH_FILTER_DISABLED//! The \e ui32Config field should be any of the following values://! that it's disabled.//! configuration of the glitch filter is 0 system clock cycles, which means//! is configurable between 1 and 32 system clock cycles.  The default//! to \e ui32Config determines the sampling range of the glitch filter, which//! This function configures the I2C Master glitch filter.  The value passed in//! \param ui32Config is the glitch filter configuration.//! Configures the I2C Master glitch filter.// Get burst count.//! operation was if an error has occurred.//! how many bytes remain in a transfer, or where in the transfer the burst//! is used by the FIFO mechanism.  Software can use this value to determine//! This function returns the current value of the burst transfer counter that//! Returns the current value of the burst transfer counter.// Set the burst length.//! in the I2CMCS using I2CMasterControl().//! operation must configure the burst length prior to writing the BURST bit//! burst length for only the current operation (can be TX or RX).  Each burst//! applies to a single I2CMCS BURST operation meaning that it specifies the//! The burst field is limited to 8 bits or 256 bytes.  The burst length//! This function configures the burst length for a I2C Master FIFO operation.//! \param ui8Length is the length of the burst transfer.//! Set the burst length for a I2C master FIFO operation.// If nothing in the FIFO, return zero.//! \return The number of elements read from the I2C receive FIFO.//! available, this functions returns 0.//! the location specified by the \e pui8Data parameter.  If there is no data//! This function reads a byte of data from I2C receive FIFO and places it in//! \param pui8Data is a pointer where the read data is stored.//! Reads a byte from the I2C receive FIFO.// Read a byte.// Wait until there is data to read.//! \return The data byte.//! available, this function waits until data is received before returning.// If FIFO is full, return zero.//! \return The number of elements added to the I2C transmit FIFO.//! no space available in the FIFO, this function returns a zero.//! This function adds a byte of data to the I2C transmit FIFO.  If there is//! \param ui8Data is the data to be placed into the transmit FIFO.//! Writes a data byte to the I2C transmit FIFO.// Place data into the FIFO.// Wait until there is space.//! available before returning.//! no space available in the FIFO,  this function waits for space to become// Return the contents of the FIFO status register.//! \b I2C_FIFO_TX_EMPTY.//! \b I2C_FIFO_TX_BELOW_TRIG_LEVEL, \b I2C_FIFO_TX_FULL, and//! \b I2C_FIFO_RX_BELOW_TRIG_LEVEL, \b I2C_FIFO_RX_FULL, \b I2C_FIFO_RX_EMPTY,//! \return Returns the FIFO status, enumerated as a bit field containing//! I2CTxFIFOConfigSet() and for the receive FIFO using I2CRxFIFOConfigSet().//! (RX) FIFOs.  The trigger level for the transmit FIFO is set using//! This function retrieves the status for both the transmit (TX) and receive//! Gets the current FIFO status.// Flush the TX FIFO.//! This function flushes the I2C receive FIFO.//! Flushes the receive (RX) FIFO.// Store new receive configuration data.// Clear receive configuration data.//! \b I2C_FIFO_CFG_RX_TRIG_7, \b I2C_FIFO_CFG_RX_TRIG_8//! \b I2C_FIFO_CFG_RX_TRIG_5, \b I2C_FIFO_CFG_RX_TRIG_6,//! \b I2C_FIFO_CFG_RX_TRIG_3, \b I2C_FIFO_CFG_RX_TRIG_4,//! \b I2C_FIFO_CFG_RX_TRIG_1, \b I2C_FIFO_CFG_RX_TRIG_2,//! To select the trigger level, one of the following macros should be used://! \b I2C_FIFO_CFG_RX_MASTER_DMA, \b I2C_FIFO_CFG_RX_SLAVE_DMA//! \b I2C_FIFO_CFG_RX_MASTER, \b I2C_FIFO_CFG_RX_SLAVE,//! to configure the RX FIFO behavior for master or slave, with or without DMA://! used by the master or slave, but not both.  The following macros are used//! This configures the I2C peripheral's receive FIFO.  The receive FIFO can be//! \param ui32Config is the configuration of the FIFO using specified macros.//! Configures the I2C receive (RX) FIFO.//! This function flushes the I2C transmit FIFO.//! Flushes the transmit (TX) FIFO.// Store new transmit configuration data.// Clear transmit configuration data.//! \b I2C_FIFO_CFG_TX_TRIG_7, \b I2C_FIFO_CFG_TX_TRIG_8//! \b I2C_FIFO_CFG_TX_TRIG_5, \b I2C_FIFO_CFG_TX_TRIG_6,//! \b I2C_FIFO_CFG_TX_TRIG_3, \b I2C_FIFO_CFG_TX_TRIG_4,//! \b I2C_FIFO_CFG_TX_TRIG_1, \b I2C_FIFO_CFG_TX_TRIG_2,//! \b I2C_FIFO_CFG_TX_MASTER_DMA, \b I2C_FIFO_CFG_TX_SLAVE_DMA//! \b I2C_FIFO_CFG_TX_MASTER, \b I2C_FIFO_CFG_TX_SLAVE,//! DMA://! used to configure the TX FIFO behavior for master or slave, with or without//! be used by the master or slave, but not both.  The following macros are//! This configures the I2C peripheral's transmit FIFO.  The transmit FIFO can//! Configures the I2C transmit (TX) FIFO.//! uint32_t.//! \return Returns the byte received from by the I2C Slave, cast as an//! This function reads a byte of data from the I2C Slave Data Register.//! Receives a byte that has been sent to the I2C Slave.// Write the byte.//! This function places the supplied data into I2C Slave Data Register.//! \param ui8Data is the data to be transmitted from the I2C Slave//! Transmits a byte from the I2C Slave.// Return the slave status.//! data bit was set when the quick command was received.//! command was received, and \b I2C_SLAVE_ACT_QCMD_DATA to indicate that the//! slave address was matched, \b I2C_SLAVE_ACT_QCMD to indicate that a quick//! has been received, \b I2C_SLAVE_ACT_OWN2SEL to indicate that the second I2C//! data to the I2C slave and the first byte following the slave's own address//! data, \b I2C_SLAVE_ACT_RREQ_FBR to indicate that an I2C master has sent//! to indicate that an I2C master has requested that the I2C Slave send//! an I2C master has sent data to the I2C Slave, \b I2C_SLAVE_ACT_TREQ//! requested of the I2C Slave, \b I2C_SLAVE_ACT_RREQ to indicate that//! \return Returns \b I2C_SLAVE_ACT_NONE to indicate that no action has been//! determine if these features are supported.//! or the quick command function.  Please consult the device data sheet to//! \note Not all Tiva devices support the second I2C slave's own address//! - \b I2C_SLAVE_ACT_QCMD_DATA//! - \b I2C_SLAVE_ACT_QCMD//! - \b I2C_SLAVE_ACT_OWN2SEL//! - \b I2C_SLAVE_ACT_RREQ_FBR//! - \b I2C_SLAVE_ACT_TREQ//! - \b I2C_SLAVE_ACT_RREQ//! - \b I2C_SLAVE_ACT_NONE//! Possible values are://! This function returns the action requested from a master, if any.//! Gets the I2C Slave status// ACK or NACK based on the value of bACK.//! I2CSlaveACKOverride().//! value written is only valid when ACK override is enabled using//! This function puts the desired ACK value on SDA during the ACK cycle.  The//! \param bACK chooses whether to ACK (true) or NACK (false) the transfer.//! Writes the ACK value.// Enable or disable based on bEnable.//! application to drive the value on SDA during the ACK cycle.//! This function enables or disables ACK override, allowing the user//! \param bEnable enables or disables ACK override.//! Configures ACK override behavior of the I2C Slave.// Write the timeout value.//! with a 100-kHz SCL frequency, \e ui32Value is 0x7d.//! upper 8-bits being programmable.  For example, to program a timeout of 20ms//! I2C peripheral.  This feature is implemented as a 12-bit counter, with the//! This function enables and configures the clock low timeout feature in the//!        asserted.//! \param ui32Value is the number of I2C clocks before the timeout is//! Sets the Master clock timeout value.//! \return Returns the byte received from by the I2C Master, cast as an//! This function reads a byte of data from the I2C Master Data Register.//! Receives a byte that has been sent to the I2C Master.//! This function places the supplied data into I2C Master Data Register.//! \param ui8Data data to be transmitted from the I2C Master.//! Transmits a byte from the I2C Master.// Check for errors.// don't have an error to report.// If the I2C master is busy, then all the other bit are invalid, and// Get the raw error state//! \b I2C_MASTER_ERR_ARB_LOST.//! \b I2C_MASTER_ERR_ADDR_ACK, \b I2C_MASTER_ERR_DATA_ACK, or//! \return Returns the error status, as one of \b I2C_MASTER_ERR_NONE,//! and receive operations.//! This function is used to obtain the error status of the Master send//! Gets the error status of the I2C Master.// Send the command.//! feature is supported.//! commands.  Please consult the device data sheet to determine if this//! \note Not all Tiva devices have an I2C FIFO and support the FIFO//! - \b I2C_MASTER_CMD_FIFO_BURST_RECEIVE_ERROR_STOP//! - \b I2C_MASTER_CMD_FIFO_BURST_RECEIVE_FINISH//! - \b I2C_MASTER_CMD_FIFO_BURST_RECEIVE_CONT//! - \b I2C_MASTER_CMD_FIFO_BURST_RECEIVE_START//! - \b I2C_MASTER_CMD_FIFO_BURST_SEND_ERROR_STOP//! - \b I2C_MASTER_CMD_FIFO_BURST_SEND_FINISH//! - \b I2C_MASTER_CMD_FIFO_BURST_SEND_CONT//! - \b I2C_MASTER_CMD_FIFO_BURST_SEND_START//! - \b I2C_MASTER_CMD_FIFO_SINGLE_RECEIVE//! - \b I2C_MASTER_CMD_FIFO_SINGLE_SEND//! - \b I2C_MASTER_CMD_HS_MASTER_CODE_SEND//! - \b I2C_MASTER_CMD_QUICK_COMMAND//! - \b I2C_MASTER_CMD_BURST_RECEIVE_ERROR_STOP//! - \b I2C_MASTER_CMD_BURST_RECEIVE_FINISH//! - \b I2C_MASTER_CMD_BURST_RECEIVE_CONT//! - \b I2C_MASTER_CMD_BURST_RECEIVE_START//! - \b I2C_MASTER_CMD_BURST_SEND_ERROR_STOP//! - \b I2C_MASTER_CMD_BURST_SEND_FINISH//! - \b I2C_MASTER_CMD_BURST_SEND_CONT//! - \b I2C_MASTER_CMD_BURST_SEND_START//! - \b I2C_MASTER_CMD_SINGLE_RECEIVE//! - \b I2C_MASTER_CMD_SINGLE_SEND//! receive operations.  The \e ui8Cmd parameter can be one of the following//! This function is used to control the state of the Master send and//! \param ui32Cmd command to be issued to the I2C Master.//! Controls the state of the I2C Master.// Return the bus busy status.//! \b false.//! \return Returns \b true if the I2C bus is busy; otherwise, returns//! another master is currently using the bus.//! This function can be used in a multi-master environment to determine if//! This function returns an indication of whether or not the I2C bus is busy.//! Indicates whether or not the I2C bus is busy.// Return the busy status.//! \return Returns \b true if the I2C Master is busy; otherwise, returns//! busy transmitting or receiving data.//! This function returns an indication of whether or not the I2C Master is//! Indicates whether or not the I2C Master is busy.// Return the line state.//! bit position 0.//! \return Returns the state of the bus with SDA in bit position 1 and SCL in//! values of the SDA and SCL pins.//! This function returns the state of the I2C bus by providing the real time//! Reads the state of the SDA and SCL pins.// Set the address of the slave with which the master will communicate.//! Master is initiating a write to the slave.//! read from the slave; otherwise the address indicates that the I2C//! to \b true, the address indicates that the I2C Master is initiating a//! bus when initiating a transaction.  When the \e bReceive parameter is set//! This function configures the address that the I2C Master places on the//! \param bReceive flag indicating the type of communication with the slave//! \param ui8SlaveAddr 7-bit slave address//! Sets the address that the I2C Master places on the bus.// Clear the I2C slave interrupt source.//! \e ui32IntFlags parameter to I2CSlaveIntEnableEx().//! keep the interrupt from being triggered again immediately upon exit.//! longer assert.  This function must be called in the interrupt handler to//! The specified I2C Slave interrupt sources are cleared, so that they no//! \param ui32IntFlags is a bit mask of the interrupt sources to be cleared.//! Clears I2C Slave interrupt sources.//! from being triggered again immediately upon exit.//! This function must be called in the interrupt handler to keep the interrupt//! The I2C Slave interrupt source is cleared, so that it no longer asserts.// Clear the I2C master interrupt source.//! \e ui32IntFlags parameter to I2CMasterIntEnableEx().//! The specified I2C Master interrupt sources are cleared, so that they no//! Clears I2C Master interrupt sources.// harmless (other than the slight performance hit).// devices.  For later devices, this write is ignored and therefore// Workaround for I2C master interrupt clear errata for rev B Tiva//! asserts.  This function must be called in the interrupt handler to keep the//! The I2C Master interrupt source is cleared, so that it no longer//! values described in I2CSlaveIntEnableEx().//! \return Returns the current interrupt status, enumerated as a bit field of//! This function returns the interrupt status for the I2C Slave.//! true if the masked interrupt status is requested.//! \param bMasked is false if the raw interrupt status is requested and//! Gets the current I2C Slave interrupt status.//! or \b false if not active.//! \return The current interrupt status, returned as \b true if active//! values described in I2CMasterIntEnableEx().//! This function returns the interrupt status for the I2C module.//! Gets the current I2C Master interrupt status.// Disable the slave interrupt.//! This function disables the indicated I2C Slave interrupt sources.  Only//!        disabled.//! Disables individual I2C Slave interrupt sources.//! This function disables the I2C Slave interrupt source.//! Disables the I2C Slave interrupt.// Disable the master interrupt.//! This function disables the indicated I2C Master interrupt sources.  Only//! Disables individual I2C Master interrupt sources.//! This function disables the I2C Master interrupt source.//! Disables the I2C Master interrupt.// Enable the slave interrupt.//! supported.//! Please consult the device data sheet to determine if these features are//! \note Not all Tiva devices support the all of the listed interrupts.//! - \b I2C_SLAVE_INT_DATA - Data interrupt//! - \b I2C_SLAVE_INT_START - Start condition detected interrupt//! - \b I2C_SLAVE_INT_STOP - Stop condition detected interrupt//! - \b I2C_SLAVE_INT_RX_DMA_DONE - RX DMA Complete interrupt//! - \b I2C_SLAVE_INT_TX_DMA_DONE - TX DMA Complete interrupt//! - \b I2C_SLAVE_INT_TX_FIFO_REQ - TX FIFO Request interrupt//! - \b I2C_SLAVE_INT_RX_FIFO_REQ - RX FIFO Request interrupt//! - \b I2C_SLAVE_INT_TX_FIFO_EMPTY - TX FIFO Empty interrupt//! - \b I2C_SLAVE_INT_RX_FIFO_FULL - RX FIFO Full interrupt//! This function enables the indicated I2C Slave interrupt sources.  Only the//! Enables individual I2C Slave interrupt sources.//! This function enables the I2C Slave interrupt source.//! Enables the I2C Slave interrupt.// Enable the master interrupt.//! features are supported.//! sources.  Please consult the device data sheet to determine if these//! \note Not all Tiva devices support all of the listed interrupt//! - \b I2C_MASTER_INT_DATA - Data interrupt//! - \b I2C_MASTER_INT_TIMEOUT - Clock Timeout interrupt//! - \b I2C_MASTER_INT_RX_DMA_DONE - RX DMA Complete interrupt//! - \b I2C_MASTER_INT_TX_DMA_DONE - TX DMA Complete interrupt//! - \b I2C_MASTER_INT_NACK - Address/Data NACK interrupt//! - \b I2C_MASTER_INT_START - Start Condition interrupt//! - \b I2C_MASTER_INT_STOP - Stop Condition interrupt//! - \b I2C_MASTER_INT_ARB_LOST - Arbitration Lost interrupt//! - \b I2C_MASTER_INT_TX_FIFO_REQ - TX FIFO Request interrupt//! - \b I2C_MASTER_INT_RX_FIFO_REQ - RX FIFO Request interrupt//! - \b I2C_MASTER_INT_TX_FIFO_EMPTY - TX FIFO Empty interrupt//! - \b I2C_MASTER_INT_RX_FIFO_FULL - RX FIFO Full interrupt//! This function enables the indicated I2C Master interrupt sources.  Only the//! Enables individual I2C Master interrupt sources.//! This function enables the I2C Master interrupt source.//! Enables the I2C Master interrupt.// Determine the interrupt number based on the I2C port.//! occurs.  This function also masks off the interrupt in the interrupt r//! This function clears the handler to be called when an I2C interrupt//! Unregisters an interrupt handler for the I2C module.// Enable the I2C interrupt.//! I2CSlaveIntClear().//! responsibility to clear the interrupt source via I2CMasterIntClear() and//! I2CSlaveIntEnable().  If necessary, it is the interrupt handler's//! specific I2C interrupts must be enabled via I2CMasterIntEnable() and//! This function enables the global interrupt in the interrupt controller;//! This function sets the handler to be called when an I2C interrupt occurs.//! I2C interrupt occurs.//! Registers an interrupt handler for the I2C module.// Disable the clock to the slave block.// Disable the slave.//! This function disables operation of the I2C slave block.//! Disables the I2C slave block.// Disable the master block.//! This function disables operation of the I2C master block.//! Disables the I2C master block.// Enable the slave.// Enable the clock to the slave block.//! This fucntion enables operation of the I2C Slave block.//! Enables the I2C Slave block.// Enable the master block.//! This function enables operation of the I2C Master block.//! Enables the I2C Master block.// Set up and enable the secondary slave address.// Set up the primary slave address.// Determine which slave address is being set.//! consult the device data sheet to determine if this feature is supported.//! \note Not all Tiva devices support a secondary address.  Please//! configures the primary address and a value of 1 configures the secondary.//! dictates which slave address is configured.  For example, a value of 0//! This function writes the specified slave address.  The \e ui32AddrNum field//! \param ui8SlaveAddr is the 7-bit slave address//! \param ui8AddrNum determines which slave address is set.//! Sets the I2C slave address.// Set up the slave address.// Must enable the device before doing anything else.//! slave address sent by an I2C master.//! The parameter \e ui8SlaveAddr is the value that is compared against the//! the slave address and enabling the I2C Slave block.//! This function initializes operation of the I2C Slave block by configuring//! Initializes the I2C Slave block.// choose the fastest speed that is less than or equal to 3.4 Mbps.// Check to see if this I2C peripheral is High-Speed enabled.  If yes, also// to the desired clock, never greater.// clock divider so that the resulting clock is always less than or equal// equal to the desired speed.  The numerator is biased to favor a larger// Compute the clock divider that achieves the fastest speed less than or// Get the desired SCL speed.//! 400 Kbps.//! initial communication with the slave is done at either 100 Kbps or//! mode, a specific command is used to switch to the faster clocks after the//! write the I2CMTPR after calling this function.  For High Speed (3.4 Mbps)//! 100 Kbps.  If Fast Mode Plus (1 Mbps) is desired, software should manually//! transfer data at 400 Kbps; otherwise, it is set up to transfer data at//! If the parameter \e bFast is \b true, then the master block is set up to//! the bus speed for the master and enabling the I2C Master block.//! This function initializes operation of the I2C Master block by configuring//! \param bFast set up for fast data transfers.//! \param ui32I2CClk is the rate of the clock supplied to the I2C module.//! Initializes the I2C Master block.//! \return Returns an I2C interrupt number, or 0 if \e ui32Base is invalid.//! Given a I2C base address, this function returns the corresponding//! Gets the I2C interrupt number.//! This function determines if a I2C module base address is valid.//! Checks an I2C base address.// A mapping of I2C base address to interrupt number.//! \addtogroup i2c_api// i2c.c - Driver for Inter-IC (I2C) bus block./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/interrupt.cIntTriggerNVIC_SW_TRIG0xE000EF003758157568(ui32Interrupt >= 16) && (ui32Interrupt < NUM_INTERRUPTS)IntPriorityMaskGetIntPriorityMaskSetIntPendClearNVIC_INT_CTRL0xE000ED04g_pui32UnpendRegs[(ui32Interrupt - 16) / 32]3758157060NVIC_INT_CTRL_UNPEND_SVNVIC_INT_CTRL_PENDSTCLRconst uint32_t[5]unsigned long[5]ui32Interrupt < NUM_INTERRUPTSIntPendSetg_pui32PendRegs[(ui32Interrupt - 16) / 32]NVIC_INT_CTRL_NMI_SETNVIC_INT_CTRL_PEND_SVNVIC_INT_CTRL_PENDSTSETIntIsEnabledNVIC_SYS_HND_CTRL0xE000ED24NVIC_ST_CTRL0xE000E010g_pui32EnRegs[(ui32Interrupt - 16) / 32]3758157092NVIC_SYS_HND_CTRL_MEMNVIC_SYS_HND_CTRL_BUSNVIC_SYS_HND_CTRL_USAGE3758153744NVIC_ST_CTRL_INTENIntDisableg_pui32Dii16Regs[(ui32Interrupt - 16) / 32](NVIC_SYS_HND_CTRL_MEM)~(NVIC_SYS_HND_CTRL_MEM)(NVIC_SYS_HND_CTRL_BUS)~(NVIC_SYS_HND_CTRL_BUS)(NVIC_SYS_HND_CTRL_USAGE)4294705151~(NVIC_SYS_HND_CTRL_USAGE)(NVIC_ST_CTRL_INTEN)~(NVIC_ST_CTRL_INTEN)IntEnableIntPriorityGetg_pui32Regs[ui32Interrupt >> 2]const uint32_t[39]unsigned long[39](ui32Interrupt >= 4) && (ui32Interrupt < NUM_INTERRUPTS)IntPrioritySetIntPriorityGroupingGetNVIC_APINT0xE000ED0C3758157068NVIC_APINT_PRIGROUP_Mconst uint32_t[8]unsigned long[8]IntPriorityGroupingSetui32Interruptui32PriorityMaskui8Priorityui32Bits100270080NVIC_APINT_VECTKEYui32Bits < NUM_PRIORITYIntUnregister..(*[155])(..)..(**)(..)IntRegisterNVIC_VTABLE0xE000ED08(ui32Idx * 4) + ui32Value3758157064((uint32_t)g_pfnRAMVectors & 0x000003ff) == 0IntMasterDisableIntMasterEnable_IntDefaultHandlerg_pfnRAMVectorsalignedvtable"vtable"char[7]sectiong_pui32UnpendRegs3758154368NVIC_UNPEND03758154372NVIC_UNPEND13758154376NVIC_UNPEND23758154380NVIC_UNPEND33758154384NVIC_UNPEND4g_pui32PendRegs3758154240NVIC_PEND03758154244NVIC_PEND13758154248NVIC_PEND23758154252NVIC_PEND33758154256NVIC_PEND4g_pui32Dii16Regs3758154112NVIC_DIS03758154116NVIC_DIS13758154120NVIC_DIS23758154124NVIC_DIS33758154128NVIC_DIS4g_pui32EnRegs3758153984NVIC_EN03758153988NVIC_EN13758153992NVIC_EN23758153996NVIC_EN33758154000NVIC_EN4g_pui32Regs3758157080NVIC_SYS_PRI13758157084NVIC_SYS_PRI23758157088NVIC_SYS_PRI33758154752NVIC_PRI03758154756NVIC_PRI13758154760NVIC_PRI23758154764NVIC_PRI33758154768NVIC_PRI43758154772NVIC_PRI53758154776NVIC_PRI63758154780NVIC_PRI73758154784NVIC_PRI83758154788NVIC_PRI93758154792NVIC_PRI103758154796NVIC_PRI113758154800NVIC_PRI123758154804NVIC_PRI133758154808NVIC_PRI143758154812NVIC_PRI153758154816NVIC_PRI163758154820NVIC_PRI173758154824NVIC_PRI183758154828NVIC_PRI193758154832NVIC_PRI203758154836NVIC_PRI213758154840NVIC_PRI223758154844NVIC_PRI233758154848NVIC_PRI243758154852NVIC_PRI253758154856NVIC_PRI263758154860NVIC_PRI273758154864NVIC_PRI283758154868NVIC_PRI293758154872NVIC_PRI303758154876NVIC_PRI313758154880NVIC_PRI323758154884NVIC_PRI333758154888NVIC_PRI34g_pui32PriorityNVIC_APINT_PRIGROUP_0_8NVIC_APINT_PRIGROUP_1_7NVIC_APINT_PRIGROUP_2_6NVIC_APINT_PRIGROUP_3_5NVIC_APINT_PRIGROUP_4_4NVIC_APINT_PRIGROUP_5_3NVIC_APINT_PRIGROUP_6_2NVIC_APINT_PRIGROUP_7_1defined(sourcerygxx)defined(ccs) || defined(DOXYGEN)// Trigger this interrupt.//! interrupts).//! processing is based on its priority with respect to other unhandled//! manner (meaning that it must be enabled in order to be processed, and the//! interrupt line was asserted, and the interrupt is handled in the same//! header file.  The interrupt controller behaves as if the corresponding//! in Peripheral Driver Library User's Guide and defined in the inc/hw_ints.h//! \e ui32Interrupt parameter must be one of the valid \b INT_* values listed//! This function performs a software trigger of an interrupt.  The//! \param ui32Interrupt specifies the interrupt to be triggered.//! Triggers an interrupt.// Return the current priority mask.//! \return Returns the value of the interrupt priority level mask.//! IntPriorityMaskGet();//! // Get the current interrupt priority mask.//! \b Example: Get the current interrupt priority mask.//! priority level, so any prioritization must be performed in those bits.//! The hardware priority mechanism only looks at the upper 3 bits of the//! and interrupts with a numerical priority of 4 and greater are blocked.//! a priority level mask of 4 allows interrupts of priority level 0-3,//! Smaller numbers correspond to higher interrupt priorities.  So for example//! masking is disabled.//! of that and lesser priority are masked.  A value of 0 means that priority//! level.  The value returned is the priority level such that all interrupts//! This function gets the current setting of the interrupt priority masking//! Gets the priority masking level// Set the priority mask.//! IntPriorityMaskSet(0x80);//! // Mask of interrupt priorities greater than or equal to 0x80.//! \b Example: Mask of interrupt priorities greater than or equal to 0x80.//! \note The hardware priority mechanism only looks at the upper 3 bits of the//! masking.//! priority below a predetermined threshold.  A value of 0 disables priority//! interrupts can be used to globally disable a set of interrupts with//! interrupts at the specified or lesser priority level are masked.  Masking//! This function sets the interrupt priority masking level so that all//! \param ui32PriorityMask is the priority level that is masked.//! Sets the priority masking level// Unpend the general interrupt.// Unpend the SysTick interrupt.// Unpend the PendSV interrupt.// Determine the interrupt to unpend.//! IntPendClear(INT_UART0);//! // Un-pend a UART 0 interrupt.//! \b Example: Un-pend a UART 0 interrupt.//! enabled yet) to be discarded.//! yet (due to higher priority interrupts or the interrupt not having been//! causes any previously generated interrupts that have not been handled//! The specified interrupt is un-pended in the interrupt controller.  This//! header file.//! \param ui32Interrupt specifies the interrupt to be un-pended.  The//! Un-pends an interrupt.// Pend the general interrupt.// Pend the SysTick interrupt.// Pend the PendSV interrupt.// Pend the NMI interrupt.// Determine the interrupt to pend.//! IntPendSet(INT_UART0);//! // Pend a UART 0 interrupt.//! \b Example: Pend a UART 0 interrupt.//! The interrupt must have been enabled for it to be called.//! called until after the current interrupt handler has completed execution.//! a higher priority interrupt handler, the specified interrupt handler is not//! based on the current interrupt state priorities.  For example, if called by//! execute the corresponding interrupt handler at the next available time,//! header file.  Pending an interrupt causes the interrupt controller to//! The specified interrupt is pended in the interrupt controller.  The//! \param ui32Interrupt specifies the interrupt to be pended.//! Pends an interrupt.// Check the general interrupt.// Check the System Tick interrupt.// Check the usage fault interrupt.// Check the bus fault interrupt.// Check the MemManage interrupt.// Determine the interrupt to disable.// Initialize the return value.//! \return A non-zero value if the interrupt is enabled.//! }//!     IntDisable(INT_UART0);//! {//! if(IntIsEnabled(INT_UART0))//! // Disable the UART 0 interrupt if it is enabled.//! \b Example: Disable the UART 0 interrupt if it is enabled.//! defined in the inc/hw_ints.h header file.//! \b INT_* values listed in Peripheral Driver Library User's Guide and//! controller.  The \e ui32Interrupt parameter must be one of the valid//! This function checks if the specified interrupt is enabled in the interrupt//! \param ui32Interrupt specifies the interrupt to check.//! Returns if a peripheral interrupt is enabled.// Disable the general interrupt.// Disable the System Tick interrupt.// Disable the usage fault interrupt.// Disable the bus fault interrupt.// Disable the MemManage interrupt.//! IntDisable(INT_UART0);//! // Disable the UART 0 interrupt in the interrupt controller.//! \b Example: Disable the UART 0 interrupt.//! level) are unaffected by this function.//! header file.  Other enables for the interrupt (such as at the peripheral//! The specified interrupt is disabled in the interrupt controller.  The//! \param ui32Interrupt specifies the interrupt to be disabled.//! Disables an interrupt.// Enable the general interrupt.// Enable the System Tick interrupt.// Enable the usage fault interrupt.// Enable the bus fault interrupt.// Enable the MemManage interrupt.// Determine the interrupt to enable.//! IntEnable(INT_UART0);//! // Enable the UART 0 interrupt in the interrupt controller.//! \b Example: Enable the UART 0 interrupt.//! header file. Other enables for the interrupt (such as at the peripheral//! The specified interrupt is enabled in the interrupt controller.  The//! \param ui32Interrupt specifies the interrupt to be enabled.//! Enables an interrupt.// Return the interrupt priority.//! \return Returns the interrupt priority for the given interrupt.//! IntPriorityGet(INT_UART0);//! // Get the current UART 0 interrupt priority.//! \b Example: Get the current UART 0 interrupt priority.//! See IntPrioritySet() for a full definition of the priority value.//! Driver Library User's Guide and defined in the inc/hw_ints.h header file.//! parameter must be one of the valid \b INT_* values listed in Peripheral//! This function gets the priority of an interrupt.  The \e ui32Interrupt//! \param ui32Interrupt specifies the interrupt in question.//! Gets the priority of an interrupt.// Set the interrupt priority.//! IntPrioritySet(INT_USB0, 0);//! // Set the USB 0 interrupt priority to the highest priority.//! IntPrioritySet(INT_UART0, 0xE0);//! // Set the UART 0 interrupt priority to the lowest priority.//! \b Example: Set priorities for UART 0 and USB interrupts.//! without changing the gross prioritization of the interrupts.//! arrangement allows priorities to migrate to different NVIC implementations//! be used by the hardware priority mechanism on a future part.  This//! remaining bits can be used to sub-prioritize the interrupt sources, and may//! priority level, so any prioritization must be performed in those bits.  The//! the highest interrupt priority.//! Smaller numbers correspond to higher interrupt priorities; priority 0 is//! highest priority are processed before the lower priority interrupts.//! When multiple interrupts are asserted simultaneously, the ones with the//! hardware priority level of the interrupt in the interrupt controller.//! header file.  The \e ui8Priority parameter specifies the interrupts//! This function is used to set the priority of an interrupt.  The//! \param ui8Priority specifies the priority of the interrupt.//! Sets the priority of an interrupt.// Return the number of priority bits.// Stop looping if this value matches.// Loop through the priority grouping values.// Read the priority grouping.//! \return The number of bits of preemptable priority.//! IntPriorityGroupingGet();//! // Get the priority grouping for the interrupt controller.//! \b Example: Get the priority grouping for the interrupt controller.//! sub-priority levels in the interrupt priority specification.//! This function returns the split between preemptable priority levels and//! Gets the priority grouping of the interrupt controller.// Set the priority grouping.//! IntPriorityGroupingSet(2);//! // Set the priority grouping for the interrupt controller to 2 bits.//! \b Example: Set the priority grouping for the interrupt controller.//! through seven have the same effect.//! interrupt prioritization and therefore priority grouping values of three//! the Tiva C and E Series family, three bits are available for hardware//! the grouping values are dependent upon the hardware implementation; on//! sub-priority levels in the interrupt priority specification.  The range of//! This function specifies the split between preemptable priority levels and//! \param ui32Bits specifies the number of bits of preemptable priority.//! Sets the priority grouping of the interrupt controller.// Reset the interrupt handler.//! IntUnregister(INT_UART0);//! // Reset the UART 0 interrupt handler to the default handler.//! \b Example: Reset the UART 0 interrupt handler to the default handler.//! necessary.//! The interrupt source is automatically disabled (via IntDisable()) if//! given interrupt is asserted to the processor.  The \e ui32Interrupt//! This function is used to indicate that no handler is called when the//! Unregisters the function to be called when an interrupt occurs.// Save the interrupt handler.// Point the NVIC at the RAM vector table.// table.// Copy the vector table from the beginning of FLASH to the RAM vector// See if the RAM vector table has been initialized.// Make sure that the RAM vector table is correctly aligned.//! IntRegister(INT_UART0, UART0Handler);//! // Set the UART 0 interrupt handler.//!     ////!     // Handle interrupt.//! UART0Handler(void)//! void//! // UART 0 interrupt handler.//! \b Example: Set the UART 0 interrupt handler.//! registration in the introduction to this chapter.//! See the discussion of compile-time versus run-time interrupt handler//! Normally, the SRAM vector table is so placed via the use of linker scripts.//! vector table (it requires the vector table be on a 1 kB memory alignment).//! otherwise the NVIC does not look in the correct portion of memory for the//! to ensure that the SRAM vector table is located at the beginning of SRAM;//! flash to SRAM.  Therefore, care must be taken when linking the application//! driver interrupt register function) moves the interrupt vector table from//! \note The use of this function (directly or indirectly via a peripheral//! that are accessed by the handler and other non-handler code.//! preempt other code, care must be taken to protect memory or peripherals//! function is called in interrupt context.  Because the handler function can//! When the interrupt occurs, if it is enabled (via IntEnable()), the handler//! This function is used to specify the handler function to be called when the//! \param pfnHandler is a pointer to the function to be called.//! Registers a function to be called when an interrupt occurs.// Disable processor interrupts.//! function was called or \b false if they were initially enabled.//! \return Returns \b true if interrupts were already disabled when the//! IntMasterDisable();//! // Disable interrupts to the processor.//! \b Example: Disable interrupts to the processor.//! is to include <tt>hw_types.h</tt> before including <tt>interrupt.h</tt>.//! <tt>bool</tt>, a compiler error occurs in this case.  The solution//! having included <tt>hw_types.h</tt>.  Now that the return is a//! possible to include <tt>interrupt.h</tt> and call this function without//! \note Previously, this function had no return value.  As such, it was//! processor.//! controller; it just gates the single interrupt from the controller to the//! function does not affect the set of interrupts enabled in the interrupt//! This function prevents the processor from receiving interrupts.  This//! Disables the processor interrupt.// Enable processor interrupts.//! called or \b false if they were initially enabled.//! \return Returns \b true if interrupts were disabled when the function was//! IntMasterEnable();//! // Enable interrupts to the processor.//! \b Example: Enable interrupts to the processor.//! it just gates the single interrupt from the controller to the processor.//! does not affect the set of interrupts enabled in the interrupt controller;//! This function allows the processor to respond to interrupts.  This function//! Enables the processor interrupt.// any device// Set the size of the vector table to the largest number of interrupts of// address given in the corresponding location in this list.// of an interrupt causes the processor to start executing directly at the// the system.  The layout of this list is defined by the hardware; assertion// This contains a list of the handlers for the various interrupt sources in// The processor vector table.// Go into an infinite loop.//! corresponding handler, this should never be called during normal operation.//! debugger.  Since interrupts must be disabled before unregistering the//! forever so that the system state is preserved for observation by a//! This is the default interrupt handler for all interrupts.  It simply loops//! The default interrupt handler.// interrupt.// only) and the register that contains the interrupt unpend for that// This is a mapping between interrupt number (for the peripheral interrupts// only) and the register that contains the interrupt pend for that interrupt.// only) and the register that contains the interrupt disable for that// only) and the register that contains the interrupt enable for that// the priority encoding for that interrupt.// This is a mapping between interrupt number and the register that contains// preemption priority bits.// This is a mapping between priority grouping encodings and the number of//! \addtogroup interrupt_api// interrupt.c - Driver for the NVIC Interrupt Controller./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/inc/hw_lcd.hLCD_CLKRESET_CORELCD_CLKRESET_LIDDLCD_CLKRESET_DMALCD_CLKRESET_MAINLCD_CLKEN_CORELCD_CLKEN_LIDDLCD_CLKEN_DMALCD_IENC_DONELCD_IENC_RRASTRDONELCD_IENC_SYNCSLCD_IENC_ACBSLCD_IENC_FIFOULCD_IENC_PALLOADLCD_IENC_EOF0LCD_IENC_EOF1LCD_IM_DONELCD_IM_RRASTRDONELCD_IM_SYNCSLCD_IM_ACBSLCD_IM_FIFOULCD_IM_PALLOADLCD_IM_EOF0LCD_IM_EOF1LCD_MISCLR_DONELCD_MISCLR_RRASTRDONELCD_MISCLR_SYNCSLCD_MISCLR_ACBSLCD_MISCLR_FIFOULCD_MISCLR_PALLOADLCD_MISCLR_EOF0LCD_MISCLR_EOF1LCD_RISSET_DONELCD_RISSET_RRASTRDONELCD_RISSET_SYNCSLCD_RISSET_ACBSLCD_RISSET_FIFOULCD_RISSET_PALLOADLCD_RISSET_EOF0LCD_RISSET_EOF1LCD_SYSCFG_IDLEMODE_SMARTLCD_SYSCFG_IDLEMODE_NONELCD_SYSCFG_IDLEMODE_FORCELCD_SYSCFG_IDLEMODE_MLCD_SYSCFG_STDBY_SMARTLCD_SYSCFG_STDBY_NONELCD_SYSCFG_STDBY_FORCELCD_SYSCFG_STDBY_MLCD_DMACAFB1_FB1CA_SLCD_DMACAFB1_FB1CA_MLCD_DMABAFB1_FB1BA_SLCD_DMABAFB1_FB1BA_MLCD_DMACAFB0_FB0CA_SLCD_DMACAFB0_FB0CA_MLCD_DMABAFB0_FB0BA_SLCD_DMABAFB0_FB0BA_MLCD_DMACTL_FMODELCD_DMACTL_BIGDENDLCD_DMACTL_BYTESWAPLCD_DMACTL_BURSTSZ_16LCD_DMACTL_BURSTSZ_8LCD_DMACTL_BURSTSZ_4LCD_DMACTL_BURSTSZ_MLCD_DMACTL_FIFORDY_512LCD_DMACTL_FIFORDY_256LCD_DMACTL_FIFORDY_128LCD_DMACTL_FIFORDY_64LCD_DMACTL_FIFORDY_32LCD_DMACTL_FIFORDY_16LCD_DMACTL_FIFORDY_8LCD_DMACTL_FIFORDY_MLCD_RASTRSUBP2_DPDMSB_SLCD_RASTRSUBP2_DPDMSB_MLCD_RASTRSUBP2_LPPTMSBLCD_RASTRSUBP1_DPDLSB_SLCD_RASTRSUBP1_LPPT_SLCD_RASTRSUBP1_DPDLSB_MLCD_RASTRSUBP1_LPPT_MLCD_RASTRSUBP1_HOLSLCD_RASTRSUBP1_SPENLCD_RASTRTIM2_MSBHFP_SLCD_RASTRTIM2_MSBHBP_SLCD_RASTRTIM2_ACBF_SLCD_RASTRTIM2_ACBI_SLCD_RASTRTIM2_MSBLPP_SLCD_RASTRTIM2_HSW_SLCD_RASTRTIM2_MSBHFP_MLCD_RASTRTIM2_MSBHBP_MLCD_RASTRTIM2_ACBF_MLCD_RASTRTIM2_ACBI_MLCD_RASTRTIM2_IVSLCD_RASTRTIM2_IHSLCD_RASTRTIM2_INVPXLCLKLCD_RASTRTIM2_INVOELCD_RASTRTIM2_PSYNCRFLCD_RASTRTIM2_PXLCLKCTLLCD_RASTRTIM2_MSBLPPLCD_RASTRTIM2_HSW_M0x78000000LCD_RASTRTIM1_LPP_SLCD_RASTRTIM1_VSW_SLCD_RASTRTIM1_VFP_SLCD_RASTRTIM1_VBP_SLCD_RASTRTIM1_LPP_MLCD_RASTRTIM1_VSW_MLCD_RASTRTIM1_VFP_MLCD_RASTRTIM1_VBP_MLCD_RASTRTIM0_MSBPPL_SLCD_RASTRTIM0_PPL_SLCD_RASTRTIM0_HSW_SLCD_RASTRTIM0_HFP_SLCD_RASTRTIM0_HBP_SLCD_RASTRTIM0_MSBPPLLCD_RASTRTIM0_PPL_MLCD_RASTRTIM0_HSW_MLCD_RASTRTIM0_HFP_MLCD_RASTRTIM0_HBP_MLCD_RASTRCTL_REQDLY_SLCD_RASTRCTL_LCDENLCD_RASTRCTL_LCDBWLCD_RASTRCTL_LCDTFTLCD_RASTRCTL_RDORDERLCD_RASTRCTL_MONO8BLCD_RASTRCTL_REQDLY_M0x000FF000LCD_RASTRCTL_PALMODE_DATLCD_RASTRCTL_PALMODE_PALLCD_RASTRCTL_PALMODE_PALDATLCD_RASTRCTL_PALMODE_MLCD_RASTRCTL_NIBMODELCD_RASTRCTL_TFTMAPLCD_RASTRCTL_FRMBUFSZLCD_RASTRCTL_TFT24LCD_RASTRCTL_TFT24UPCKLCD_LIDDCS1DATA_CS0DATA_SLCD_LIDDCS1DATA_CS0DATA_MLCD_LIDDCS1ADDR_CS1ADDR_SLCD_LIDDCS1ADDR_CS1ADDR_MLCD_LIDDCS1CFG_GAP_SLCD_LIDDCS1CFG_RDHOLD_SLCD_LIDDCS1CFG_RDDUR_SLCD_LIDDCS1CFG_RDSU_SLCD_LIDDCS1CFG_WRHOLD_SLCD_LIDDCS1CFG_WRDUR_SLCD_LIDDCS1CFG_WRSU_SLCD_LIDDCS1CFG_GAP_MLCD_LIDDCS1CFG_RDHOLD_MLCD_LIDDCS1CFG_RDDUR_MLCD_LIDDCS1CFG_RDSU_M0x0001F000LCD_LIDDCS1CFG_WRHOLD_MLCD_LIDDCS1CFG_WRDUR_M0x07E00000LCD_LIDDCS1CFG_WRSU_M0xF8000000LCD_LIDDCS0DATA_CS0DATA_SLCD_LIDDCS0DATA_CS0DATA_MLCD_LIDDCS0ADDR_CS0ADDR_SLCD_LIDDCS0ADDR_CS0ADDR_MLCD_LIDDCS0CFG_GAP_SLCD_LIDDCS0CFG_RDHOLD_SLCD_LIDDCS0CFG_RDDUR_SLCD_LIDDCS0CFG_RDSU_SLCD_LIDDCS0CFG_WRHOLD_SLCD_LIDDCS0CFG_WRDUR_SLCD_LIDDCS0CFG_WRSU_SLCD_LIDDCS0CFG_GAP_MLCD_LIDDCS0CFG_RDHOLD_MLCD_LIDDCS0CFG_RDDUR_MLCD_LIDDCS0CFG_RDSU_MLCD_LIDDCS0CFG_WRHOLD_MLCD_LIDDCS0CFG_WRDUR_MLCD_LIDDCS0CFG_WRSU_MLCD_LIDDCTL_MODE_ASYNCHITLCD_LIDDCTL_MODE_ASYNCM80LCD_LIDDCTL_MODE_SYNCM80LCD_LIDDCTL_MODE_ASYNCM68LCD_LIDDCTL_MODE_SYNCM68LCD_LIDDCTL_MODE_MLCD_LIDDCTL_ALELCD_LIDDCTL_RDENLCD_LIDDCTL_WRDIRINVLCD_LIDDCTL_CS0E0LCD_LIDDCTL_CS1E1LCD_LIDDCTL_DMAENLCD_LIDDCTL_DMACSLCD_CTL_CLKDIV_SLCD_CTL_LCDMODELCD_CTL_UFLOWRSTLCD_CTL_CLKDIV_MLCD_PID_MINOR_SLCD_PID_MAJOR_SLCD_PID_MINOR_MLCD_PID_MAJOR_MLCD_O_CLKRESETLCD_O_CLKENLCD_O_IENCLCD_O_IMLCD_O_MISCLRLCD_O_RISSETLCD_O_SYSCFGLCD_O_DMACAFB1LCD_O_DMABAFB1LCD_O_DMACAFB0LCD_O_DMABAFB0LCD_O_DMACTLLCD_O_RASTRSUBP2LCD_O_RASTRSUBP1LCD_O_RASTRTIM2LCD_O_RASTRTIM1LCD_O_RASTRTIM0LCD_O_RASTRCTLLCD_O_LIDDCS1DATALCD_O_LIDDCS1ADDRLCD_O_LIDDCS1CFGLCD_O_LIDDCS0DATALCD_O_LIDDCS0ADDRLCD_O_LIDDCS0CFGLCD_O_LIDDCTLLCD_O_CTLLCD_O_PID__HW_LCD_H__// __HW_LCD_H__// logic// Active Matrix and Passive Matrix// which encompasses the Raster// Software Reset for the Core,// submodule (character displays)// Software Reset for the LIDD// submodule// Software Reset for the DMA// LCD module// Software Reset for the entire// The following are defines for the bit fields in the LCD_O_CLKRESET register.// LCD Core Clock Enable// LIDD Submodule Clock Enable// DMA Clock Enable// The following are defines for the bit fields in the LCD_O_CLKEN register.// Interrupt Enable Clear// Raster or LIDD mode enabled)// (shared, depends on whether// Raster or LIDD Frame Done// Enable Clear// Raster Mode Frame Done Interrupt// Frame Synchronization Lost// AC Bias Count Interrupt Enable// DMA FIFO Underflow Interrupt// DMA Palette Loaded Interrupt// DMA End-of-Frame 0 Interrupt// DMA End-of-Frame 1 Interrupt// The following are defines for the bit fields in the LCD_O_IENC register.// Interrupt Enable Set// Enable Set// Set// The following are defines for the bit fields in the LCD_O_IM register.// Enabled Interrupt and Clear// Raster Mode Frame Done interrupt// AC Bias Count Enabled Interrupt// Interrupt and Clear// DMA FIFO Underflow Enabled// DMA Palette Loaded Enabled// DMA End-of-Frame 0 Raw Interrupt// DMA End-of-Frame 1 Enabled// The following are defines for the bit fields in the LCD_O_MISCLR register.// Interrupt Status and Set// Raster or LIDD mode enabled) Raw// Frame Synchronization Lost Raw// Status and Set// AC Bias Count Raw Interrupt// DMA FIFO Underflow Raw Interrupt// DMA Palette Loaded Raw Interrupt// DMA End-of-Frame 1 Raw Interrupt// The following are defines for the bit fields in the LCD_O_RISSET register.// wakeup events// (IRQ- or DMA-requestrelated)// IP module shall not generate// module's internal requirements.// requests, depending on the IP// (acknowledges) the system's idle// idle state eventually follows// Smart-idle mode: local target's// for debug only// enters idle state. Backup mode,// No-idle mode: local target never// Backup mode, for debug only// is, regardless of the IP// requests unconditionally, that// idle state follows// Force-idle mode: local target's// Idle Mode// events// (initiator-related) wakeup// requirement from the initiator.// the module's functional// on local conditions, that is,// initiator standby status depends// Smart-standby mode: local// debug only// standby state. Backup mode, for// is unconditionally placed out of// No-standby mode: local initiator// mode, for debug only// placed in standby state. Backup// initiator is unconditionally// Force-standby mode: local// The following are defines for the bit fields in the LCD_O_SYSCFG register.// pointer// Frame Buffer 1 Ceiling Address// The following are defines for the bit fields in the LCD_O_DMACAFB1 register.// Frame Buffer 1 Base Address// The following are defines for the bit fields in the LCD_O_DMABAFB1 register.// Frame Buffer 0 Ceiling Address// The following are defines for the bit fields in the LCD_O_DMACAFB0 register.// Frame Buffer 0 Base Address// The following are defines for the bit fields in the LCD_O_DMABAFB0 register.// Frame Mode// Big Endian Enable// output of the DMA module// ordering of the data on the// This bit controls the bytelane// burst size of 16// burst size of 8// burst size of 4// 32 bits wide):// transfers (all DMA transfers are// Burst Size setting for DMA// 512 words// 256 words// 128 words// 64 words// 32 words// 16 words// 8 words// DMA FIFO threshold// The following are defines for the bit fields in the LCD_O_DMACTL register.// Default Pixel Data MSB [23:16]// Lines Per Panel Threshold Bit 10// The following are defines for the bit fields in the LCD_O_RASTRSUBP2// Default Pixel Data LSB[15:0]// Line Per Panel Threshold// High or Low Signal// Sub Panel Enable// The following are defines for the bit fields in the LCD_O_RASTRSUBP1// porch field// Bits 9:8 of the horizontal front// Bits 9:8 of the horizontal back// AC Bias Pin Frequency// AC Bias Pins Transitions per// Invert Vsync// Invert Hysync// Invert Pixel Clock// Invert Output Enable// Program HSYNC/VSYNC Rise or Fall// On/Off// Hsync/Vsync Pixel Clock Control// MSB of Lines Per Panel// width field// Bits 9:6 of the horizontal sync// The following are defines for the bit fields in the LCD_O_RASTRTIM2// Lines Per Panel// Vertical Sync Width Pulse// Vertical Front Porch// Vertical Back Porch// The following are defines for the bit fields in the LCD_O_RASTRTIM1// Pixels-per-line MSB[10]// Pixels-per-line LSB[9:4]// Lowbits// Horizontal Sync Pulse Width// Horizontal Front Porch Lowbits// Horizontal Back Porch Lowbits// The following are defines for the bit fields in the LCD_O_RASTRTIM0// Operations// LCD Controller Enable for Raster// LCD Monochrome// LCD TFT// Raster Data Order Select// Mono 8-Bit// Palette Loading Delay// Data loading only// Palette loading only// value// Palette and data loading, reset// Pallette Loading Mode// Nibble Mode// Framebuffer// Mapping for Palettized// TFT Mode Alternate Signal// Frame Buffer Select// 24-Bit TFT Mode// 24-bit TFT Mode Packing// The following are defines for the bit fields in the LCD_O_RASTRCTL register.// LCD Data Read/Write Initiation// The following are defines for the bit fields in the LCD_O_LIDDCS1DATA// LCD Address Bus// The following are defines for the bit fields in the LCD_O_LIDDCS1ADDR// accesses are both reads// device access unless the two// start of another CS0 (LCDAC)// (LCDAC) device access and the// between the end of one CS1// of LCDMCLK cycles (GAP + 1)// Field value defines the number// Read Strobe (RD) Hold cycles// Read Strobe (RD) Duration cycles// Read Strobe (RD) Set-Up cycles// Write Strobe (WR) Hold cycles// Cycles// Write Strobe (WR) Duration// Write Strobe (WR) Set-Up Cycles// The following are defines for the bit fields in the LCD_O_LIDDCS1CFG// LCD Data Read/Write// The following are defines for the bit fields in the LCD_O_LIDDCS0DATA// LCD Address// The following are defines for the bit fields in the LCD_O_LIDDCS0ADDR// between the end of one CS0// of LCDMCLK cycles (GAP +1)// The following are defines for the bit fields in the LCD_O_LIDDCS0CFG// Asynchronous Hitachi mode// Asynchronous Intel 8080 mode// Synchronous Intel 8080 mode// Asynchronous Motorola 6800 Mode// Synchronous Motorola 6800 Mode// LIDD Mode Select// Polarity Control// Address Latch Enable (ALE)// (EN) Polarity Control// Read Strobe (RD) /Direct Enable// (DIR) Polarity Control// Write Strobe (WR) /Direction// (E0) Polarity Control// Chip Select 0 (CS0)/Enable 0// Chip Select 1 (CS1)/Enable 1(E1)// LIDD DMA Enable// Writes// CS0/CS1 Select for LIDD DMA// The following are defines for the bit fields in the LCD_O_LIDDCTL register.// LCD Mode Select// Underflow Restart// Clock Divisor// The following are defines for the bit fields in the LCD_O_CTL register.// Minor Release Number// Major Release Number// The following are defines for the bit fields in the LCD_O_PID register.// LCD Clock Resets// LCD Clock Enable// LCD Interrupt Enable Clear// LCD Interrupt Mask// LCD Interrupt Status and Clear// LCD Interrupt Raw Status and Set// LCD System Configuration// LCD DMA Frame Buffer 1 Ceiling// LCD DMA Frame Buffer 1 Base// LCD DMA Frame Buffer 0 Ceiling// LCD DMA Frame Buffer 0 Base// LCD DMA Control// LCD Raster Subpanel Display 2// LCD Raster Subpanel Display 1// LCD Raster Timing 2// LCD Raster Timing 1// LCD Raster Timing 0// LCD Raster Control// Initiation// LIDD CS1 Data Read/Write// LIDD CS1 Address Read/Write// LIDD CS1 Configuration// LIDD CS0 Data Read/Write// LIDD CS0 Read/Write Address// LCD LIDD CS0 Configuration// LCD LIDD Control// LCD Control// LCD PID Register Format// The following are defines for the LCD register offsets.// hw_lcd.h - Defines and macros used when accessing the LCD controller./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/lcd.htLCDRasterTimingtLCDIDDTimingui8ACBiasLineCountui8VSyncWidthui8VBackPorchui8VFrontPorchui16HSyncWidthui16HBackPorchui16HFrontPorchui16PanelHeightui16PanelWidthui8DelayCyclesui8RSHoldui8RSDurationui8RSSetupui8WSHoldui8WSDurationui8WSSetupLCD_SUBPANEL_AT_BOTTOMLCD_SUBPANEL_AT_TOPLCD_CLOCK_CORELCD_CLOCK_LIDDLCD_CLOCK_DMALCD_CLOCK_MAINLCD_PALETTE_SRC_24BITLCD_PALETTE_TYPE_DIRECTLCD_PALETTE_TYPE_8BPPLCD_PALETTE_TYPE_4BPPLCD_PALETTE_TYPE_2BPPLCD_PALETTE_TYPE_1BPPLCD_DMA_PING_PONGLCD_DMA_BYTE_ORDER_2301LCD_DMA_BYTE_ORDER_3210LCD_DMA_BYTE_ORDER_1023LCD_DMA_BYTE_ORDER_0123LCD_DMA_BURST_16LCD_DMA_BURST_8LCD_DMA_BURST_4LCD_DMA_BURST_2LCD_DMA_BURST_1LCD_DMA_FIFORDY_512_WORDSLCD_DMA_FIFORDY_256_WORDSLCD_DMA_FIFORDY_128_WORDSLCD_DMA_FIFORDY_64_WORDSLCD_DMA_FIFORDY_32_WORDSLCD_DMA_FIFORDY_16_WORDSLCD_DMA_FIFORDY_8_WORDSLCD_INT_EOF1LCD_INT_EOF0LCD_INT_PAL_LOADLCD_INT_UNDERFLOWLCD_INT_AC_BIAS_CNTLCD_INT_SYNC_LOSTLCD_INT_RASTER_FRAME_DONELCD_INT_DMA_DONERASTER_READ_ORDER_REVERSEDRASTER_LOAD_PALETTE_ONLYRASTER_LOAD_DATA_ONLYRASTER_NIBBLE_MODE_ENABLEDRASTER_ACTVID_DURING_BLANKRASTER_FMT_PASSIVE_COLOR_16BITRASTER_FMT_PASSIVE_COLOR_12BITRASTER_FMT_PASSIVE_PALETTIZEDRASTER_FMT_PASSIVE_MONO_8PIXRASTER_FMT_PASSIVE_MONO_4PIXRASTER_FMT_ACTIVE_PALETTIZED_16BIT0x00800080RASTER_FMT_ACTIVE_PALETTIZED_12BITRASTER_FMT_ACTIVE_24BPP_UNPACKED0x06000080RASTER_FMT_ACTIVE_24BPP_PACKED0x02000080LIDD_CONFIG_INVERT_CS1LIDD_CONFIG_INVERT_CS0LIDD_CONFIG_INVERT_WS_DIRLIDD_CONFIG_INVERT_RS_ENLIDD_CONFIG_INVERT_ALELIDD_CONFIG_ASYNC_HITACHILIDD_CONFIG_ASYNC_MPU80LIDD_CONFIG_SYNC_MPU80LIDD_CONFIG_ASYNC_MPU68LIDD_CONFIG_SYNC_MPU68LCD_MODE_AUTO_UFLOW_RESTART((uint8_t)0x02)LCD_MODE_RASTER((uint8_t)0x01)LCD_MODE_LIDD((uint8_t)0x00)RASTER_TIMING_ACTIVE_LOW_VSYNCRASTER_TIMING_ACTIVE_HIGH_VSYNCRASTER_TIMING_ACTIVE_LOW_HSYNCRASTER_TIMING_ACTIVE_HIGH_HSYNCRASTER_TIMING_ACTIVE_LOW_PIXCLKRASTER_TIMING_ACTIVE_HIGH_PIXCLKRASTER_TIMING_ACTIVE_LOW_OERASTER_TIMING_ACTIVE_HIGH_OERASTER_TIMING_SYNCS_ON_FALLING_PIXCLKRASTER_TIMING_SYNCS_ON_RISING_PIXCLKRASTER_TIMING_SYNCS_OPPOSITE_PIXCLKCYCLES_FROM_TIME_NS(ui32ClockFreq,ui32Time_nS)(((ui32Time_nS) == 0) ? 0 : ((((((ui32ClockFreq) / 1000000) * ((ui32Time_nS) - 1)) / 1000)) + 1))CYCLES_FROM_TIME_US(ui32ClockFreq,ui32Time_uS)(((ui32Time_uS) == 0) ? 0 : (((ui32ClockFreq) / 1000000) * ((((ui32Time_uS) * 1000) - 1) / 1000)) + 1)PAL_FROM_RGB(ui32RGBColor)(((ui32RGBColor & 0xF0) >> 4) | ((ui32RGBColor & 0xF000) >> 8) | ((ui32RGBColor & 0xF00000) >> 12))__DRIVERLIB_LCD_H__LCDIntUnregisterLCDIntRegisterLCDIntClearLCDIntStatusLCDIntDisableLCDIntEnableLCDRasterFrameBufferSetLCDRasterPaletteSetLCDDMAConfigSetLCDRasterSubPanelDisableLCDRasterSubPanelEnableLCDRasterSubPanelConfigSetLCDRasterDisableLCDRasterEnabledLCDRasterEnableLCDRasterACBiasIntCountSetLCDRasterTimingSetconst tLCDRasterTimingconst tLCDRasterTiming *LCDRasterConfigSetLCDIDDDMAWriteLCDIDDIndexedReadLCDIDDDataReadLCDIDDStatusReadLCDIDDIndexedWriteLCDIDDDataWriteLCDIDDCommandWriteLCDIDDDMADisableLCDIDDTimingSetconst tLCDIDDTimingconst tLCDIDDTiming *LCDIDDConfigSetLCDClockResetLCDModeSet// __DRIVERLIB_LCD_H__// Function Prototypes.// Flags used in with LCDSubPanelConfigSet().// Flags used in the ui32Clocks parameter to LCDClockReset().// Type values used with LCDRasterPaletteSet().// Configuration values used with LCDDMAConfigSet().// returned by LCDIntStatus().// passed to LCDIntEnable(), LCDIntDisable() and LCDIntClear().  They are also// Interrupt sources for the LCD controller.  These may be ORed together and// scanning out the frame buffer).// neither is specified, the controller will load both palette and data when// RASTER_LOAD_DATA_ONLY and RASTER_LOAD_PALETTE_ONLY may be specified (if// labels optionally ORed with the other flags.  Only one of// LCDRasterConfigSet().  Valid parameters contain one of the RASTER_FMT_xxx// Values used to construct the ui32Config parameter to// Values used to construct the ui32Config parameter to LCDIDDConfigSet().// LCD_MODE_AUTO_UFLOW_RESTART may be ORed with either of the other two.// Possible values for the ui8Mode parameter to LCDModeSet().  The label//! charge build-up within the display.//! periodically invert the polarity of the power supply to prevent DC//! count before transitioning the AC Bias pin.  This pin is used to//! A value from 0 to 255 that specifies the number of line clocks to//! this value in passive mode.//! period has elapsed.  Note that the width of lcd_fp is not affected by//! extra line clock periods to insert after the vertical front porch//! In passive mode, a value from 1 to 64 that specifies the number of//! The frame clock is used as the VSYNC signal in active mode.//! frame after the vertical front porch period elapses.  The number of//! line clock periods to set the lcd_fp pin active at the end of each//! In active mode, a value from 1 to 64 that specifies the number of//! output to the display.//! to add to the beginning of a frame before the first active line is//! A value from 0 to 255 that specifies the number of line clock periods//! to add to the end of each frame after the last active line.//! to pulse the line clock at the end of each line.//! A value from 1 to 1024 that specifies the number of pixel clock periods//! to add to the beginning of a line before active video is asserted.//! to add to the end of each line after active video has ended.//! 2048.//! The number of lines on the LCD display.  Valid values are from 1 to//! Valid values are multiple of 16 less than or equal to 2048.//! The number of pixels contained within each line on the LCD display.//! the labels with prefix  ``RASTER_TIMING_''.//! in the raster interface.  This field is comprised of a logical OR of//! Flags configuring the polarity and active edges of the various signals//! used with the LCDRasterTimingSet function.//! A structure containing timing parameters for the raster interface.  This is// tLCDRasterTiming structure.// Values which can be ORed together within the ui32Flags field of the//! this delay is not incurred.  Valid vales are from 1 to 4.//! Chip Select unless the two accesses are both Reads.  In this case,//! device access and the start of another device access using the same//! Field value defines the number of MCLK cycles between the end of one//! read access.  Valid values are from 1 to 15.//! Select are held after the Read Strobe is deasserted when performing a//! for which Data Bus/Pad Output Enable, ALE, the Direction bit, and Chip//! Read Strobe Hold cycles.  Field value defines the number of MCLK cycles//! access.  Valid values are from 1 to 63.//! cycles for which the Read Strobe is held active when performing a read//! Read Strobe Duration cycles.  Field value defines the number of MCLK//! Strobe is asserted.  Valid values are from 0 to 31.//! the Direction bit, and Chip Select have to be ready before the Read//! defines the number of MCLK cycles that Data Bus/Pad Output Enable, ALE,//! Read Strobe Set-Up cycles.  When performing a read access, this field//! performing a write access.  Valid values are from 1 to 15.//! and Chip Select are held after the Write Strobe is deasserted when//! cycles for which Data Bus/Pad Output Enable, ALE, the Direction bit,//! Write Strobe Hold cycles.  Field value defines the number of MCLK//! write access.  Valid values are from 1 to 63.//! cycles for which the Write Strobe is held active when performing a//! Write Strobe Duration cycles.  Field value defines the number of MCLK//! the Write Strobe is asserted.  Valid values are from 0 to 31.//! Enable, ALE, the Direction bit, and Chip Select have to be ready before//! field defines the number of MCLK cycles that Data Bus/Pad Output//! Write Strobe Set-Up cycles.  When performing a write access, this//! Display Driver) interface.  This is used with the LCDIDDTimingSet function.//! A structure containing timing parameters for the LIDD (LCD Interface//! assumed that ui32ClockFreq is a non-zero multiple of 1000000 (1MHz).//! will cause arithmetic overflow and yield incorrect values.  It is further//! 35791394 (35.79 milliseconds) are supported by the macro.  Larger values//! ui32Time_nS parameter.  Values of ui32Time_nS less than or equal to//! cycles returned represents no longer a time than specified in the//! timing structures.  The calculation will round such that the number of//! the supplied clock in Hertz as required when setting up the LIDD and raster//! This macro can be used to convert from time in nanoseconds to periods of//! cause arithmetic overflow and yield incorrect values.  It is further//! 4294967uS (4.29 seconds) are supported by the macro.  Larger values will//! ui32Time_uS parameter.  Values of ui32Time_uS less than or equal to//! This macro can be used to convert from time in microseconds to periods of//! entry.//! TivaWare Graphics Library into a 12-bit LCD controller color palette//! This macro can be used to convert a 24-bit RGB color value as used by the//! \addtogroup lcd_api// lcd.h - Defines and Macros for the LCD Controller module.ui8Bufferui32NumBytesui32Typepui32PalAddrpui32SrcColorsui32Startui32BottomLinesui32DefaultPixelui8CountpTimingui8PalLoadDelayui16Addrui16Cmdui32Clocksui8Modeui32PixClk/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/lcd.c"driverlib/lcd.h""inc/hw_lcd.h"ui32Base == LCD0_BASEui32Base + LCD_O_MISCLR!(ui32IntFlags & ~(LCD_INT_DMA_DONE | LCD_INT_SYNC_LOST | LCD_INT_AC_BIAS_CNT | LCD_INT_UNDERFLOW | LCD_INT_PAL_LOAD | LCD_INT_EOF0 | LCD_INT_EOF1 | LCD_INT_RASTER_FRAME_DONE))ui32Base + LCD_O_RISSETui32Base + LCD_O_IENCui32Base + LCD_O_IMui32Base + LCD_O_DMABAFB0ui32Base + LCD_O_DMACAFB0ui32Base + LCD_O_DMABAFB1ui32Base + LCD_O_DMACAFB1!((uint32_t)pui32Addr & 3)!(ui32NumBytes & 3)ui8Buffer < 2pui16Palpui16Srcpui32SrcColors[ui32Loop](LCD_PALETTE_TYPE_8BPP | LCD_PALETTE_TYPE_DIRECT)-28673~(LCD_PALETTE_TYPE_8BPP | LCD_PALETTE_TYPE_DIRECT)~LCD_PALETTE_SRC_24BITui32Start < 256(ui32Start + ui32Count) <= 256(pui32SrcColors) || (ui32Count == 0)!(ui32Type & ~(LCD_PALETTE_SRC_24BIT | LCD_PALETTE_TYPE_DIRECT | LCD_PALETTE_TYPE_8BPP | LCD_PALETTE_TYPE_4BPP | LCD_PALETTE_TYPE_2BPP | LCD_PALETTE_TYPE_1BPP))ui32Base + LCD_O_DMACTL!(ui32Config & ~(LCD_DMACTL_FIFORDY_M | LCD_DMACTL_BURSTSZ_M | LCD_DMACTL_BYTESWAP | LCD_DMACTL_BIGDEND | LCD_DMACTL_FMODE))ui32Base + LCD_O_RASTRSUBP1~LCD_RASTRSUBP1_SPENui32Base + LCD_O_RASTRSUBP2(ui32Flags == LCD_SUBPANEL_AT_TOP) || (ui32Flags == LCD_SUBPANEL_AT_BOTTOM)ui32BottomLines && (ui32BottomLines <= 2048)ui32Base + LCD_O_RASTRCTL~LCD_RASTRCTL_LCDENui32Base + LCD_O_RASTRTIM24293984255~LCD_RASTRTIM2_ACBI_Mui8Count < 16ui32T0ui32T1ui32T20x3F0x3F00x40010230x3FF9600x3C0ui32Base + LCD_O_RASTRTIM0ui32Base + LCD_O_RASTRTIM1!(pTiming->ui32Flags & ~(RASTER_TIMING_SYNCS_OPPOSITE_PIXCLK | RASTER_TIMING_SYNCS_ON_FALLING_PIXCLK | RASTER_TIMING_SYNCS_ON_RISING_PIXCLK | RASTER_TIMING_ACTIVE_LOW_OE | RASTER_TIMING_ACTIVE_LOW_PIXCLK | RASTER_TIMING_ACTIVE_LOW_HSYNC | RASTER_TIMING_ACTIVE_LOW_VSYNC))pTiming->ui16PanelWidth && (pTiming->ui16PanelWidth <= 2048) && ((pTiming->ui16PanelWidth % 16) == 0)pTiming->ui16PanelHeight && (pTiming->ui16PanelHeight <= 2048)pTiming->ui16HFrontPorch && (pTiming->ui16HFrontPorch <= 1024)pTiming->ui16HBackPorch && (pTiming->ui16HBackPorch <= 1024)pTiming->ui16HSyncWidth && (pTiming->ui16HSyncWidth <= 1024)pTiming->ui8VSyncWidth && (pTiming->ui8VSyncWidth <= 64)!(ui32Config & ~(RASTER_FMT_ACTIVE_24BPP_PACKED | RASTER_FMT_ACTIVE_24BPP_UNPACKED | RASTER_FMT_ACTIVE_PALETTIZED_12BIT | RASTER_FMT_ACTIVE_PALETTIZED_16BIT | RASTER_FMT_PASSIVE_MONO_4PIX | RASTER_FMT_PASSIVE_MONO_8PIX | RASTER_FMT_PASSIVE_PALETTIZED | RASTER_FMT_PASSIVE_COLOR_12BIT | RASTER_FMT_PASSIVE_COLOR_16BIT | RASTER_ACTVID_DURING_BLANK | RASTER_NIBBLE_MODE_ENABLED | RASTER_LOAD_DATA_ONLY | RASTER_LOAD_PALETTE_ONLY | RASTER_READ_ORDER_REVERSED))ui32Base + LCD_O_LIDDCTL4294967039~LCD_LIDDCTL_DMAEN4294966783~LCD_LIDDCTL_DMACS(ui32CS == 0) || (ui32CS == 1)!((uint32_t)pui32Data & 3)!(ui32Count & 1)ui32Addrui32Base + ui32Addrui32Base + ui32Regui32Base + LCD_O_LIDDCS0CFGui32Base + LCD_O_LIDDCS1CFGpTiming->ui8WSSetup < 32pTiming->ui8WSDuration && (pTiming->ui8WSDuration < 64)pTiming->ui8WSHold && (pTiming->ui8WSHold < 16)pTiming->ui8RSSetup < 32pTiming->ui8RSDuration && (pTiming->ui8RSDuration < 64)pTiming->ui8RSHold && (pTiming->ui8RSHold < 16)pTiming->ui8DelayCycles && (pTiming->ui8DelayCycles < 5)!(ui32Config & ~(LIDD_CONFIG_SYNC_MPU68 | LIDD_CONFIG_ASYNC_MPU68 | LIDD_CONFIG_SYNC_MPU80 | LIDD_CONFIG_ASYNC_MPU80 | LIDD_CONFIG_ASYNC_HITACHI | LIDD_CONFIG_INVERT_ALE | LIDD_CONFIG_INVERT_RS_EN | LIDD_CONFIG_INVERT_WS_DIR | LIDD_CONFIG_INVERT_CS0 | LIDD_CONFIG_INVERT_CS1))LCD0_BASE + 0x700x44050000 + 0x7011411783681141178480!(ui32Clocks & ~(LCD_CLOCK_MAIN | LCD_CLOCK_LIDD | LCD_CLOCK_DMA | LCD_CLOCK_CORE))ui32Base + LCD_O_CLKEN(LCD_CLKEN_DMA | LCD_CLKEN_CORE |
                                     LCD_CLKEN_LIDD)ui32Base + LCD_O_CTL(ui8Mode & ~(LCD_MODE_RASTER | LCD_MODE_LIDD | LCD_MODE_AUTO_UFLOW_RESTART)) == 0ui32Div < 256!((ui8Mode & LCD_MODE_RASTER) && (ui32Div < 2))//! is statically linked into the vector table in the application startup code.//! \note This function need not be called if the appropriate interrupt vector//! controller interrupt in the interrupt controller.//! This function unregisters the interrupt handler and disables the global LCD//! \param ui32Base specifies the LCD controller module base address.//! Unregisters the interrupt handler for the LCD controller module.//! module interrupt occurs.//! This function registers the handler to be called when the LCD controller//! controller interrupt occurs.//! \param pfnHandler is a pointer to the function to be called when the LCD//! Registers an interrupt handler for the LCD controller module.// Clear the requested interrupts.//! signaled.//! - \b LCD_INT_EOF2 - indicates that the raw End-of-Frame 1 has been//! - \b LCD_INT_EOF0 - indicates that the raw End-of-Frame 0 has been//! - \b LCD_INT_PAL_LOAD - indicates that the color palette has been loaded.//! send to the display.//! internal FIFO was empty when the output logic attempted to read data to//! - \b LCD_INT_UNDERFLOW - indicates that a data underflow occurred. The//! but remains disabled until this interrupt is cleared.//! The counter, set by a call to LCDRasterACBiasIntCountSet(), is reloaded//! has decremented to zero and is is valid for passive matrix panels only.//! - \b LCD_INT_AC_BIAS_CNT - indicates that that AC bias transition counter//! - \b LCD_INT_SYNC_LOST - indicates that frame synchronization was lost.//! complete.//! - \b LCD_INT_RASTER_FRAME_DONE - indicates that a raster-mode frame is//! - \b LCD_INT_DMA_DONE - indicates that a LIDD DMA transfer is complete.//! The specified LCD controller interrupt sources are cleared so that they no//! Clears LCD controller interrupt sources.// Return the raw interrupts status.// Return the masked interrupt status.// Were we asked for the masked or raw interrupt status?//! This function returns the interrupt status for the LCD controller.//! if the masked interrupt status is required.//! \param bMasked is false if the raw interrupt status is required and true//! Gets the current LCD controller interrupt status.// mask register.// Disable the interrupt sources by clearing the appropriate bits in the//! This function disables the indicated LCD controller interrupt sources.//! Disables individual LCD controller interrupt sources.// Enable the interrupt sources by setting the appropriate bits in the//! This function enables the indicated LCD controller interrupt sources.//! Enables individual LCD controller interrupt sources.// No - set the registers for frame buffer 1.// Yes - set the registers for frame buffer 0.// Are we setting the values for frame buffer 0?// Sanity check parameters.//! and the results are unpredictable.//! identifier and color table required by the hardware is not present//! enabling the raster output.  If this is not done, the pixel format//! function must be initialized using a call to LCDRasterPaletteSet() prior to//! If \b RASTER_LOAD_DATA_ONLY is not specified, frame buffers passed to this//! \e ui32NumBytes = (Palette Size) + ((Width * Height) * BPP) / 8)//! for the currently configured display resolution.//! be the palette size (if any) plus the size of the image bitmap required//! The frame buffer size, specified using the \e ui32NumBytes parameter, must//! use the lookup table.//! palette is still present even for 12, 16 and 24-bit formats, which do not//! uses a palette of 128 words (256 16-bit entries).  Note that the 8 word//! words (16 16-bit entries) for all pixel formats other than 8bpp which//! 32-bit words followed by the packed pixel data.  The palette size is 8//! In other cases, the frame buffer comprises a palette of either 8 or 128//! contains only packed pixel data in the required bit depth and format.//! was specified in a previous call to LCDRasterConfigSet(), the frame buffer//! the current raster configuration settings.  If \b RASTER_LOAD_DATA_ONLY//! The format of the frame buffer depends on the image type in use and//! configuration flag on a call to LCDDMAConfigSet()).//! is set to operate in ping-pong mode (by specifying the \b LCD_DMA_PING_PONG//! (configured when ui8Buffer is set to 1) is only used if the controller//! two supported frame buffers while in raster mode.  The second frame buffer//! This function is used to configure the position and size of one of the//! value must be a multiple of 4.//! \param ui32NumBytes specifies the size of the frame buffer in bytes.  This//! pointer must be aligned on a 32-bit (word) boundary.//! \param pui32Addr points to the first byte of the frame buffer.  This//! are 0 and 1.//! \param ui8Buffer specifies which frame buffer to configure.  Valid values//! Sets the LCD controller frame buffer start address and size in raster mode.// Write the pixel type into the first palette entry.// No - loop through the supplied 12-bit colors storing each.// and storing each.// Yes - loop through each of the supplied 24-bit colors converting// Are we converting the palette color format?// Get a pointer to the start of the palette.//! reformatting.//! the values are copied directly into the frame buffer palette without any//! the LCD controller with 2 colors stored in each 32-bit word.  In this case,//! \e pui32SrcColors array contains 12-bit colors in the format required by//! If \b LCD_PALETTE_SRC_24BIT is not present, it is assumed that the//! being written into the frame buffer palette.//! array are converted to the 12-bit format used by the LCD controller before//! stored in each 32-bit word.  In this case, the colors read from the source//! the 24-bit format as used by the TivaWare Graphics Library with one color//! to indicate that the supplied colors in the \e pui32SrcColors array are in//! Optionally, the \b LCD_PALETTE_SRC_24BIT flag may be ORed into \e ui32Type//! previously passed to LCDRasterConfigSet().//! pixels in the frame buffer is defined by the \e ui32Config parameter//! uses the correct pixel type.  When this value is used, the format of the//! frame buffer type must still be initialized to ensure that the hardware//! 24 bit per pixel).  The color palette is not used in these modes, but the//! - \b LCD_PALETTE_TYPE_DIRECT indicates a direct color (12, 16 or//! buffer. This format requires a 256 entry palette.//! - \b LCD_PALETTE_TYPE_8BPP indicates an 8 bit per pixel frame//! buffer. This format requires a 4 entry palette.//! - \b LCD_PALETTE_TYPE_4BPP indicates a 4 bit per pixel frame//! - \b LCD_PALETTE_TYPE_2BPP indicates a 2 bit per pixel frame//! (monochrome) frame buffer.  This format requires a 2 entry palette.//! - \b LCD_PALETTE_TYPE_1BPP indicates a 1 bit per pixel//! type of frame buffer for which the palette is being initialized://! \e ui32Type must be set to one of the following values to indicate the//! used by the LCD controller.//! optionally converting them from 24-bit color format into the 12-bit format//! from a source buffer into the palette starting at the required index,//! first entry of the frame buffer and copies the requested number of colors//! beginning of a frame buffer.  It writes the relevant pixel type into the//! This function is used to initialize the color palette stored at the//! the frame buffer palette.//! \param ui32Count specifies the number of source colors to be copied into//! to update.//! \param ui32Start specifies the index of the first color in the palette//! written into the frame buffer palette.//! \param pui32SrcColors points to the first color value that is to be//! palette information is to be written.//! \param pui32Addr points to the start of the frame buffer into which the//! buffer and also the format of the source color values passed.//! \param ui32Type specifies the type of pixel data to be held in the frame//! Initializes the color palette in a frame buffer.// Write the DMA control register.//! display glitches.//! this case is likely to result in occasional FIFO underflows and associated//! buffers in external, EPI-connected memory.  Using a smaller burst size in//! \note DMA burst size \b LCD_DMA_BURST_16 should be set when using frame//! a frame.//! restarting the scan from the beginning of the buffer each time it completes//! first.  If this flag is clear, the DMA engine uses a single frame buffer,//! the second frame buffer and scans from there before moving back to the//! out from the first frame buffer, the DMA engine immediately moves to//! the controller to operate in double-buffered mode.  When data is scanned//! Additionally, \b LCD_DMA_PING_PONG may be specified.  This flag configures//! - \b LCD_DMA_BYTE_ORDER_2301//! - \b LCD_DMA_BYTE_ORDER_3210//! - \b LCD_DMA_BYTE_ORDER_1023//! - \b LCD_DMA_BYTE_ORDER_0123//! for an input 32-bit word ordered ``0123''.//! swapping within the DMA engine.  The label represents the output byte order//! The final group of flags set internal byte lane controls and allow byte//! - \b LCD_DMA_BURST_16//! - \b LCD_DMA_BURST_8//! - \b LCD_DMA_BURST_4//! - \b LCD_DMA_BURST_2//! - \b LCD_DMA_BURST_1//! transfer://! The second group of flags set the number of 32-bit words in each DMA burst//! - \b LCD_DMA_FIFORDY_512_WORDS//! - \b LCD_DMA_FIFORDY_256_WORDS//! - \b LCD_DMA_FIFORDY_128_WORDS//! - \b LCD_DMA_FIFORDY_64_WORDS//! - \b LCD_DMA_FIFORDY_32_WORDS//! - \b LCD_DMA_FIFORDY_16_WORDS//! - \b LCD_DMA_FIFORDY_8_WORDS//! FIFO before it signals that it is ready://! The first group of flags set the number of words that have to be in the//! contain one value from each of the following groups.//! The \e ui32Config parameter is a logical OR of various flags. It must//! from SRAM to the display panel when in raster mode.//! to the display when in LIDD mode or for transferring palette and pixel data//! controller.  This engine is responsible for performing bulk data transfers//! This function is used to configure the DMA engine within the LCD//! \param ui32Config provides flags defining the desired DMA parameters.//! Configures the LCD controller's internal DMA engine.// Disable the subpanel.//! value for the \e ui32NumBytes parameter.//! the display area by calling LCDRasterFrameBufferSet() with an appropriate//! the frame buffer size must be reconfigured to match the full dimensions of//! entire frame buffer image on the display.  After the subpanel is disabled,//! This function disables subpanel display mode and reverts to showing the//! Disables subpanel display mode.// Enable the subpanel.//! mode and is configured to drive an active matrix display.//! Subpanel display is only possible when the LCD controller is in raster//! LCDRasterFrameBufferSet().//! to match the desired subpanel size using a call to//! LCDRasterSubPanelEnable(), the frame buffer should have been reconfigured//! by a previous call to LCDRasterSubPanelConfigSet().  Prior to calling//! rather than image data in the number of lines and at the position specified//! This function enables subpanel display mode and displays a default color//! Enables subpanel display mode.// Set the second subpanel configuration register.// subpanel enabled if it already was.// Set the first subpanel configuration register, taking care to leave the// Adjust the line count into the 0-2047 range.//! the subpanel once it has been configured, call LCDRasterSubPanelEnable().//! The subpanel display mode is not enabled using this function.  To enable//! the subpanel area.//! appropriately to describe the required number of active video lines in//! LCDRasterFrameBufferSet() with the \e ui32NumBytes parameter set//! the subpanel size in use.  This configuration can be achieved by calling//! frame buffer to ensure that it contains the correct number of lines for//! When a subpanel is configured, the application must also reconfigure the//! is defined by \e ui32BottomLines.//! the value of \e ui32Flags.  The height of the bottom portion of the display//! positioned either at the top or bottom of the display as controlled by//! The subpanel area containing image data from the frame buffer may be//! an active matrix display.//! available when the LCD controller is in raster mode and configured to drive//! is fetched for lines containing the default color.  This feature is only//! buffer. This feature reduces SRAM bandwidth requirements because no data//! to be filled with a default color rather than image data from the frame//! The LCD controller provides a feature that allows a portion of the display//! the display not configured to show image data.//! \param ui32DefaultPixel is the 24-bit RGB color to show in the portion of//! enabled, otherwise they contain image data.//! these lines contain the default pixel color when the subpanel is//! portion of the display.  If \b LCD_SUBPANEL_AT_TOP is set in \e ui32Flags,//! \param ui32BottomLines defines the number of lines comprising the bottom//! bottom of the display and default color at the top.//! bottom portion, or \b LCD_SUBPANEL_AT_BOTTOM to show image data at the//! image data in the top portion of the display and default color in the//! \param ui32Flags may be either \b LCD_SUBPANEL_AT_TOP to show frame buffer//! Sets the position and size of the subpanel on the raster display.// Disable the raster engine.//! that the raster engine has stopped.//! after the final \b LCD_INT_RASTER_FRAME_DONE has been received, indicating//! end of the current frame. If the display is to be re-enabled, wait until//! \note Once disabled, the raster engine continues to scan data until the//! the attached display.//! This function disables the LCD controller raster output and stops driving//! Disables the raster output.// Return the current raster engine status.//! \return Returns \b true if the raster is enabled or \b false if it is//! This function may be used to query whether or not the raster output is//! Determines whether or not the raster output is currently enabled.// Enable the raster engine.// ensure correct operation of the raster engine.// Reset the module prior to starting the raster.  This is required to//! LCDRasterFrameBufferSet() must have been called.//! LCDDMAConfigSet(), LCDRasterTimingSet(), LCDRasterPaletteSet() and//! Prior to enabling the raster output, LCDModeSet(), LCDRasterConfigSet(),//! displaying the content of the current frame buffer on the attached panel.//! This function enables the LCD controller raster output and starts//! Enables the raster output.// Write the new value back to the register.// AC Bias interrupt count.// Get the existing raster timing 2 register value and mask in the new//! 0, no AC bias count interrupt is generated.//! each AC bias count interrupt (\b LCD_INT_AC_BIAS_CNT).  If \e ui8Count is//! This function is used to set the number of AC bias transitions between//! the AC bias count interrupt is asserted.  Valid values are from 0 to 15.//! \param ui8Count is the number of AC bias pin transitions to count before//! Sets the number of AC bias pin transitions per interrupt.// in the AC Bias interrupt field of RASTRTIM2.// Write the timing registers, taking care to preserve any existing value// Construct the values we need for the three raster timing registers.//! tLCDRasterTiming.//! For a definition of the timing parameters required, see the definition of//! This function is used in raster mode to set the panel size and sync timing//! \param pTiming points to a structure containing the desired timing//! Sets the LCD controller interface timing when in raster mode.// Write the raster control register.//! called, it is disabled as a result of the call.//! If the LCD controller's raster engine is enabled when this function is//! the least significant bits.//! the most significant bits.  When absent, the leftmost pixel is parsed from//! When this option is specified, the leftmost pixel in a word is taken from//! this option reverses the order in which frame buffer words are parsed.//! - \b RASTER_READ_ORDER_REVERSED when using 1, 2, 4 and 8bpp frame buffers,//! data from the frame buffer.//! - \b RASTER_LOAD_PALETTE_ONLY tells the controller to read only the palette//! is performed.//! from the frame buffer and to use the last palette read.  No palette load//! - \b RASTER_LOAD_DATA_ONLY tells the controller to read only pixel data//! being parsed from them.//! read from the frame buffer are byte swapped prior to individual pixels//! are extracted from words read from the frame buffer.  If specified, words//! with \b RASTER_READ_ORDER_REVERSED to determine how 1, 2 and 4bpp pixels//! - \b RASTER_NIBBLE_MODE_ENABLED enables nibble mode.  This parameter works//! blanking.//! - \b RASTER_ACTVID_DURING_BLANK sets Actvid to toggle during vertical//! Additionally, the following flags may be ORed into \e ui32Config://! for the display.//! most significant bits of each color component are sent to the grayscaler//! and uses a 16bpp frame buffer with pixels in 5:6:5 format.  Only the 4//! - \b RASTER_FMT_PASSIVE_COLOR_16BIT selects a passive matrix display//! data is sent to the grayscaler for the display.//! and uses a 12bpp frame buffer.  The palette is bypassed and 12-bit pixel//! - \b RASTER_FMT_PASSIVE_COLOR_12BIT selects a passive matrix display//! display that outputs 8 pixels on each pixel clock.//! - \b RASTER_FMT_PASSIVE_MONO_8PIX selects a monochrome, passive matrix//! display that outputs 4 pixels on each pixel clock.//! - \b RASTER_FMT_PASSIVE_MONO_4PIX selects a monochrome, passive matrix//! LCDRasterPaletteSet().//! defined by the value passed in the \e ui32Type parameter to//! data is described in 16-bit 5:6:5 format.  The frame buffer pixel format is//! and uses a 1, 2, 4 or 8bpp frame buffer with palette lookup.  Output color//! - \b RASTER_FMT_ACTIVE_PALETTIZED_16BIT selects an active matrix display//! parameter to LCDRasterPaletteSet().//! frame buffer pixel format is defined by the value passed in the \e ui32Type//! data is described in 12-bit format using bits 11:0 of the data bus.  The//! - \b RASTER_FMT_ACTIVE_PALETTIZED_12BIT selects an active matrix display//! word.//! and uses a 16-bit per pixel frame buffer with 2 pixels in each 32-bit//! - \b RASTER_FMT_ACTIVE_16BPP selects an active matrix display//! 32-bit word contains a single pixel and 8 bits of padding.//! and uses an unpacked 24-bit per pixel packet frame buffer where each//! - \b RASTER_FMT_ACTIVE_24BPP_UNPACKED selects an active matrix display//! are described within 3 consecutive 32-bit words.//! and uses a packed 24-bit per pixel packet frame buffer where 4 pixels//! - \b RASTER_FMT_ACTIVE_24BPP_PACKED selects an active matrix display//! select the required target panel type and output pixel format://! The \e ui32Config parameter must be defined as one of the following to//! and specifies the type of panel that the controller is to drive.//! This function configures the basic operating mode of the raster interface//! SRAM into the internal palette RAM of the controller.//! between each 16 halfword (16-bit) burst when loading the palette from//! \param ui8PalLoadDelay specifies the number of system clocks to wait//! attached display panel.//! \param ui32Config specifies properties of the raster interface and the// Enable the DMA engine and start the transaction.// Use CS1.// Use CS0.// Tell the controller which CS to use for the DMA transaction.// the first location after the data we want written.// address of the last word which contains data we want transfered and NOT// Set up the transfer.  Note that the ceiling register must contain the// transfer.// Make sure DMA is disabled so that enabling it triggers this new//! modes.//! \note CS1 is not available when operating in Sync MPU68 or Sync MPU80//! LCDIDDIndexedWrite(), LCDIDDIndexedRead() or LCDIDDDataRead().//! LCDIDDCommandWrite(), LCDIDDDataWrite(), LCDIDDStatusRead(),//! LCDIDDDMADisable() must be called to disable DMA access prior to calling//! the application wishes to use the CPU to communicate with the display,//! transfer functions may be called.  When the DMA transfer is complete and//! During the time that DMA is enabled, none of the other LCD LIDD data//! completed before initiating another transfer.//! caller is responsible for ensuring that any earlier DMA transfer has//! This function enables DMA mode prior to starting the transfer.  The//! LCD_INT_DMA_DONE interrupt.//! Completion of the DMA transfer is signaled by the \b//! DMA.  It is only valid when the LCD controller is in LIDD mode.//! This function writes a block of 16-bit data words to the display using//! be a multiple of 2.//! \param ui32Count is the number of 16-bit words to write.  This value must//! address must be aligned on a 32-bit word boundary.//! \param pui32Data is the address of the first 16-bit word to write.  This//! \param ui32CS specifies the chip select to use. Valid values are 0 and 1.//! in LIDD mode.//! Writes a block of data to the display using DMA when the LCD controller is// Return the data read.// Determine the data register to read.// Write the address.// Determine the address register to write.//! can be used.//! write to the panel, LCDIDDDMADisable() must be called before this function//! configured to expect DMA transactions.  If DMA was previously used to//! This function must not be called if the LIDD interface is currently//! and data bytes from the panel.//! LCDIDDStatusRead() and LCDIDDDataRead() may be used to read status//! function should not be used.  In this case, the functions//! When configured in Hitachi mode (\b LIDD_CONFIG_ASYNC_HITACHI), this//! that employ an external address latch.//! Intel (\b LIDD_CONFIG_SYNC_MPU80 or \b LIDD_CONFIG_ASYNC_MPU80) modes//! Motorola (\b LIDD_CONFIG_SYNC_MPU68 or \b LIDD_CONFIG_ASYNC_MPU68) or//! the LCD controller is in LIDD mode and configured to use either the//! This function reads a 16-bit word from a register in the display when//! \param ui16Addr is the address of the display register to read.//! Reads a given display register when the LCD controller is in LIDD mode.// Read the relevant data register.// Determine the register to read based on the CS value supplied.//! \return Returns the status word read from the display panel.//! inactive.//! controller is in LIDD mode.  A data read occurs with the ALE signal//! This function reads the 16-bit data word from the display when the LCD//! Reads a data word from the display when the LCD controller is in LIDD// Read the relevant status register.//! LIDD_CONFIG_ASYNC_HITACHI), this operation corresponds to a command mode//! active.  If the interface is configured in Hitachi mode (\b//! controller is in LIDD mode.  A status read occurs with the ALE signal//! This function reads the 16-bit status word from the display when the LCD//! Reads a status word from the display when the LCD controller is in LIDD// Determine the data register to write.//! command and data bytes to the panel.//! LCDIDDCommandWrite() and LCDIDDDataWrite() may be used to transfer//! function should not be used.  In this case the functions//! This function writes a 16-bit data word to a register in the display when//! \param ui16Data is the data to write.//! \param ui16Addr is the address of the display register to write.//! Writes data to a given display register when the LCD controller is in LIDD// Write the data value to the register.// Determine the register to write based on the CS value supplied.//! controller is in LIDD mode.  A data write occurs with the ALE signal//! This function writes a 16-bit data word to the display when the LCD//! \param ui16Data is the 16-bit data word to write.//! Writes a data value to the display when the LCD controller is in LIDD mode.// Write the command/address to the register.//! active.//! controller is in LIDD mode.  A command write occurs with the ALE signal//! This function writes a 16-bit command word to the display when the LCD//! \param ui16Cmd is the 16-bit command word to write.//! Writes a command to the display when the LCD controller is in LIDD mode.// Disable DMA.//! called.//! \note LIDD DMA mode is enabled automatically when LCDIDDDMAWrite() is//! DMA mode and allow CPU-initiated transactions to the display.//! LCDIDDIndexedWrite(), LCDIDDIndexedRead() or LCDIDDDataRead() to disable//! before calling LCDIDDCommandWrite(), LCDIDDDataWrite(), LCDIDDStatusRead(),//! this function must be called after completion of a DMA transaction and//! When the LCD controller is operating in LCD Interface Display Driver mode,//! Disables internal DMA operation when the LCD controller is in LIDD mode.// Write the appropriate LCD LIDD CS configuration register.// Convert the timings provided into a value ready for the register.//! tLCDIDDTiming.//! for each of the two supported chip selects offered by the LCD controller.//! for the various interface control signals.  Independent timings are stored//! This function is used in LIDD mode to set the setup, strobe and hold times//! \param ui32CS specifies the chip select whose timings are to be set.//! Sets the LCD controller interface timing when in LIDD mode.// Write the LIDD Control Register.//! active low.//! default, CS1 and E1 are active high.  If this flag is set, they become//! - \b LIDD_CONFIG_INVERT_CS1 - Chip Select 1/Enable 1 polarity control.  By//! default, CS0 and E0 are active high.  If this flag is set, they become//! - \b LIDD_CONFIG_INVERT_CS0 - Chip Select 0/Enable 0 polarity control.  By//! flag is set, WS becomes active high and Direction becomes write high/read//! By default, WS is active low and Direction write low/read high. If this//! - \b LIDD_CONFIG_INVERT_WS_DIR - Write Strobe/Direction polarity control.//! RS becomes active high and Enable active low.//! default, RS is active low and Enable is active high. If this flag is set,//! - \b LIDD_CONFIG_INVERT_RS_EN - Read Strobe/Enable polarity control.  By//! By default, ALE is active low.  If this flag is set, it becomes active//! - \b LIDD_CONFIG_INVERT_ALE - Address Latch Enable (ALE) polarity control.//! of various control signals://! Additional flags may be ORed into \e ui32Config to control the polarities//! LCDLP = DIR, LCDFP = ALE, LCDAC = E0, LCDMCLK = E1.//! - \b LIDD_CONFIG_ASYNC_HITACHI selects Hitachi (async) mode.  LCDCP = N/C,//! WS, LCDFP = ALE, LCDAC = CS0, LCDMCLK = CS1.//! - \b LIDD_CONFIG_ASYNC_MPU80 selects Async MPU80 mode.  LCDCP = RS, LCDLP =//! WS, LCDFP = ALE, LCDAC = CS0, LCDMCLK = MCLK.//! - \b LIDD_CONFIG_SYNC_MPU80 selects Sync MPU80 mode.  LCDCP = RS, LCDLP =//! DIR, LCDFP = ALE, LCDAC = CS0, LCDMCLK = CS1.//! - \b LIDD_CONFIG_ASYNC_MPU68 selects Async MPU68 mode.  LCDCP = EN, LCDLP =//! DIR, LCDFP = ALE, LCDAC = CS0, LCDMCLK = MCLK.//! - \b LIDD_CONFIG_SYNC_MPU68 selects Sync MPU68 mode.  LCDCP = EN, LCDLP =//! comprised of one of the following modes://! controller and the display panel.  The \e ui32Config parameter is//! mode and specifies the configuration of the interface between the//! This function is used when the LCD controller is configured in LIDD//! \param ui32Config defines the display interface configuration.//! Sets the LCD controller communication parameters when in LIDD mode.// Wait a while.// Remove software reset.// Reset the required LCD controller sub-module(s).//! resets.//! In all cases, LCD controller register values are preserved across these//! be reset.//! - \b LCD_CLOCK_CORE causes the core module, including the raster logic to//! - \b LCD_CLOCK_LIDD causes the LIDD submodule to be reset.//! - \b LCD_CLOCK_DMA causes the DMA controller submodule to be reset.//! - \b LCD_CLOCK_MAIN causes the entire LCD controller module to be reset.//! following clocks://! software control.  The \e ui32Clocks parameter is the logical OR of the//! This function allows sub-modules of the LCD controller to be reset under//! \param ui32Clocks defines the subset of clock domains to be reset.//! Resets one or more of the LCD controller clock domains.// the ASSERTS, but we guard against it just in case.// happen unless someone passed pathological arguments and builds without// Return the selected clock rate.  Finding ui32Div set to 0 should not// Write the LCDCTL register to set the mode.// Check that the calculated value is valid.// than the requested rate.// round the divisor up and ensure that the clock used is never faster// desired pixel clock.  Note that we set the division up so that we// Determine the clock divider to use to get as close as possible to the// Enable clocks to the LCD controller submodules.//! \return Returns the actual LCD controller pixel clock or MCLK rate set.//! to give the desired \e ui32PixClk rate.//! used to allow the LCD controller clock rate divisor to be correctly set//! The \e ui32SysClk parameter provides the current system clock rate and is//! value.//! are supported.  The rate set will, however, be no higher than the requested//! slightly from the desired rate due to the fact that only integer dividers//! ui32SysClk/2 and \e ui32SysClk/255.  The actual clock rate set may differ//! clock rate for the raster interface and valid values are between \e//! and \e ui32SysClk/255.  In raster mode, \e ui32PixClk specifies the pixel//! communication with the display and valid values are between \e ui32SysClk//! the LCD controller.  In LIDD mode, this value controls the MCLK used in//! The \e ui32PixClk parameter specifies the desired master clock for the//! restart automatically if a data underflow occurs.//! be ORed with either of these modes to indicate that the hardware should//! data and sync signals.  Additionally, \b LCD_MODE_AUTO_UFLOW_RESTART may//! is used to communicate with panels via a synchronous video interface using//! an asynchronous interface (CS, WE, OE, ALE, data) and \b LCD_MODE_RASTER//! LCD Interface Display Driver mode for character panels connected via//! LCD_MODE_LIDD or \b LCD_MODE_RASTER. \b LCD_MODE_LIDD is used to select//! its master clock. The \e ui8Mode parameter may be set to either \b//! This function sets the basic operating mode of the LCD controller and also//! \param ui32SysClk specifies the current system clock rate in Hz.//! clock rate in Hz.//! \param ui32PixClk specifies the desired LCD controller pixel or master//! \param ui8Mode specifies the basic operating mode to be used.//! Configures the basic operating mode and clock rate for the LCD controller.// until the hardware header is updated.// These are currently missing from hw_lcd.h and included here as a stopgap// lcd.c - Defines and Macros for the LCD Controller module./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/mpu.hMPU_RGN_DISABLEMPU_RGN_ENABLEMPU_SUB_RGN_DISABLE_7MPU_SUB_RGN_DISABLE_6MPU_SUB_RGN_DISABLE_5MPU_SUB_RGN_DISABLE_4MPU_SUB_RGN_DISABLE_3MPU_SUB_RGN_DISABLE_2MPU_SUB_RGN_DISABLE_1MPU_SUB_RGN_DISABLE_0MPU_RGN_PERM_PRV_RO_USR_RO0x06000000MPU_RGN_PERM_PRV_RO_USR_NO0x05000000MPU_RGN_PERM_PRV_RW_USR_RWMPU_RGN_PERM_PRV_RW_USR_ROMPU_RGN_PERM_PRV_RW_USR_NOMPU_RGN_PERM_PRV_NO_USR_NOMPU_RGN_PERM_NOEXECMPU_RGN_PERM_EXECMPU_RGN_SIZE_4G(31 << 1)MPU_RGN_SIZE_2G(30 << 1)MPU_RGN_SIZE_1G(29 << 1)MPU_RGN_SIZE_512M(28 << 1)MPU_RGN_SIZE_256M(27 << 1)MPU_RGN_SIZE_128M(26 << 1)MPU_RGN_SIZE_64M(25 << 1)MPU_RGN_SIZE_32M(24 << 1)MPU_RGN_SIZE_16M(23 << 1)MPU_RGN_SIZE_8M(22 << 1)MPU_RGN_SIZE_4M(21 << 1)MPU_RGN_SIZE_2M(20 << 1)MPU_RGN_SIZE_1M(19 << 1)MPU_RGN_SIZE_512K(18 << 1)MPU_RGN_SIZE_256K(17 << 1)MPU_RGN_SIZE_128K(16 << 1)MPU_RGN_SIZE_64K(15 << 1)MPU_RGN_SIZE_32K(14 << 1)MPU_RGN_SIZE_16K(13 << 1)MPU_RGN_SIZE_8K(12 << 1)MPU_RGN_SIZE_4K(11 << 1)MPU_RGN_SIZE_2K(10 << 1)MPU_RGN_SIZE_1K(9 << 1)MPU_RGN_SIZE_512B(8 << 1)MPU_RGN_SIZE_256B(7 << 1)MPU_RGN_SIZE_128B(6 << 1)MPU_RGN_SIZE_64B(5 << 1)MPU_RGN_SIZE_32B(4 << 1)MPU_CONFIG_NONEMPU_CONFIG_HARDFLT_NMIMPU_CONFIG_PRIV_DEFAULT__DRIVERLIB_MPU_H__MPUIntUnregisterMPUIntRegisterMPURegionGetMPURegionSetMPURegionDisableMPURegionEnableMPURegionCountGetMPUDisableMPUEnable// __DRIVERLIB_MPU_H__// Flags to enable or disable a region, to be passed to MPURegionSet.// Flags for the sub-region to be passed to MPURegionSet.// Flags for the permissions to be passed to MPURegionSet.// Flags for the region size to be passed to MPURegionSet.// Flags that can be passed to MPUEnable.// mpu.h - Defines and Macros for the memory protection unit.ui32Regionpui32Flagsui32MPUConfig/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/mpu.c"driverlib/mpu.h"NVIC_MPU_NUMBER0xE000ED983758157208NVIC_MPU_BASE0xE000ED9C3758157212NVIC_MPU_BASE_ADDR_MNVIC_MPU_ATTR0xE000EDA03758157216ui32Region < 8NVIC_MPU_BASE_VALID3670016NVIC_MPU_ATTR_TEX_MNVIC_MPU_ATTR_CACHEABLE3801088(NVIC_MPU_ATTR_TEX_M |
                                           NVIC_MPU_ATTR_CACHEABLE)4291166207~(NVIC_MPU_ATTR_TEX_M |
                                           NVIC_MPU_ATTR_CACHEABLE)NVIC_MPU_ATTR_SHAREABLENVIC_MPU_ATTR_BUFFRABLEui32Addr == (ui32Addr & ~0 << (((ui32Flags & NVIC_MPU_ATTR_SIZE_M) >> 1) + 1))NVIC_MPU_ATTR_ENABLE~NVIC_MPU_ATTR_ENABLENVIC_MPU_TYPE0xE000ED903758157200NVIC_MPU_TYPE_DREGION_MNVIC_MPU_TYPE_DREGION_SNVIC_MPU_CTRL0xE000ED943758157204NVIC_MPU_CTRL_ENABLE~NVIC_MPU_CTRL_ENABLE!(ui32MPUConfig & ~(MPU_CONFIG_PRIV_DEFAULT | MPU_CONFIG_HARDFLT_NMI))//! memory management fault occurs.//! This function disables and clears the handler to be called when a//! Unregisters an interrupt handler for the memory management fault.// Enable the memory management fault.//! violation.//! generates a memory management fault due to a protection region access//! This function sets and enables the handler to be called when the MPU//! Registers an interrupt handler for the memory management fault.// Read and store the region attributes.// Read and store the base address for the region.// Select the region to get.//! preserved in the attributes that are saved.//! use with the MPURegionSet() function.  The region's enable state is//! This function can be used to save the configuration of a region for later//! MPURegionSet() function.//! meanings and format of the parameters is the same as that of the//! This function retrieves the configuration of a specific region.  The//! \param pui32Flags points to the attribute flags for the region.//! \param pui32Addr points to storage for the base address of the region.//! \param ui32Region is the region number to get.//! Gets the current settings for a specific region.// E Series memory.// and B bits to fixed values that are suitable for all Tiva C and// Program the region attributes.  Set the TEX field and the S, C,// region at the same time.// Program the base address, use the region field to select the//! Refer to the discussion of this in the API Detailed Description section.//! The safest way to handle this is to disable a region before changing it.//! region may occur while that region is in the process of being changed.//! from interrupts.  It is possible that an interrupt which accesses a//! \note This function writes to multiple registers and is not protected//! </code>//!  MPU_SUB_RGN_DISABLE_2 | MPU_RGN_ENABLE)//! (MPU_RGN_SIZE_32K | MPU_RGN_PERM_EXEC | MPU_RGN_PERM_PRV_RO_USR_RO |//! <code>//! would have the following value://! sub-region disabled, and initially enabled; the \e ui32Flags parameter//! 32 KB, execution enabled, read-only for both privileged and user, one//! As an example, to set a region with the following attributes: size of//! - \b MPU_RGN_DISABLE//! - \b MPU_RGN_ENABLE//! Finally, the region can be initially enabled or disabled with one of//! - \b MPU_SUB_RGN_DISABLE_7//! - \b MPU_SUB_RGN_DISABLE_6//! - \b MPU_SUB_RGN_DISABLE_5//! - \b MPU_SUB_RGN_DISABLE_4//! - \b MPU_SUB_RGN_DISABLE_3//! - \b MPU_SUB_RGN_DISABLE_2//! - \b MPU_SUB_RGN_DISABLE_1//! - \b MPU_SUB_RGN_DISABLE_0//! can be disabled with a logical OR of any of the following flags://! by another region with different attributes.  Any of the 8 sub-regions//! creation of ``holes'' in a region which can be left open, or overlaid//! or larger.  Any of these 8 sub-regions can be disabled, allowing for//! the MPU.  Sub-regions can only be used in regions of size 256 bytes//! The region is automatically divided into 8 equally-sized sub-regions by//! - \b MPU_RGN_PERM_PRV_RO_USR_RO - privileged read-only, user read-only//! - \b MPU_RGN_PERM_PRV_RO_USR_NO - privileged read-only, user no access//! - \b MPU_RGN_PERM_PRV_RW_USR_RW - privileged read/write, user read/write//! - \b MPU_RGN_PERM_PRV_RW_USR_RO - privileged read/write, user read-only//! - \b MPU_RGN_PERM_PRV_RW_USR_NO - privileged read/write, user no access//! - \b MPU_RGN_PERM_PRV_NO_USR_NO - no access in privileged or user mode//! privileged and user modes.  The read/write access flags must be one//! The read/write access permissions are applied separately for the//! - \b MPU_RGN_PERM_NOEXEC disables the region for execution of code//! - \b MPU_RGN_PERM_EXEC enables the region for execution of code//! The execute permission flag must be one of the following://! - \b MPU_RGN_SIZE_4G//! - \b MPU_RGN_SIZE_2G//! - \b MPU_RGN_SIZE_1G//! - \b MPU_RGN_SIZE_512M//! - \b MPU_RGN_SIZE_256M//! - \b MPU_RGN_SIZE_128M//! - \b MPU_RGN_SIZE_64M//! - \b MPU_RGN_SIZE_32M//! - \b MPU_RGN_SIZE_16M//! - \b MPU_RGN_SIZE_8M//! - \b MPU_RGN_SIZE_4M//! - \b MPU_RGN_SIZE_2M//! - \b MPU_RGN_SIZE_1M//! - \b MPU_RGN_SIZE_512K//! - \b MPU_RGN_SIZE_256K//! - \b MPU_RGN_SIZE_128K//! - \b MPU_RGN_SIZE_64K//! - \b MPU_RGN_SIZE_32K//! - \b MPU_RGN_SIZE_16K//! - \b MPU_RGN_SIZE_8K//! - \b MPU_RGN_SIZE_4K//! - \b MPU_RGN_SIZE_2K//! - \b MPU_RGN_SIZE_1K//! - \b MPU_RGN_SIZE_512B//! - \b MPU_RGN_SIZE_256B//! - \b MPU_RGN_SIZE_128B//! - \b MPU_RGN_SIZE_64B//! - \b MPU_RGN_SIZE_32B//! The size flag determines the size of a region and must be one of the//! and a flag to determine if the region is enabled.//! execute permission, read/write permissions, disabled sub-regions,//! of the region.  It is a combination of choices for region size,//! The \e ui32Flags parameter is the logical OR of all of the attributes//! the size must be a power of 2.//! address parameter, \e ui32Addr, must be aligned according to the size, and//! a base address and a set of attributes including the size.  The base//! This function sets up the protection rules for a region.  The region has//! \param ui32Flags is a set of flags to define the attributes of the region.//! according to the size of the region specified in ui32Flags.//! \param ui32Addr is the base address of the region.  It must be aligned//! \param ui32Region is the region number to set up.//! Sets up the access rules for a specific region.// Modify the enable bit in the region attributes.// Select the region to modify.//! MPURegionEnable().//! another call to MPURegionSet(), and can be enabled again by calling//! region.  The region remains configured if it is not overwritten with//! This function is used to disable a previously enabled memory protection//! \param ui32Region is the region number to disable.//! Disables a specific region.//! violations cause a memory management fault.//! enabled, the memory protection rules of the region are applied and access//! should already be configured with the MPURegionSet() function.  Once//! This function is used to enable a memory protection region.  The region//! \param ui32Region is the region number to enable.//! Enables a specific region.// the bits of interest to get the count of regions.// Read the DREGION field of the MPU type register and mask off//! for programming using MPURegionSet().//! \return The number of memory protection regions that are available//! by the MPU, including regions that are already programmed.//! This function is used to get the total number of regions that are supported//! Gets the count of regions supported by the MPU.// Turn off the MPU enable bit.//! faults are not generated.//! MPU is disabled, the default memory map is used and memory management//! This function disables the Cortex-M memory protection unit.  When the//! Disables the MPU for use.// and also set the enable bit.// Set the MPU control bits according to the flags passed by the user,//! enabled in the fault handlers.//! no default memory map is provided in privileged mode, and the MPU is not//! - \b MPU_CONFIG_NONE chooses none of the above options.  In this case,//! memory map is applied.//! disabled while in one of these exception handlers and the default//! exception handler.  If this option is not enabled, then the MPU is//! - \b MPU_CONFIG_HARDFLT_NMI enables the MPU while in a hard fault or NMI//! defined when the MPU is enabled.//! is not enabled, then there must be at least one valid region already//! privileged mode and when no other regions are defined.  If this option//! - \b MPU_CONFIG_PRIV_DEFAULT enables the default memory map when in//! The \e ui32MPUConfig parameter should be the logical OR of any of the//! generated for memory access violations.//! MPUEnable().  Once the MPU is enabled, a memory management fault is//! privileged mode by passing the \b MPU_CONFIG_PRIV_DEFAULT flag to//! be set by calling MPURegionSet() or else by enabling the default region for//! a hard fault or NMI.  Prior to enabling the MPU, at least one region must//! configures the default behavior when in privileged mode and while handling//! This function enables the Cortex-M memory protection unit.  It also//! \param ui32MPUConfig is the logical OR of the possible configurations.//! Enables and configures the MPU for use.//! \addtogroup mpu_api// mpu.c - Driver for the Cortex-M3 memory protection unit (MPU)./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/inc/hw_onewire.hONEWIRE_PP_CNT_SONEWIRE_PP_CNT_MONEWIRE_PP_DMAPONEWIRE_DMA_RSTONEWIRE_DMA_DMAOP_RDMULONEWIRE_DMA_DMAOP_WRMULONEWIRE_DMA_DMAOP_RDSNGONEWIRE_DMA_DMAOP_DISONEWIRE_DMA_DMAOP_MONEWIRE_DMA_SGONEWIRE_ICR_RSTONEWIRE_ICR_OPCONEWIRE_ICR_NOATRONEWIRE_ICR_STUCKONEWIRE_ICR_DMAONEWIRE_MIS_RSTONEWIRE_MIS_OPCONEWIRE_MIS_NOATRONEWIRE_MIS_STUCKONEWIRE_MIS_DMAONEWIRE_RIS_RSTONEWIRE_RIS_OPCONEWIRE_RIS_NOATRONEWIRE_RIS_STUCKONEWIRE_RIS_DMAONEWIRE_IM_RSTONEWIRE_IM_OPCONEWIRE_IM_NOATRONEWIRE_IM_STUCKONEWIRE_IM_DMAONEWIRE_DATR_B0_SONEWIRE_DATR_B1_SONEWIRE_DATR_B2_SONEWIRE_DATR_B3_SONEWIRE_DATR_B0_MONEWIRE_DATR_B1_MONEWIRE_DATR_B2_MONEWIRE_DATR_B3_MONEWIRE_DATW_B0_SONEWIRE_DATW_B1_SONEWIRE_DATW_B2_SONEWIRE_DATW_B3_SONEWIRE_DATW_B0_MONEWIRE_DATW_B1_MONEWIRE_DATW_B2_MONEWIRE_DATW_B3_MONEWIRE_TIM_RSTTIM_SONEWIRE_TIM_ATRTIM_SONEWIRE_TIM_ATRSAM_SONEWIRE_TIM_W1SAM_SONEWIRE_TIM_W0REST_SONEWIRE_TIM_W0TIM_SONEWIRE_TIM_W1TIM_SONEWIRE_TIM_RSTTIM_MONEWIRE_TIM_ATRTIM_MONEWIRE_TIM_ATRSAM_M0x00007800ONEWIRE_TIM_W1SAM_M0x00078000ONEWIRE_TIM_W0REST_MONEWIRE_TIM_W0TIM_M0x0F800000ONEWIRE_TIM_W1TIM_MONEWIRE_CS_SZ_SONEWIRE_CS_RSTONEWIRE_CS_OP_WRRDONEWIRE_CS_OP_WRONEWIRE_CS_OP_RDONEWIRE_CS_OP_NONEONEWIRE_CS_OP_MONEWIRE_CS_SZ_MONEWIRE_CS_ODRVONEWIRE_CS_LSAMONEWIRE_CS_SKATRONEWIRE_CS_BUSYONEWIRE_CS_NOATRONEWIRE_CS_STUCKONEWIRE_CS_BSIZE_7ONEWIRE_CS_BSIZE_6ONEWIRE_CS_BSIZE_5ONEWIRE_CS_BSIZE_4ONEWIRE_CS_BSIZE_3ONEWIRE_CS_BSIZE_2ONEWIRE_CS_BSIZE_1ONEWIRE_CS_BSIZE_8ONEWIRE_CS_BSIZE_MONEWIRE_CS_ALTPONEWIRE_CS_USEALTONEWIRE_O_PPONEWIRE_O_DMAONEWIRE_O_ICRONEWIRE_O_MISONEWIRE_O_RISONEWIRE_O_IMONEWIRE_O_DATRONEWIRE_O_DATWONEWIRE_O_TIMONEWIRE_O_CS__HW_ONEWIRE_H__// __HW_ONEWIRE_H__// 1-Wire Bus Count// uDMA Present// The following are defines for the bit fields in the ONEWIRE_O_PP register.// uDMA Reset// ONEWIREDATR register// start after uDMA has read the// read occurs and subsequent reads// uDMA multiple read: An initial// empty// the ONEWIREDATW register is// requests uDMA to load whenever// uDMA multiple write: 1-Wire// read transaction// ONEWIREDATR register after each// requests uDMA to read// uDMA single read: 1-Wire// uDMA disabled// uDMA Operation// Scatter-Gather Enable// The following are defines for the bit fields in the ONEWIRE_O_DMA register.// Reset Interrupt Clear// Operation Complete Interrupt// No Answer-to-Reset Interrupt// Stuck Status Interrupt Clear// DMA Done Interrupt Clear// The following are defines for the bit fields in the ONEWIRE_O_ICR register.// Reset Interrupt Mask// Operation Complete Masked// No Answer-to-Reset Masked// Stuck Status Masked Interrupt// DMA Done Masked Interrupt Status// The following are defines for the bit fields in the ONEWIRE_O_MIS register.// Reset Raw Interrupt Status// Operation Complete Raw Interrupt// No Answer-to-Reset Raw Interrupt// Stuck Status Raw Interrupt// DMA Done Raw Interrupt Status// The following are defines for the bit fields in the ONEWIRE_O_RIS register.// Stuck Status Interrupt Mask// DMA Done Interrupt Mask// The following are defines for the bit fields in the ONEWIRE_O_IM register.// Lowest Data Byte// Lower Middle Data Byte// Upper Middle Data Byte// Upper Data Byte// The following are defines for the bit fields in the ONEWIRE_O_DATR register.// The following are defines for the bit fields in the ONEWIRE_O_DATW register.// Reset Low Time// Answer-to-Reset/Rest Period// Answer-to-Reset Sample// Sample Time// Rest Time// Value '0' Timing// Value '1' Timing// The following are defines for the bit fields in the ONEWIRE_O_TIM register.// Reset Request// Write/Read// Operation Request// Data Operation Size// Overdrive Enable// Late Sample Enable// Skip Answer-to-Reset Enable// Busy Status// Answer-to-Reset Status// STUCK Status// 7 bits// 6 bits// 5 bits// 4 bits// 3 bits// 2 bits// 1 bit// 8 bits (1 byte)// Last Byte Size// Alternate Polarity Enable// Two Wire Enable// The following are defines for the bit fields in the ONEWIRE_O_CS register.// 1-Wire Peripheral Properties// 1-Wire uDMA Control// 1-Wire Interrupt Clear// 1-Wire Masked Interrupt Status// 1-Wire Raw Interrupt Status// 1-Wire Interrupt Mask// 1-Wire Data Read// 1-Wire Data Write// 1-Wire Timing Override// 1-Wire Control and Status// The following are defines for the One wire register offsets.// hw_onewire.h - Macros used when accessing the One wire hardware./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/onewire.hONEWIRE_INT_DMA_DONEONEWIRE_INT_STUCKONEWIRE_INT_NO_SLAVEONEWIRE_INT_OP_DONEONEWIRE_INT_RESET_DONEONEWIRE_DMA_OP_SZ_32ONEWIRE_DMA_OP_SZ_16ONEWIRE_DMA_OP_SZ_8ONEWIRE_DMA_MODE_SGONEWIRE_DMA_OP_MULTI_READONEWIRE_DMA_OP_MULTI_WRITEONEWIRE_DMA_OP_READONEWIRE_DMA_BUS_RESETONEWIRE_OP_WRITEONEWIRE_OP_READONEWIRE_OP_RESETONEWIRE_BUS_STATUS_STUCKONEWIRE_BUS_STATUS_NO_SLAVEONEWIRE_BUS_STATUS_BUSYONEWIRE_INIT_2_WIRE_CFGONEWIRE_INIT_1_WIRE_CFGONEWIRE_INIT_ALT_POLONEWIRE_INIT_STD_POLONEWIRE_INIT_NO_ATRONEWIRE_INIT_ATRONEWIRE_INIT_READ_LATEONEWIRE_INIT_READ_STDONEWIRE_INIT_SPD_ODONEWIRE_INIT_SPD_STD__DRIVERLIB_ONEWIRE_H__OneWireTransactionOneWireIntStatusOneWireIntUnregisterOneWireIntRegisterOneWireIntEnableOneWireIntDisableOneWireIntClearOneWireInitOneWireDMAEnableOneWireDMADisableOneWireDataGetNonBlockingOneWireDataGetOneWireBusStatusOneWireBusReset// __DRIVERLIB_ONEWIRE_H__// This interrupt indicates a OneWire DMA operation has completed.// operations.// This interrupt indicates the bus is being held low outside of normal// on the bus after a reset.// This interrupt indicates that no presence detect was signaled by a slave// has just completed.// The interrupt indicates a Read or Write master initiated operation// This interrupt indicates a bus reset has just completed.// OneWireIntDisable(), OneWireIntClear() and returned by OneWireIntStatus().// OneWire interrupt defines.  Use in calls to OneWireIntEnable(),// the uDMA channel setup.// DMA expects a Read/Write bus operation size of 32 bits.  This should match// DMA expects a Read/Write bus operation size of 16 bits.  This should match// DMA expects a Read/Write bus operation size of 8 bits.  This should match// transition completion thereafter.// the 1-Wire DMA to initiate an operation at the start of and then on each// This Scatter Gather DMA mode is paired with ONEWIRE_DMA_OP_READ to instruct// read operation completes.// The DMA will read values from the 1-Wire interface as each previous DMA// write operation completes.// The DMA will write values to the 1-Wire interface as each previous DMA// The DMA operation will be a single Read after each module transaction.// This indicates the DMA should issue a 1-Wire bus reset before starting.// OneWire DMA used with OneWireDMAEnable().// This mode flag indicates a write operation.// This mode flag indicates a read operation.// and/or read operation.// This mode flag indicates a single reset should be issued prior to a write// OneWire operation modes used with OneWireTransaction().// Write or Reset activity.// This will be set if the bus is being held low outside of a normal Read,// after a bus reset.// This will be set if the module did not detect any slave presence pulses// Reset activity.// This will be set if the bus is busy handling a Read, Write or// OneWireBusStatus().// Defines for bus status conditions.  These values can be returned by// for RX.// mode where one pin is used exclusively for TX operations and the other// This define is used in initialization to request a 2 pin operational// mode.  This is the default.// This define is used in initialization to request normal 1-Wire operational// on the 1-Wire bus (pin is driven high to drive bus low).// This define is used in initialization to request alternate signal polarity// default.// on the 1-Wire bus (pin is driven low to drive bus low).  This is the// This define is used in initialization to request standard signal polarity// reset for the expected presence detect period in this case.// (presence detect) monitor.  The module will delay operations after a bus// This define is used in initialization to request no Answer-to-Reset// Answer-to-Reset (presence detect) monitor.  This is the default.// This define is used in initialization to request a standard// timing (7us for ONEWIRE_INIT_SPD_OD and 50us for ONEWIRE_INIT_SPD_STD).// This define is used in initialization to request late read sampling// This is the default.// timing (2us for ONEWIRE_INIT_SPD_OD and 16us for ONEWIRE_INIT_SPD_STD).// This define is used in initialization to request standard read sampling// timings.// This define is used in initialization to request overdrive speed bus// timings.  This is the default.// This define is used in initialization to request standard speed bus// Defines used in the OneWireInit() function call.//! \addtogroup onewire_api// onewire.h - Prototypes for the OneWire Driver.ui32OpFlagsui32BitCntui32InitFlagsui32DMAFlagsu3i2Base/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/onewire.c"driverlib/onewire.h""inc/hw_onewire.h"ui32Transactionui32Base + ONEWIRE_O_CS458782ONEWIRE_TXN_MASK(ONEWIRE_TXN_MASK)4294508513~(ONEWIRE_TXN_MASK)(ONEWIRE_OP_RESET | ONEWIRE_OP_WRITE |
                                      ONEWIRE_OP_READ)ui32Base + ONEWIRE_O_DATW(ONEWIRE_CS_OP_WR | ONEWIRE_CS_OP_RD)ONEWIRE_TXN_SIZE_LSHIFTONEWIRE_TXN_BSIZE_LSHIFTui32Base == ONEWIRE0_BASE(ui32OpMode & (ONEWIRE_OP_RESET | ONEWIRE_OP_WRITE | ONEWIRE_OP_READ)) > 0(ui32BitCnt >= 1) && (ui32BitCnt <= 32)ui32Base + ONEWIRE_O_DMA(ONEWIRE_DMA_DMAOP_RDSNG | ONEWIRE_DMA_DMAOP_RDMUL)0xffffffffui32DMAFlags > 0_OneWireIntNumberGetui32Base + ONEWIRE_O_MISui32Base + 0x00000108ui32Base + ONEWIRE_O_RISui32Base + ONEWIRE_O_IM(ui32IntFlags & ~(ONEWIRE_IM_RST | ONEWIRE_IM_OPC | ONEWIRE_IM_DMA | ONEWIRE_IM_NOATR | ONEWIRE_IM_STUCK)) == 0ui32Base + ONEWIRE_O_ICRui32Base + ONEWIRE_O_DATR(ONEWIRE_CS_BUSY |
                                             ONEWIRE_CS_NOATR |
                                             ONEWIRE_CS_STUCK)(ONEWIRE_CS_OP_M | ONEWIRE_CS_SZ_M | ONEWIRE_CS_BSIZE_M)// Start the transaction.// Load the data into the write register.// Write specific setup.// byte therein.// specified as 1-4 bytes and the specific bit size for the last// Configure the 1-Wire module for the transaction size.  This is// set up for a read or write transaction.// Add the user specified operation flags.// bit fields.// Read the control register and clear any transaction related//! performed prior to the read.//! \note If both a read and write operation are requested, the write will be//! - \b ONEWIRE_OP_READ - A read operation//! - \b ONEWIRE_OP_WRITE - A write operation//!   a bus reset.//! - \b ONEWIRE_OP_RESET - Indicates the operation should be started with//! logical OR of the following://! The \e ui32OpMode defines the activity for the bus operations and is a//! read or write transaction.//! the bus.  The application should confirm the bus is idle before starting a//! This function performs a 1-Wire protocol transaction, read and/or write, on//! operation.//! \param ui32BitCnt specifies the number of valid bits (1-32) for the//! \param ui32Data is the data for a write operation.//! \param ui32OpMode sets the transaction type.//! \param ui32Base specifies the base address of the 1-Wire module.//! Performs a 1-Wire protocol transaction on the bus.// Write DATW to trigger DMA receive start.// Workaround for Snowflake DMA receive trigger errata.// scatter-gather operations.// will trigger the DMA reads to start.  This should not be done for// If a read transaction was requested, seed the write data register.  This// Enable DMA with the parameters provided.// set up the transaction size.//! used with the 1-Wire module.//! \note The uDMA controller must be properly configured before DMA can be//! - \b ONEWIRE_DMA_OP_SZ_32 - Bus read/write of 32 bits//! - \b ONEWIRE_DMA_OP_SZ_16 - Bus read/write of 16 bits//! - \b ONEWIRE_DMA_OP_SZ_8 - Bus read/write of 8 bits//!   completion//! - \b ONEWIRE_DMA_MODE_SG - Start DMA on enable then repeat on each//! - \b ONEWIRE_DMA_OP_MULTI_READ - Read after each previous read//! - \b ONEWIRE_DMA_OP_MULTI_WRITE - Write after each previous write//! - \b ONEWIRE_DMA_OP_READ - Read after each module transaction//! - \b ONEWIRE_DMA_BUS_RESET - Issue a 1-Wire bus reset before starting//! The \e ui32DMAFlags parameter is a combination of the following://! read operations, and scatter-gather support of mixed operations.//! can be configured for write operations, read operations, small write and//! This function enables the specified 1-Wire DMA features.  The 1-Wire module//! \param ui32DMAFlags is a bit mask of the DMA features to enable.//! \param ui32Base is the base address of the 1-Wire module.//! Enables 1-Wire DMA operations.// Disable the DMA features as requested.// Clear the transaction size bits//! by OneWireDMAEnable().  The specified 1-Wire DMA features are disabled.//! This function is used to disable 1-Wire DMA features that were enabled//! \param ui32DMAFlags is a bit mask of the DMA features to disable.//! Disables 1-Wire DMA operations.// Disable the 1-Wire peripheral interrupt.// Get the actual interrupt number for the 1-Wire module.//! This function clears the handler to be called when an 1-Wire interrupt//! Unregisters an interrupt handler for the 1-Wire module.// Enable the 1-Wire peripheral interrupt.//! interrupt source via OneWireIntClear().//! necessary, it is the interrupt handler's responsibility to clear the//! specific 1-Wire interrupts must be enabled via OneWireIntEnable().  If//! This function sets the handler to be called when a 1-Wire interrupt occurs.//! 1-Wire interrupt occurs.//! Registers an interrupt handler for the 1-Wire module.// Find the valid interrupt number for the 1-Wire module.//! \return Returns a 1-Wire interrupt number or 0 if the interrupt does not//! base address passed in the \e ui32Base parameter.//! This function returns the interrupt number for the 1-Wire module with the//! \param ui32Base specifies the 1-Wire module base address.//! Returns the 1-Wire controller interrupt number.//! - \b ONEWIRE_INT_DMA_DONE - DMA operation has completed//! - \b ONEWIRE_INT_STUCK - Bus is being held low by non-master.//! - \b ONEWIRE_INT_NO_SLAVE - No presence detect was signaled by a slave.//! - \b ONEWIRE_INT_OP_DONE - Read or write operation completed.//! - \b ONEWIRE_INT_RESET_DONE - Bus reset has just completed.//! \return Returns the masked or raw 1-Wire interrupt status, as a bit field//! reflect to the processor can be returned.//! the raw interrupt status or the status of interrupts that are allowed to//! This function returns the interrupt status for the 1-Wire module.  Either//! \param bMasked is \b false if the raw interrupt status is required or//! Gets the current 1-Wire interrupt status.//!   read is done.//!   combined write and read operation was set up, the interrupt signals the//! - \b ONEWIRE_INT_OP_DONE - Read or write operation completed.  If a//! parameter can be a logical OR of any of the following://! disabled sources have no effect on the processor.  The \e ui32IntFlags//! This function enables the indicated 1-Wire interrupt sources.  Only the//! Enables individual 1-Wire module interrupt sources.//! \e ui32IntFlags parameter can be a logical OR of any of the following://! This function disables the indicated 1-Wire interrupt sources.  The//! Disables individual 1-Wire module interrupt sources.//! - \b ONEWIRE_INT_DMA_DONE - DMA operation has completed.//! keep the interrupts from being triggered again immediately upon exit.  The//! This function clears the specified 1-Wire interrupt sources so that they no//! Clears the 1-Wire module interrupt sources.// Notify the caller data was read from the read register.// Copy the data into the provided storage.// If the bus is busy, return without reading.//! bus was not idle and no data was read.//! \return Returns \b true if a data read was performed, or \b false if the//! not signal any 0-bit data, this read returns 0xffffffff.//! By protocol definition, bit data defaults to a 1.  Thus if a slave did//! the module.//! operations on the bus.  Otherwise it returns without reading the data from//! This function reads data from the 1-Wire module if there are no active//! \param pui32Data is a pointer to storage to hold the read data.//! Retrieves data from the 1-Wire interface.// Wait for any active operations to complete.//! 0xffffffff.//! a 1.  Thus if a slave did not signal any 0-bit data, this read returns//! operations are completed.  By protocol definition, bit data defaults to//! This function reads data from the 1-Wire module once all active bus// Return the status bits from control and status register.//! \return Returns the 1-Wire bus conditions if detected else zero.//! - \b ONEWIRE_BUS_STATUS_STUCK - The bus is being held low by non-master.//! - \b ONEWIRE_BUS_STATUS_NO_SLAVE - No slave presence pulses detected.//! - \b ONEWIRE_BUS_STATUS_BUSY - A read, write, or reset is active.//! module.  These conditions could be a logical OR of any of the following://! This function returns the 1-Wire bus conditions reported by the 1-Wire//! Retrieves the 1-Wire bus condition status.// Issue a bus reset.//! 1-Wire bus.//! This function causes the 1-Wire module to generate a reset signal on the//! Issues a reset on the 1-Wire bus.// Initialize control register.//! - \b ONEWIRE_INIT_2_WIRE_CFG - alternate 2-Wire (2 data pin) setup//! - \b ONEWIRE_INIT_1_WIRE_CFG - standard 1-Wire (1 data pin) setup//! - \b ONEWIRE_INIT_ALT_POL - alternate (reverse) signal polarity//! - \b ONEWIRE_INIT_STD_POL - normal signal polarity//! - \b ONEWIRE_INIT_NO_ATR - no answer-to-reset presence detect//! - \b ONEWIRE_INIT_ATR - standard answer-to-reset presence detect//! - \b ONEWIRE_INIT_READ_LATE - late read sampling timing//! - \b ONEWIRE_INIT_READ_STD - standard read sampling timing//! - \b ONEWIRE_INIT_SPD_OD - overdrive speed bus timings//! - \b ONEWIRE_INIT_SPD_STD - standard speed bus timings//! The \e ui32InitFlags parameter is a combination of the following://! This function configures and initializes the 1-Wire interface for use.//! \param ui32InitFlags provides the initialization flags.//! Initializes the 1-Wire module.// Left-shift value for the control register's last byte bit size.// Left-shift value for the control register's transaction size.// A bit mask for all transaction related fields in the 1-Wire control// onewire.c - Driver for OneWire master module.ui32OpMode/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/inc/hw_pwm.hPWM_X_FLTSTAT1_DCMP0PWM_X_FLTSTAT1_DCMP1PWM_X_FLTSTAT1_DCMP2PWM_X_FLTSTAT1_DCMP3PWM_X_FLTSTAT1_DCMP4PWM_X_FLTSTAT1_DCMP5PWM_X_FLTSTAT1_DCMP6PWM_X_FLTSTAT1_DCMP7PWM_X_FLTSTAT0_FAULT0PWM_X_FLTSTAT0_FAULT1PWM_X_FLTSTAT0_FAULT2PWM_X_FLTSTAT0_FAULT3PWM_X_FLTSEN_FAULT0PWM_X_FLTSEN_FAULT1PWM_X_FLTSEN_FAULT2PWM_X_FLTSEN_FAULT3PWM_EXT_3_OFFSET0x00000980PWM_EXT_2_OFFSETPWM_EXT_1_OFFSETPWM_EXT_0_OFFSETPWM_O_X_FLTSTAT1PWM_O_X_FLTSTAT0PWM_O_X_FLTSENPWM_X_MINFLTPER_SPWM_X_MINFLTPER_MPWM_X_FLTSRC1_DCMP0PWM_X_FLTSRC1_DCMP1PWM_X_FLTSRC1_DCMP2PWM_X_FLTSRC1_DCMP3PWM_X_FLTSRC1_DCMP4PWM_X_FLTSRC1_DCMP5PWM_X_FLTSRC1_DCMP6PWM_X_FLTSRC1_DCMP7PWM_X_FLTSRC0_FAULT0PWM_X_FLTSRC0_FAULT1PWM_X_FLTSRC0_FAULT2PWM_X_FLTSRC0_FAULT3PWM_X_DBFALL_DELAY_SPWM_X_DBFALL_DELAY_MPWM_X_DBRISE_DELAY_SPWM_X_DBRISE_DELAY_MPWM_X_DBCTL_ENABLEPWM_X_GENB_ACTZERO_ONEPWM_X_GENB_ACTZERO_ZEROPWM_X_GENB_ACTZERO_INVPWM_X_GENB_ACTZERO_NONEPWM_X_GENB_ACTZERO_MPWM_X_GENB_ACTLOAD_ONEPWM_X_GENB_ACTLOAD_ZEROPWM_X_GENB_ACTLOAD_INVPWM_X_GENB_ACTLOAD_NONEPWM_X_GENB_ACTLOAD_MPWM_X_GENB_ACTCMPAU_ONEPWM_X_GENB_ACTCMPAU_ZEROPWM_X_GENB_ACTCMPAU_INVPWM_X_GENB_ACTCMPAU_NONEPWM_X_GENB_ACTCMPAU_MPWM_X_GENB_ACTCMPAD_ONEPWM_X_GENB_ACTCMPAD_ZEROPWM_X_GENB_ACTCMPAD_INVPWM_X_GENB_ACTCMPAD_NONEPWM_X_GENB_ACTCMPAD_MPWM_X_GENB_ACTCMPBU_ONEPWM_X_GENB_ACTCMPBU_ZEROPWM_X_GENB_ACTCMPBU_INVPWM_X_GENB_ACTCMPBU_NONEPWM_X_GENB_ACTCMPBU_MPWM_X_GENB_ACTCMPBD_ONEPWM_X_GENB_ACTCMPBD_ZEROPWM_X_GENB_ACTCMPBD_INVPWM_X_GENB_ACTCMPBD_NONEPWM_X_GENB_ACTCMPBD_MPWM_X_GENA_ACTZERO_ONEPWM_X_GENA_ACTZERO_ZEROPWM_X_GENA_ACTZERO_INVPWM_X_GENA_ACTZERO_NONEPWM_X_GENA_ACTZERO_MPWM_X_GENA_ACTLOAD_ONEPWM_X_GENA_ACTLOAD_ZEROPWM_X_GENA_ACTLOAD_INVPWM_X_GENA_ACTLOAD_NONEPWM_X_GENA_ACTLOAD_MPWM_X_GENA_ACTCMPAU_ONEPWM_X_GENA_ACTCMPAU_ZEROPWM_X_GENA_ACTCMPAU_INVPWM_X_GENA_ACTCMPAU_NONEPWM_X_GENA_ACTCMPAU_MPWM_X_GENA_ACTCMPAD_ONEPWM_X_GENA_ACTCMPAD_ZEROPWM_X_GENA_ACTCMPAD_INVPWM_X_GENA_ACTCMPAD_NONEPWM_X_GENA_ACTCMPAD_MPWM_X_GENA_ACTCMPBU_ONEPWM_X_GENA_ACTCMPBU_ZEROPWM_X_GENA_ACTCMPBU_INVPWM_X_GENA_ACTCMPBU_NONEPWM_X_GENA_ACTCMPBU_MPWM_X_GENA_ACTCMPBD_ONEPWM_X_GENA_ACTCMPBD_ZEROPWM_X_GENA_ACTCMPBD_INVPWM_X_GENA_ACTCMPBD_NONEPWM_X_GENA_ACTCMPBD_MPWM_X_CMPB_SPWM_X_CMPB_MPWM_X_CMPA_SPWM_X_CMPA_MPWM_X_COUNT_SPWM_X_COUNT_MPWM_X_LOAD_SPWM_X_LOAD_MPWM_X_ISC_INTCNTZEROPWM_X_ISC_INTCNTLOADPWM_X_ISC_INTCMPAUPWM_X_ISC_INTCMPADPWM_X_ISC_INTCMPBUPWM_X_ISC_INTCMPBDPWM_X_RIS_INTCNTZEROPWM_X_RIS_INTCNTLOADPWM_X_RIS_INTCMPAUPWM_X_RIS_INTCMPADPWM_X_RIS_INTCMPBUPWM_X_RIS_INTCMPBDPWM_X_INTEN_INTCNTZEROPWM_X_INTEN_INTCNTLOADPWM_X_INTEN_INTCMPAUPWM_X_INTEN_INTCMPADPWM_X_INTEN_INTCMPBUPWM_X_INTEN_INTCMPBDPWM_X_INTEN_TRCNTZEROPWM_X_INTEN_TRCNTLOADPWM_X_INTEN_TRCMPAUPWM_X_INTEN_TRCMPADPWM_X_INTEN_TRCMPBUPWM_X_INTEN_TRCMPBDPWM_X_CTL_ENABLEPWM_X_CTL_MODEPWM_X_CTL_DEBUGPWM_X_CTL_LOADUPDPWM_X_CTL_CMPAUPDPWM_X_CTL_CMPBUPDPWM_X_CTL_GENAUPD_GSPWM_X_CTL_GENAUPD_LSPWM_X_CTL_GENAUPD_IPWM_X_CTL_GENAUPD_MPWM_X_CTL_GENBUPD_GSPWM_X_CTL_GENBUPD_LSPWM_X_CTL_GENBUPD_IPWM_X_CTL_GENBUPD_MPWM_X_CTL_DBCTLUPD_GSPWM_X_CTL_DBCTLUPD_LSPWM_X_CTL_DBCTLUPD_IPWM_X_CTL_DBCTLUPD_MPWM_X_CTL_DBRISEUPD_GSPWM_X_CTL_DBRISEUPD_LSPWM_X_CTL_DBRISEUPD_IPWM_X_CTL_DBRISEUPD_MPWM_X_CTL_DBFALLUPD_GSPWM_X_CTL_DBFALLUPD_LSPWM_X_CTL_DBFALLUPD_IPWM_X_CTL_DBFALLUPD_MPWM_X_CTL_FLTSRCPWM_X_CTL_MINFLTPERPWM_X_CTL_LATCHPWM_GEN_3_OFFSETPWM_GEN_2_OFFSETPWM_GEN_1_OFFSETPWM_GEN_0_OFFSETPWM_O_X_MINFLTPERPWM_O_X_FLTSRC1PWM_O_X_FLTSRC0PWM_O_X_DBFALLPWM_O_X_DBRISEPWM_O_X_DBCTLPWM_O_X_GENBPWM_O_X_GENAPWM_O_X_CMPBPWM_O_X_CMPAPWM_O_X_COUNTPWM_O_X_LOADPWM_O_X_ISCPWM_O_X_RISPWM_O_X_INTENPWM_O_X_CTLPWM_CC_PWMDIV_64PWM_CC_PWMDIV_32PWM_CC_PWMDIV_16PWM_CC_PWMDIV_8PWM_CC_PWMDIV_4PWM_CC_PWMDIV_2PWM_CC_PWMDIV_MPWM_CC_USEPWMPWM_PP_FCNT_SPWM_PP_GCNT_SPWM_PP_ONEPWM_PP_EFAULTPWM_PP_ESYNCPWM_PP_FCNT_MPWM_PP_GCNT_MPWM_3_FLTSTAT1_DCMP0PWM_3_FLTSTAT1_DCMP1PWM_3_FLTSTAT1_DCMP2PWM_3_FLTSTAT1_DCMP3PWM_3_FLTSTAT1_DCMP4PWM_3_FLTSTAT1_DCMP5PWM_3_FLTSTAT1_DCMP6PWM_3_FLTSTAT1_DCMP7PWM_3_FLTSTAT0_FAULT0PWM_3_FLTSTAT0_FAULT1PWM_3_FLTSTAT0_FAULT2PWM_3_FLTSTAT0_FAULT3PWM_3_FLTSEN_FAULT0PWM_3_FLTSEN_FAULT1PWM_3_FLTSEN_FAULT2PWM_3_FLTSEN_FAULT3PWM_2_FLTSTAT1_DCMP0PWM_2_FLTSTAT1_DCMP1PWM_2_FLTSTAT1_DCMP2PWM_2_FLTSTAT1_DCMP3PWM_2_FLTSTAT1_DCMP4PWM_2_FLTSTAT1_DCMP5PWM_2_FLTSTAT1_DCMP6PWM_2_FLTSTAT1_DCMP7PWM_2_FLTSTAT0_FAULT0PWM_2_FLTSTAT0_FAULT1PWM_2_FLTSTAT0_FAULT2PWM_2_FLTSTAT0_FAULT3PWM_2_FLTSEN_FAULT0PWM_2_FLTSEN_FAULT1PWM_2_FLTSEN_FAULT2PWM_2_FLTSEN_FAULT3PWM_1_FLTSTAT1_DCMP0PWM_1_FLTSTAT1_DCMP1PWM_1_FLTSTAT1_DCMP2PWM_1_FLTSTAT1_DCMP3PWM_1_FLTSTAT1_DCMP4PWM_1_FLTSTAT1_DCMP5PWM_1_FLTSTAT1_DCMP6PWM_1_FLTSTAT1_DCMP7PWM_1_FLTSTAT0_FAULT0PWM_1_FLTSTAT0_FAULT1PWM_1_FLTSTAT0_FAULT2PWM_1_FLTSTAT0_FAULT3PWM_1_FLTSEN_FAULT0PWM_1_FLTSEN_FAULT1PWM_1_FLTSEN_FAULT2PWM_1_FLTSEN_FAULT3PWM_0_FLTSTAT1_DCMP0PWM_0_FLTSTAT1_DCMP1PWM_0_FLTSTAT1_DCMP2PWM_0_FLTSTAT1_DCMP3PWM_0_FLTSTAT1_DCMP4PWM_0_FLTSTAT1_DCMP5PWM_0_FLTSTAT1_DCMP6PWM_0_FLTSTAT1_DCMP7PWM_0_FLTSTAT0_FAULT0PWM_0_FLTSTAT0_FAULT1PWM_0_FLTSTAT0_FAULT2PWM_0_FLTSTAT0_FAULT3PWM_0_FLTSEN_FAULT0PWM_0_FLTSEN_FAULT1PWM_0_FLTSEN_FAULT2PWM_0_FLTSEN_FAULT3PWM_3_MINFLTPER_MFP_SPWM_3_MINFLTPER_MFP_MPWM_3_FLTSRC1_DCMP0PWM_3_FLTSRC1_DCMP1PWM_3_FLTSRC1_DCMP2PWM_3_FLTSRC1_DCMP3PWM_3_FLTSRC1_DCMP4PWM_3_FLTSRC1_DCMP5PWM_3_FLTSRC1_DCMP6PWM_3_FLTSRC1_DCMP7PWM_3_FLTSRC0_FAULT0PWM_3_FLTSRC0_FAULT1PWM_3_FLTSRC0_FAULT2PWM_3_FLTSRC0_FAULT3PWM_3_DBFALL_FALLDELAY_SPWM_3_DBFALL_FALLDELAY_MPWM_3_DBRISE_RISEDELAY_SPWM_3_DBRISE_RISEDELAY_MPWM_3_DBCTL_ENABLEPWM_3_GENB_ACTZERO_ONEPWM_3_GENB_ACTZERO_ZEROPWM_3_GENB_ACTZERO_INVPWM_3_GENB_ACTZERO_NONEPWM_3_GENB_ACTZERO_MPWM_3_GENB_ACTLOAD_ONEPWM_3_GENB_ACTLOAD_ZEROPWM_3_GENB_ACTLOAD_INVPWM_3_GENB_ACTLOAD_NONEPWM_3_GENB_ACTLOAD_MPWM_3_GENB_ACTCMPAU_ONEPWM_3_GENB_ACTCMPAU_ZEROPWM_3_GENB_ACTCMPAU_INVPWM_3_GENB_ACTCMPAU_NONEPWM_3_GENB_ACTCMPAU_MPWM_3_GENB_ACTCMPAD_ONEPWM_3_GENB_ACTCMPAD_ZEROPWM_3_GENB_ACTCMPAD_INVPWM_3_GENB_ACTCMPAD_NONEPWM_3_GENB_ACTCMPAD_MPWM_3_GENB_ACTCMPBU_ONEPWM_3_GENB_ACTCMPBU_ZEROPWM_3_GENB_ACTCMPBU_INVPWM_3_GENB_ACTCMPBU_NONEPWM_3_GENB_ACTCMPBU_MPWM_3_GENB_ACTCMPBD_ONEPWM_3_GENB_ACTCMPBD_ZEROPWM_3_GENB_ACTCMPBD_INVPWM_3_GENB_ACTCMPBD_NONEPWM_3_GENB_ACTCMPBD_MPWM_3_GENA_ACTZERO_ONEPWM_3_GENA_ACTZERO_ZEROPWM_3_GENA_ACTZERO_INVPWM_3_GENA_ACTZERO_NONEPWM_3_GENA_ACTZERO_MPWM_3_GENA_ACTLOAD_ONEPWM_3_GENA_ACTLOAD_ZEROPWM_3_GENA_ACTLOAD_INVPWM_3_GENA_ACTLOAD_NONEPWM_3_GENA_ACTLOAD_MPWM_3_GENA_ACTCMPAU_ONEPWM_3_GENA_ACTCMPAU_ZEROPWM_3_GENA_ACTCMPAU_INVPWM_3_GENA_ACTCMPAU_NONEPWM_3_GENA_ACTCMPAU_MPWM_3_GENA_ACTCMPAD_ONEPWM_3_GENA_ACTCMPAD_ZEROPWM_3_GENA_ACTCMPAD_INVPWM_3_GENA_ACTCMPAD_NONEPWM_3_GENA_ACTCMPAD_MPWM_3_GENA_ACTCMPBU_ONEPWM_3_GENA_ACTCMPBU_ZEROPWM_3_GENA_ACTCMPBU_INVPWM_3_GENA_ACTCMPBU_NONEPWM_3_GENA_ACTCMPBU_MPWM_3_GENA_ACTCMPBD_ONEPWM_3_GENA_ACTCMPBD_ZEROPWM_3_GENA_ACTCMPBD_INVPWM_3_GENA_ACTCMPBD_NONEPWM_3_GENA_ACTCMPBD_MPWM_3_CMPB_COMPB_SPWM_3_CMPB_COMPB_MPWM_3_CMPA_COMPA_SPWM_3_CMPA_COMPA_MPWM_3_COUNT_COUNT_SPWM_3_COUNT_COUNT_MPWM_3_LOAD_LOAD_SPWM_3_LOAD_LOAD_MPWM_3_ISC_INTCNTZEROPWM_3_ISC_INTCNTLOADPWM_3_ISC_INTCMPAUPWM_3_ISC_INTCMPADPWM_3_ISC_INTCMPBUPWM_3_ISC_INTCMPBDPWM_3_RIS_INTCNTZEROPWM_3_RIS_INTCNTLOADPWM_3_RIS_INTCMPAUPWM_3_RIS_INTCMPADPWM_3_RIS_INTCMPBUPWM_3_RIS_INTCMPBDPWM_3_INTEN_INTCNTZEROPWM_3_INTEN_INTCNTLOADPWM_3_INTEN_INTCMPAUPWM_3_INTEN_INTCMPADPWM_3_INTEN_INTCMPBUPWM_3_INTEN_INTCMPBDPWM_3_INTEN_TRCNTZEROPWM_3_INTEN_TRCNTLOADPWM_3_INTEN_TRCMPAUPWM_3_INTEN_TRCMPADPWM_3_INTEN_TRCMPBUPWM_3_INTEN_TRCMPBDPWM_3_CTL_ENABLEPWM_3_CTL_MODEPWM_3_CTL_DEBUGPWM_3_CTL_LOADUPDPWM_3_CTL_CMPAUPDPWM_3_CTL_CMPBUPDPWM_3_CTL_GENAUPD_GSPWM_3_CTL_GENAUPD_LSPWM_3_CTL_GENAUPD_IPWM_3_CTL_GENAUPD_MPWM_3_CTL_GENBUPD_GSPWM_3_CTL_GENBUPD_LSPWM_3_CTL_GENBUPD_IPWM_3_CTL_GENBUPD_MPWM_3_CTL_DBCTLUPD_GSPWM_3_CTL_DBCTLUPD_LSPWM_3_CTL_DBCTLUPD_IPWM_3_CTL_DBCTLUPD_MPWM_3_CTL_DBRISEUPD_GSPWM_3_CTL_DBRISEUPD_LSPWM_3_CTL_DBRISEUPD_IPWM_3_CTL_DBRISEUPD_MPWM_3_CTL_DBFALLUPD_GSPWM_3_CTL_DBFALLUPD_LSPWM_3_CTL_DBFALLUPD_IPWM_3_CTL_DBFALLUPD_MPWM_3_CTL_FLTSRCPWM_3_CTL_MINFLTPERPWM_3_CTL_LATCHPWM_2_MINFLTPER_MFP_SPWM_2_MINFLTPER_MFP_MPWM_2_FLTSRC1_DCMP0PWM_2_FLTSRC1_DCMP1PWM_2_FLTSRC1_DCMP2PWM_2_FLTSRC1_DCMP3PWM_2_FLTSRC1_DCMP4PWM_2_FLTSRC1_DCMP5PWM_2_FLTSRC1_DCMP6PWM_2_FLTSRC1_DCMP7PWM_2_FLTSRC0_FAULT0PWM_2_FLTSRC0_FAULT1PWM_2_FLTSRC0_FAULT2PWM_2_FLTSRC0_FAULT3PWM_2_DBFALL_FALLDELAY_SPWM_2_DBFALL_FALLDELAY_MPWM_2_DBRISE_RISEDELAY_SPWM_2_DBRISE_RISEDELAY_MPWM_2_DBCTL_ENABLEPWM_2_GENB_ACTZERO_ONEPWM_2_GENB_ACTZERO_ZEROPWM_2_GENB_ACTZERO_INVPWM_2_GENB_ACTZERO_NONEPWM_2_GENB_ACTZERO_MPWM_2_GENB_ACTLOAD_ONEPWM_2_GENB_ACTLOAD_ZEROPWM_2_GENB_ACTLOAD_INVPWM_2_GENB_ACTLOAD_NONEPWM_2_GENB_ACTLOAD_MPWM_2_GENB_ACTCMPAU_ONEPWM_2_GENB_ACTCMPAU_ZEROPWM_2_GENB_ACTCMPAU_INVPWM_2_GENB_ACTCMPAU_NONEPWM_2_GENB_ACTCMPAU_MPWM_2_GENB_ACTCMPAD_ONEPWM_2_GENB_ACTCMPAD_ZEROPWM_2_GENB_ACTCMPAD_INVPWM_2_GENB_ACTCMPAD_NONEPWM_2_GENB_ACTCMPAD_MPWM_2_GENB_ACTCMPBU_ONEPWM_2_GENB_ACTCMPBU_ZEROPWM_2_GENB_ACTCMPBU_INVPWM_2_GENB_ACTCMPBU_NONEPWM_2_GENB_ACTCMPBU_MPWM_2_GENB_ACTCMPBD_ONEPWM_2_GENB_ACTCMPBD_ZEROPWM_2_GENB_ACTCMPBD_INVPWM_2_GENB_ACTCMPBD_NONEPWM_2_GENB_ACTCMPBD_MPWM_2_GENA_ACTZERO_ONEPWM_2_GENA_ACTZERO_ZEROPWM_2_GENA_ACTZERO_INVPWM_2_GENA_ACTZERO_NONEPWM_2_GENA_ACTZERO_MPWM_2_GENA_ACTLOAD_ONEPWM_2_GENA_ACTLOAD_ZEROPWM_2_GENA_ACTLOAD_INVPWM_2_GENA_ACTLOAD_NONEPWM_2_GENA_ACTLOAD_MPWM_2_GENA_ACTCMPAU_ONEPWM_2_GENA_ACTCMPAU_ZEROPWM_2_GENA_ACTCMPAU_INVPWM_2_GENA_ACTCMPAU_NONEPWM_2_GENA_ACTCMPAU_MPWM_2_GENA_ACTCMPAD_ONEPWM_2_GENA_ACTCMPAD_ZEROPWM_2_GENA_ACTCMPAD_INVPWM_2_GENA_ACTCMPAD_NONEPWM_2_GENA_ACTCMPAD_MPWM_2_GENA_ACTCMPBU_ONEPWM_2_GENA_ACTCMPBU_ZEROPWM_2_GENA_ACTCMPBU_INVPWM_2_GENA_ACTCMPBU_NONEPWM_2_GENA_ACTCMPBU_MPWM_2_GENA_ACTCMPBD_ONEPWM_2_GENA_ACTCMPBD_ZEROPWM_2_GENA_ACTCMPBD_INVPWM_2_GENA_ACTCMPBD_NONEPWM_2_GENA_ACTCMPBD_MPWM_2_CMPB_COMPB_SPWM_2_CMPB_COMPB_MPWM_2_CMPA_COMPA_SPWM_2_CMPA_COMPA_MPWM_2_COUNT_COUNT_SPWM_2_COUNT_COUNT_MPWM_2_LOAD_LOAD_SPWM_2_LOAD_LOAD_MPWM_2_ISC_INTCNTZEROPWM_2_ISC_INTCNTLOADPWM_2_ISC_INTCMPAUPWM_2_ISC_INTCMPADPWM_2_ISC_INTCMPBUPWM_2_ISC_INTCMPBDPWM_2_RIS_INTCNTZEROPWM_2_RIS_INTCNTLOADPWM_2_RIS_INTCMPAUPWM_2_RIS_INTCMPADPWM_2_RIS_INTCMPBUPWM_2_RIS_INTCMPBDPWM_2_INTEN_INTCNTZEROPWM_2_INTEN_INTCNTLOADPWM_2_INTEN_INTCMPAUPWM_2_INTEN_INTCMPADPWM_2_INTEN_INTCMPBUPWM_2_INTEN_INTCMPBDPWM_2_INTEN_TRCNTZEROPWM_2_INTEN_TRCNTLOADPWM_2_INTEN_TRCMPAUPWM_2_INTEN_TRCMPADPWM_2_INTEN_TRCMPBUPWM_2_INTEN_TRCMPBDPWM_2_CTL_ENABLEPWM_2_CTL_MODEPWM_2_CTL_DEBUGPWM_2_CTL_LOADUPDPWM_2_CTL_CMPAUPDPWM_2_CTL_CMPBUPDPWM_2_CTL_GENAUPD_GSPWM_2_CTL_GENAUPD_LSPWM_2_CTL_GENAUPD_IPWM_2_CTL_GENAUPD_MPWM_2_CTL_GENBUPD_GSPWM_2_CTL_GENBUPD_LSPWM_2_CTL_GENBUPD_IPWM_2_CTL_GENBUPD_MPWM_2_CTL_DBCTLUPD_GSPWM_2_CTL_DBCTLUPD_LSPWM_2_CTL_DBCTLUPD_IPWM_2_CTL_DBCTLUPD_MPWM_2_CTL_DBRISEUPD_GSPWM_2_CTL_DBRISEUPD_LSPWM_2_CTL_DBRISEUPD_IPWM_2_CTL_DBRISEUPD_MPWM_2_CTL_DBFALLUPD_GSPWM_2_CTL_DBFALLUPD_LSPWM_2_CTL_DBFALLUPD_IPWM_2_CTL_DBFALLUPD_MPWM_2_CTL_FLTSRCPWM_2_CTL_MINFLTPERPWM_2_CTL_LATCHPWM_1_MINFLTPER_MFP_SPWM_1_MINFLTPER_MFP_MPWM_1_FLTSRC1_DCMP0PWM_1_FLTSRC1_DCMP1PWM_1_FLTSRC1_DCMP2PWM_1_FLTSRC1_DCMP3PWM_1_FLTSRC1_DCMP4PWM_1_FLTSRC1_DCMP5PWM_1_FLTSRC1_DCMP6PWM_1_FLTSRC1_DCMP7PWM_1_FLTSRC0_FAULT0PWM_1_FLTSRC0_FAULT1PWM_1_FLTSRC0_FAULT2PWM_1_FLTSRC0_FAULT3PWM_1_DBFALL_FALLDELAY_SPWM_1_DBFALL_FALLDELAY_MPWM_1_DBRISE_RISEDELAY_SPWM_1_DBRISE_RISEDELAY_MPWM_1_DBCTL_ENABLEPWM_1_GENB_ACTZERO_ONEPWM_1_GENB_ACTZERO_ZEROPWM_1_GENB_ACTZERO_INVPWM_1_GENB_ACTZERO_NONEPWM_1_GENB_ACTZERO_MPWM_1_GENB_ACTLOAD_ONEPWM_1_GENB_ACTLOAD_ZEROPWM_1_GENB_ACTLOAD_INVPWM_1_GENB_ACTLOAD_NONEPWM_1_GENB_ACTLOAD_MPWM_1_GENB_ACTCMPAU_ONEPWM_1_GENB_ACTCMPAU_ZEROPWM_1_GENB_ACTCMPAU_INVPWM_1_GENB_ACTCMPAU_NONEPWM_1_GENB_ACTCMPAU_MPWM_1_GENB_ACTCMPAD_ONEPWM_1_GENB_ACTCMPAD_ZEROPWM_1_GENB_ACTCMPAD_INVPWM_1_GENB_ACTCMPAD_NONEPWM_1_GENB_ACTCMPAD_MPWM_1_GENB_ACTCMPBU_ONEPWM_1_GENB_ACTCMPBU_ZEROPWM_1_GENB_ACTCMPBU_INVPWM_1_GENB_ACTCMPBU_NONEPWM_1_GENB_ACTCMPBU_MPWM_1_GENB_ACTCMPBD_ONEPWM_1_GENB_ACTCMPBD_ZEROPWM_1_GENB_ACTCMPBD_INVPWM_1_GENB_ACTCMPBD_NONEPWM_1_GENB_ACTCMPBD_MPWM_1_GENA_ACTZERO_ONEPWM_1_GENA_ACTZERO_ZEROPWM_1_GENA_ACTZERO_INVPWM_1_GENA_ACTZERO_NONEPWM_1_GENA_ACTZERO_MPWM_1_GENA_ACTLOAD_ONEPWM_1_GENA_ACTLOAD_ZEROPWM_1_GENA_ACTLOAD_INVPWM_1_GENA_ACTLOAD_NONEPWM_1_GENA_ACTLOAD_MPWM_1_GENA_ACTCMPAU_ONEPWM_1_GENA_ACTCMPAU_ZEROPWM_1_GENA_ACTCMPAU_INVPWM_1_GENA_ACTCMPAU_NONEPWM_1_GENA_ACTCMPAU_MPWM_1_GENA_ACTCMPAD_ONEPWM_1_GENA_ACTCMPAD_ZEROPWM_1_GENA_ACTCMPAD_INVPWM_1_GENA_ACTCMPAD_NONEPWM_1_GENA_ACTCMPAD_MPWM_1_GENA_ACTCMPBU_ONEPWM_1_GENA_ACTCMPBU_ZEROPWM_1_GENA_ACTCMPBU_INVPWM_1_GENA_ACTCMPBU_NONEPWM_1_GENA_ACTCMPBU_MPWM_1_GENA_ACTCMPBD_ONEPWM_1_GENA_ACTCMPBD_ZEROPWM_1_GENA_ACTCMPBD_INVPWM_1_GENA_ACTCMPBD_NONEPWM_1_GENA_ACTCMPBD_MPWM_1_CMPB_COMPB_SPWM_1_CMPB_COMPB_MPWM_1_CMPA_COMPA_SPWM_1_CMPA_COMPA_MPWM_1_COUNT_COUNT_SPWM_1_COUNT_COUNT_MPWM_1_LOAD_LOAD_SPWM_1_LOAD_LOAD_MPWM_1_ISC_INTCNTZEROPWM_1_ISC_INTCNTLOADPWM_1_ISC_INTCMPAUPWM_1_ISC_INTCMPADPWM_1_ISC_INTCMPBUPWM_1_ISC_INTCMPBDPWM_1_RIS_INTCNTZEROPWM_1_RIS_INTCNTLOADPWM_1_RIS_INTCMPAUPWM_1_RIS_INTCMPADPWM_1_RIS_INTCMPBUPWM_1_RIS_INTCMPBDPWM_1_INTEN_INTCNTZEROPWM_1_INTEN_INTCNTLOADPWM_1_INTEN_INTCMPAUPWM_1_INTEN_INTCMPADPWM_1_INTEN_INTCMPBUPWM_1_INTEN_INTCMPBDPWM_1_INTEN_TRCNTZEROPWM_1_INTEN_TRCNTLOADPWM_1_INTEN_TRCMPAUPWM_1_INTEN_TRCMPADPWM_1_INTEN_TRCMPBUPWM_1_INTEN_TRCMPBDPWM_1_CTL_ENABLEPWM_1_CTL_MODEPWM_1_CTL_DEBUGPWM_1_CTL_LOADUPDPWM_1_CTL_CMPAUPDPWM_1_CTL_CMPBUPDPWM_1_CTL_GENAUPD_GSPWM_1_CTL_GENAUPD_LSPWM_1_CTL_GENAUPD_IPWM_1_CTL_GENAUPD_MPWM_1_CTL_GENBUPD_GSPWM_1_CTL_GENBUPD_LSPWM_1_CTL_GENBUPD_IPWM_1_CTL_GENBUPD_MPWM_1_CTL_DBCTLUPD_GSPWM_1_CTL_DBCTLUPD_LSPWM_1_CTL_DBCTLUPD_IPWM_1_CTL_DBCTLUPD_MPWM_1_CTL_DBRISEUPD_GSPWM_1_CTL_DBRISEUPD_LSPWM_1_CTL_DBRISEUPD_IPWM_1_CTL_DBRISEUPD_MPWM_1_CTL_DBFALLUPD_GSPWM_1_CTL_DBFALLUPD_LSPWM_1_CTL_DBFALLUPD_IPWM_1_CTL_DBFALLUPD_MPWM_1_CTL_FLTSRCPWM_1_CTL_MINFLTPERPWM_1_CTL_LATCHPWM_0_MINFLTPER_SPWM_0_MINFLTPER_MPWM_0_FLTSRC1_DCMP0PWM_0_FLTSRC1_DCMP1PWM_0_FLTSRC1_DCMP2PWM_0_FLTSRC1_DCMP3PWM_0_FLTSRC1_DCMP4PWM_0_FLTSRC1_DCMP5PWM_0_FLTSRC1_DCMP6PWM_0_FLTSRC1_DCMP7PWM_0_FLTSRC0_FAULT0PWM_0_FLTSRC0_FAULT1PWM_0_FLTSRC0_FAULT2PWM_0_FLTSRC0_FAULT3PWM_0_DBFALL_DELAY_SPWM_0_DBFALL_DELAY_MPWM_0_DBRISE_DELAY_SPWM_0_DBRISE_DELAY_MPWM_0_DBCTL_ENABLEPWM_0_GENB_ACTZERO_ONEPWM_0_GENB_ACTZERO_ZEROPWM_0_GENB_ACTZERO_INVPWM_0_GENB_ACTZERO_NONEPWM_0_GENB_ACTZERO_MPWM_0_GENB_ACTLOAD_ONEPWM_0_GENB_ACTLOAD_ZEROPWM_0_GENB_ACTLOAD_INVPWM_0_GENB_ACTLOAD_NONEPWM_0_GENB_ACTLOAD_MPWM_0_GENB_ACTCMPAU_ONEPWM_0_GENB_ACTCMPAU_ZEROPWM_0_GENB_ACTCMPAU_INVPWM_0_GENB_ACTCMPAU_NONEPWM_0_GENB_ACTCMPAU_MPWM_0_GENB_ACTCMPAD_ONEPWM_0_GENB_ACTCMPAD_ZEROPWM_0_GENB_ACTCMPAD_INVPWM_0_GENB_ACTCMPAD_NONEPWM_0_GENB_ACTCMPAD_MPWM_0_GENB_ACTCMPBU_ONEPWM_0_GENB_ACTCMPBU_ZEROPWM_0_GENB_ACTCMPBU_INVPWM_0_GENB_ACTCMPBU_NONEPWM_0_GENB_ACTCMPBU_MPWM_0_GENB_ACTCMPBD_ONEPWM_0_GENB_ACTCMPBD_ZEROPWM_0_GENB_ACTCMPBD_INVPWM_0_GENB_ACTCMPBD_NONEPWM_0_GENB_ACTCMPBD_MPWM_0_GENA_ACTZERO_ONEPWM_0_GENA_ACTZERO_ZEROPWM_0_GENA_ACTZERO_INVPWM_0_GENA_ACTZERO_NONEPWM_0_GENA_ACTZERO_MPWM_0_GENA_ACTLOAD_ONEPWM_0_GENA_ACTLOAD_ZEROPWM_0_GENA_ACTLOAD_INVPWM_0_GENA_ACTLOAD_NONEPWM_0_GENA_ACTLOAD_MPWM_0_GENA_ACTCMPAU_ONEPWM_0_GENA_ACTCMPAU_ZEROPWM_0_GENA_ACTCMPAU_INVPWM_0_GENA_ACTCMPAU_NONEPWM_0_GENA_ACTCMPAU_MPWM_0_GENA_ACTCMPAD_ONEPWM_0_GENA_ACTCMPAD_ZEROPWM_0_GENA_ACTCMPAD_INVPWM_0_GENA_ACTCMPAD_NONEPWM_0_GENA_ACTCMPAD_MPWM_0_GENA_ACTCMPBU_ONEPWM_0_GENA_ACTCMPBU_ZEROPWM_0_GENA_ACTCMPBU_INVPWM_0_GENA_ACTCMPBU_NONEPWM_0_GENA_ACTCMPBU_MPWM_0_GENA_ACTCMPBD_ONEPWM_0_GENA_ACTCMPBD_ZEROPWM_0_GENA_ACTCMPBD_INVPWM_0_GENA_ACTCMPBD_NONEPWM_0_GENA_ACTCMPBD_MPWM_0_CMPB_SPWM_0_CMPB_MPWM_0_CMPA_SPWM_0_CMPA_MPWM_0_COUNT_SPWM_0_COUNT_MPWM_0_LOAD_SPWM_0_LOAD_MPWM_0_ISC_INTCNTZEROPWM_0_ISC_INTCNTLOADPWM_0_ISC_INTCMPAUPWM_0_ISC_INTCMPADPWM_0_ISC_INTCMPBUPWM_0_ISC_INTCMPBDPWM_0_RIS_INTCNTZEROPWM_0_RIS_INTCNTLOADPWM_0_RIS_INTCMPAUPWM_0_RIS_INTCMPADPWM_0_RIS_INTCMPBUPWM_0_RIS_INTCMPBDPWM_0_INTEN_INTCNTZEROPWM_0_INTEN_INTCNTLOADPWM_0_INTEN_INTCMPAUPWM_0_INTEN_INTCMPADPWM_0_INTEN_INTCMPBUPWM_0_INTEN_INTCMPBDPWM_0_INTEN_TRCNTZEROPWM_0_INTEN_TRCNTLOADPWM_0_INTEN_TRCMPAUPWM_0_INTEN_TRCMPADPWM_0_INTEN_TRCMPBUPWM_0_INTEN_TRCMPBDPWM_0_CTL_ENABLEPWM_0_CTL_MODEPWM_0_CTL_DEBUGPWM_0_CTL_LOADUPDPWM_0_CTL_CMPAUPDPWM_0_CTL_CMPBUPDPWM_0_CTL_GENAUPD_GSPWM_0_CTL_GENAUPD_LSPWM_0_CTL_GENAUPD_IPWM_0_CTL_GENAUPD_MPWM_0_CTL_GENBUPD_GSPWM_0_CTL_GENBUPD_LSPWM_0_CTL_GENBUPD_IPWM_0_CTL_GENBUPD_MPWM_0_CTL_DBCTLUPD_GSPWM_0_CTL_DBCTLUPD_LSPWM_0_CTL_DBCTLUPD_IPWM_0_CTL_DBCTLUPD_MPWM_0_CTL_DBRISEUPD_GSPWM_0_CTL_DBRISEUPD_LSPWM_0_CTL_DBRISEUPD_IPWM_0_CTL_DBRISEUPD_MPWM_0_CTL_DBFALLUPD_GSPWM_0_CTL_DBFALLUPD_LSPWM_0_CTL_DBFALLUPD_IPWM_0_CTL_DBFALLUPD_MPWM_0_CTL_FLTSRCPWM_0_CTL_MINFLTPERPWM_0_CTL_LATCHPWM_ENUPD_ENUPD0_GSYNCPWM_ENUPD_ENUPD0_LSYNCPWM_ENUPD_ENUPD0_IMMPWM_ENUPD_ENUPD0_MPWM_ENUPD_ENUPD1_GSYNCPWM_ENUPD_ENUPD1_LSYNCPWM_ENUPD_ENUPD1_IMMPWM_ENUPD_ENUPD1_MPWM_ENUPD_ENUPD2_GSYNCPWM_ENUPD_ENUPD2_LSYNCPWM_ENUPD_ENUPD2_IMMPWM_ENUPD_ENUPD2_MPWM_ENUPD_ENUPD3_GSYNCPWM_ENUPD_ENUPD3_LSYNCPWM_ENUPD_ENUPD3_IMMPWM_ENUPD_ENUPD3_MPWM_ENUPD_ENUPD4_GSYNCPWM_ENUPD_ENUPD4_LSYNCPWM_ENUPD_ENUPD4_IMMPWM_ENUPD_ENUPD4_MPWM_ENUPD_ENUPD5_GSYNCPWM_ENUPD_ENUPD5_LSYNCPWM_ENUPD_ENUPD5_IMMPWM_ENUPD_ENUPD5_MPWM_ENUPD_ENUPD6_GSYNCPWM_ENUPD_ENUPD6_LSYNCPWM_ENUPD_ENUPD6_IMMPWM_ENUPD_ENUPD6_MPWM_ENUPD_ENUPD7_GSYNCPWM_ENUPD_ENUPD7_LSYNCPWM_ENUPD_ENUPD7_IMMPWM_ENUPD_ENUPD7_MPWM_FAULTVAL_PWM0PWM_FAULTVAL_PWM1PWM_FAULTVAL_PWM2PWM_FAULTVAL_PWM3PWM_FAULTVAL_PWM4PWM_FAULTVAL_PWM5PWM_FAULTVAL_PWM6PWM_FAULTVAL_PWM7PWM_STATUS_FAULT0PWM_STATUS_FAULT1PWM_STATUS_FAULT2PWM_STATUS_FAULT3PWM_ISC_INTPWM0PWM_ISC_INTPWM1PWM_ISC_INTPWM2PWM_ISC_INTPWM3PWM_ISC_INTFAULT0PWM_ISC_INTFAULT1PWM_ISC_INTFAULT2PWM_ISC_INTFAULT3PWM_RIS_INTPWM0PWM_RIS_INTPWM1PWM_RIS_INTPWM2PWM_RIS_INTPWM3PWM_RIS_INTFAULT0PWM_RIS_INTFAULT1PWM_RIS_INTFAULT2PWM_RIS_INTFAULT3PWM_INTEN_INTPWM0PWM_INTEN_INTPWM1PWM_INTEN_INTPWM2PWM_INTEN_INTPWM3PWM_INTEN_INTFAULT0PWM_INTEN_INTFAULT1PWM_INTEN_INTFAULT2PWM_INTEN_INTFAULT3PWM_FAULT_FAULT0PWM_FAULT_FAULT1PWM_FAULT_FAULT2PWM_FAULT_FAULT3PWM_FAULT_FAULT4PWM_FAULT_FAULT5PWM_FAULT_FAULT6PWM_FAULT_FAULT7PWM_INVERT_PWM0INVPWM_INVERT_PWM1INVPWM_INVERT_PWM2INVPWM_INVERT_PWM3INVPWM_INVERT_PWM4INVPWM_INVERT_PWM5INVPWM_INVERT_PWM6INVPWM_INVERT_PWM7INVPWM_ENABLE_PWM0ENPWM_ENABLE_PWM1ENPWM_ENABLE_PWM2ENPWM_ENABLE_PWM3ENPWM_ENABLE_PWM4ENPWM_ENABLE_PWM5ENPWM_ENABLE_PWM6ENPWM_ENABLE_PWM7ENPWM_SYNC_SYNC0PWM_SYNC_SYNC1PWM_SYNC_SYNC2PWM_SYNC_SYNC3PWM_CTL_GLOBALSYNC0PWM_CTL_GLOBALSYNC1PWM_CTL_GLOBALSYNC2PWM_CTL_GLOBALSYNC3PWM_O_CCPWM_O_PPPWM_O_3_FLTSTAT10x00000988PWM_O_3_FLTSTAT00x00000984PWM_O_3_FLTSENPWM_O_2_FLTSTAT10x00000908PWM_O_2_FLTSTAT00x00000904PWM_O_2_FLTSENPWM_O_1_FLTSTAT10x00000888PWM_O_1_FLTSTAT00x00000884PWM_O_1_FLTSENPWM_O_0_FLTSTAT1PWM_O_0_FLTSTAT0PWM_O_0_FLTSENPWM_O_3_MINFLTPER0x0000013CPWM_O_3_FLTSRC10x00000138PWM_O_3_FLTSRC00x00000134PWM_O_3_DBFALL0x00000130PWM_O_3_DBRISE0x0000012CPWM_O_3_DBCTL0x00000128PWM_O_3_GENBPWM_O_3_GENAPWM_O_3_CMPB0x0000011CPWM_O_3_CMPAPWM_O_3_COUNT0x00000114PWM_O_3_LOADPWM_O_3_ISCPWM_O_3_RISPWM_O_3_INTENPWM_O_3_CTLPWM_O_2_MINFLTPER0x000000FCPWM_O_2_FLTSRC10x000000F8PWM_O_2_FLTSRC00x000000F4PWM_O_2_DBFALLPWM_O_2_DBRISE0x000000ECPWM_O_2_DBCTL0x000000E8PWM_O_2_GENB0x000000E4PWM_O_2_GENAPWM_O_2_CMPBPWM_O_2_CMPA0x000000D8PWM_O_2_COUNT0x000000D4PWM_O_2_LOAD0x000000D0PWM_O_2_ISC0x000000CCPWM_O_2_RIS0x000000C8PWM_O_2_INTEN0x000000C4PWM_O_2_CTLPWM_O_1_MINFLTPERPWM_O_1_FLTSRC1PWM_O_1_FLTSRC0PWM_O_1_DBFALLPWM_O_1_DBRISEPWM_O_1_DBCTLPWM_O_1_GENBPWM_O_1_GENAPWM_O_1_CMPBPWM_O_1_CMPAPWM_O_1_COUNTPWM_O_1_LOADPWM_O_1_ISCPWM_O_1_RISPWM_O_1_INTENPWM_O_1_CTLPWM_O_0_MINFLTPERPWM_O_0_FLTSRC1PWM_O_0_FLTSRC0PWM_O_0_DBFALLPWM_O_0_DBRISEPWM_O_0_DBCTLPWM_O_0_GENBPWM_O_0_GENAPWM_O_0_CMPBPWM_O_0_CMPAPWM_O_0_COUNTPWM_O_0_LOADPWM_O_0_ISCPWM_O_0_RISPWM_O_0_INTENPWM_O_0_CTLPWM_O_ENUPDPWM_O_FAULTVALPWM_O_STATUSPWM_O_ISCPWM_O_RISPWM_O_INTENPWM_O_FAULTPWM_O_INVERTPWM_O_ENABLEPWM_O_SYNCPWM_O_CTL__HW_PWM_H__// __HW_PWM_H__// Digital Comparator 0 Trigger// Digital Comparator 1 Trigger// Digital Comparator 2 Trigger// Digital Comparator 3 Trigger// Digital Comparator 4 Trigger// Digital Comparator 5 Trigger// Digital Comparator 6 Trigger// Digital Comparator 7 Trigger// The following are defines for the bit fields in the PWM_O_X_FLTSTAT1// Fault Input 0// Fault Input 1// Fault Input 2// Fault Input 3// The following are defines for the bit fields in the PWM_O_X_FLTSTAT0// Fault0 Sense// Fault1 Sense// Fault2 Sense// Fault3 Sense// The following are defines for the bit fields in the PWM_O_X_FLTSEN register.// PWM3 extended base// PWM2 extended base// PWM1 extended base// PWM0 extended base// Digital comparator status// Pin and comparator status// Fault logic sense// The following are defines for the PWM Generator extended offsets.// Minimum Fault Period// The following are defines for the bit fields in the PWM_O_X_MINFLTPER// Digital Comparator 0// Digital Comparator 1// Digital Comparator 2// Digital Comparator 3// Digital Comparator 4// Digital Comparator 5// Digital Comparator 6// Digital Comparator 7// The following are defines for the bit fields in the PWM_O_X_FLTSRC1// Fault0 Input// Fault1 Input// Fault2 Input// Fault3 Input// The following are defines for the bit fields in the PWM_O_X_FLTSRC0// Dead-Band Fall Delay// The following are defines for the bit fields in the PWM_O_X_DBFALL register.// Dead-Band Rise Delay// The following are defines for the bit fields in the PWM_O_X_DBRISE register.// Dead-Band Generator Enable// The following are defines for the bit fields in the PWM_O_X_DBCTL register.// Drive pwmB High// Drive pwmB Low// Invert pwmB// Do nothing// Action for Counter=0// Action for Counter=LOAD// Action for Comparator A Up// Action for Comparator A Down// Action for Comparator B Up// Action for Comparator B Down// The following are defines for the bit fields in the PWM_O_X_GENB register.// Drive pwmA High// Drive pwmA Low// Invert pwmA// The following are defines for the bit fields in the PWM_O_X_GENA register.// Comparator B Value// The following are defines for the bit fields in the PWM_O_X_CMPB register.// Comparator A Value// The following are defines for the bit fields in the PWM_O_X_CMPA register.// Counter Value// The following are defines for the bit fields in the PWM_O_X_COUNT register.// Counter Load Value// The following are defines for the bit fields in the PWM_O_X_LOAD register.// Counter=0 Interrupt// Counter=Load Interrupt// Comparator A Up Interrupt// Comparator A Down Interrupt// Comparator B Up Interrupt// Comparator B Down Interrupt// The following are defines for the bit fields in the PWM_O_X_ISC register.// Counter=0 Interrupt Status// Counter=Load Interrupt Status// Comparator A Up Interrupt Status// Comparator B Up Interrupt Status// The following are defines for the bit fields in the PWM_O_X_RIS register.// Interrupt for Counter=0// Interrupt for Counter=PWMnLOAD// Up// Interrupt for Counter=PWMnCMPA// Down// Interrupt for Counter=PWMnCMPB// Trigger for Counter=0// Trigger for Counter=PWMnLOAD// Trigger for Counter=PWMnCMPA Up// Trigger for Counter=PWMnCMPA// Trigger for Counter=PWMnCMPB Up// Trigger for Counter=PWMnCMPB// The following are defines for the bit fields in the PWM_O_X_INTEN register.// PWM Block Enable// Debug Mode// Load Register Update Mode// Comparator A Update Mode// Comparator B Update Mode// Globally Synchronized// Locally Synchronized// Immediate// PWMnGENA Update Mode// PWMnGENB Update Mode// PWMnDBCTL Update Mode// PWMnDBRISE Update Mode// PWMnDBFALL Update Mode// Fault Condition Source// Latch Fault Input// The following are defines for the bit fields in the PWM_O_X_CTL register.// PWM3 base// PWM2 base// PWM1 base// PWM0 base// Fault minimum period extension// Digital comparator condition// Fault pin, comparator condition// Gen DB Falling Edge Delay Reg// Gen DB Rising Edge Delay Reg// Gen Dead Band Ctrl Reg// Gen Generator B Ctrl Reg// Gen Generator A Ctrl Reg// Gen Compare B Reg// Gen Compare A Reg// Gen Counter Reg// Gen Load Reg// Gen Int Status Reg// Gen Raw Int Status Reg// Gen Int/Trig Enable Reg// Gen Control Reg// The following are defines for the PWM Generator standard offsets.// /64// /32// /16// /8// /4// /2// PWM Clock Divider// Use PWM Clock Divisor// The following are defines for the bit fields in the PWM_O_CC register.// One-Shot Mode// Extended Fault// Extended Synchronization// Fault Inputs (per PWM unit)// Generators// The following are defines for the bit fields in the PWM_O_PP register.// The following are defines for the bit fields in the PWM_O_3_FLTSTAT1// The following are defines for the bit fields in the PWM_O_3_FLTSTAT0// The following are defines for the bit fields in the PWM_O_3_FLTSEN register.// The following are defines for the bit fields in the PWM_O_2_FLTSTAT1// The following are defines for the bit fields in the PWM_O_2_FLTSTAT0// The following are defines for the bit fields in the PWM_O_2_FLTSEN register.// The following are defines for the bit fields in the PWM_O_1_FLTSTAT1// The following are defines for the bit fields in the PWM_O_1_FLTSTAT0// The following are defines for the bit fields in the PWM_O_1_FLTSEN register.// The following are defines for the bit fields in the PWM_O_0_FLTSTAT1// The following are defines for the bit fields in the PWM_O_0_FLTSTAT0// The following are defines for the bit fields in the PWM_O_0_FLTSEN register.// The following are defines for the bit fields in the PWM_O_3_MINFLTPER// The following are defines for the bit fields in the PWM_O_3_FLTSRC1// The following are defines for the bit fields in the PWM_O_3_FLTSRC0// The following are defines for the bit fields in the PWM_O_3_DBFALL register.// The following are defines for the bit fields in the PWM_O_3_DBRISE register.// The following are defines for the bit fields in the PWM_O_3_DBCTL register.// The following are defines for the bit fields in the PWM_O_3_GENB register.// The following are defines for the bit fields in the PWM_O_3_GENA register.// The following are defines for the bit fields in the PWM_O_3_CMPB register.// The following are defines for the bit fields in the PWM_O_3_CMPA register.// The following are defines for the bit fields in the PWM_O_3_COUNT register.// The following are defines for the bit fields in the PWM_O_3_LOAD register.// The following are defines for the bit fields in the PWM_O_3_ISC register.// The following are defines for the bit fields in the PWM_O_3_RIS register.// The following are defines for the bit fields in the PWM_O_3_INTEN register.// The following are defines for the bit fields in the PWM_O_3_CTL register.// The following are defines for the bit fields in the PWM_O_2_MINFLTPER// The following are defines for the bit fields in the PWM_O_2_FLTSRC1// The following are defines for the bit fields in the PWM_O_2_FLTSRC0// The following are defines for the bit fields in the PWM_O_2_DBFALL register.// The following are defines for the bit fields in the PWM_O_2_DBRISE register.// The following are defines for the bit fields in the PWM_O_2_DBCTL register.// The following are defines for the bit fields in the PWM_O_2_GENB register.// The following are defines for the bit fields in the PWM_O_2_GENA register.// The following are defines for the bit fields in the PWM_O_2_CMPB register.// The following are defines for the bit fields in the PWM_O_2_CMPA register.// The following are defines for the bit fields in the PWM_O_2_COUNT register.// The following are defines for the bit fields in the PWM_O_2_LOAD register.// The following are defines for the bit fields in the PWM_O_2_ISC register.// The following are defines for the bit fields in the PWM_O_2_RIS register.// The following are defines for the bit fields in the PWM_O_2_INTEN register.// The following are defines for the bit fields in the PWM_O_2_CTL register.// The following are defines for the bit fields in the PWM_O_1_MINFLTPER// The following are defines for the bit fields in the PWM_O_1_FLTSRC1// The following are defines for the bit fields in the PWM_O_1_FLTSRC0// The following are defines for the bit fields in the PWM_O_1_DBFALL register.// The following are defines for the bit fields in the PWM_O_1_DBRISE register.// The following are defines for the bit fields in the PWM_O_1_DBCTL register.// The following are defines for the bit fields in the PWM_O_1_GENB register.// The following are defines for the bit fields in the PWM_O_1_GENA register.// The following are defines for the bit fields in the PWM_O_1_CMPB register.// The following are defines for the bit fields in the PWM_O_1_CMPA register.// The following are defines for the bit fields in the PWM_O_1_COUNT register.// The following are defines for the bit fields in the PWM_O_1_LOAD register.// The following are defines for the bit fields in the PWM_O_1_ISC register.// The following are defines for the bit fields in the PWM_O_1_RIS register.// The following are defines for the bit fields in the PWM_O_1_INTEN register.// The following are defines for the bit fields in the PWM_O_1_CTL register.// The following are defines for the bit fields in the PWM_O_0_MINFLTPER// The following are defines for the bit fields in the PWM_O_0_FLTSRC1// The following are defines for the bit fields in the PWM_O_0_FLTSRC0// The following are defines for the bit fields in the PWM_O_0_DBFALL register.// The following are defines for the bit fields in the PWM_O_0_DBRISE register.// The following are defines for the bit fields in the PWM_O_0_DBCTL register.// The following are defines for the bit fields in the PWM_O_0_GENB register.// The following are defines for the bit fields in the PWM_O_0_GENA register.// The following are defines for the bit fields in the PWM_O_0_CMPB register.// The following are defines for the bit fields in the PWM_O_0_CMPA register.// The following are defines for the bit fields in the PWM_O_0_COUNT register.// The following are defines for the bit fields in the PWM_O_0_LOAD register.// The following are defines for the bit fields in the PWM_O_0_ISC register.// The following are defines for the bit fields in the PWM_O_0_RIS register.// The following are defines for the bit fields in the PWM_O_0_INTEN register.// The following are defines for the bit fields in the PWM_O_0_CTL register.// MnPWM0 Enable Update Mode// MnPWM1 Enable Update Mode// MnPWM2 Enable Update Mode// MnPWM3 Enable Update Mode// MnPWM4 Enable Update Mode// MnPWM5 Enable Update Mode// MnPWM6 Enable Update Mode// MnPWM7 Enable Update Mode// The following are defines for the bit fields in the PWM_O_ENUPD register.// MnPWM0 Fault Value// MnPWM1 Fault Value// MnPWM2 Fault Value// MnPWM3 Fault Value// MnPWM4 Fault Value// MnPWM5 Fault Value// MnPWM6 Fault Value// MnPWM7 Fault Value// The following are defines for the bit fields in the PWM_O_FAULTVAL register.// Generator 0 Fault Status// Generator 1 Fault Status// Generator 2 Fault Status// Generator 3 Fault Status// The following are defines for the bit fields in the PWM_O_STATUS register.// PWM0 Interrupt Status// PWM1 Interrupt Status// PWM2 Interrupt Status// PWM3 Interrupt Status// FAULT0 Interrupt Asserted// FAULT1 Interrupt Asserted// FAULT2 Interrupt Asserted// FAULT3 Interrupt Asserted// The following are defines for the bit fields in the PWM_O_ISC register.// PWM0 Interrupt Asserted// PWM1 Interrupt Asserted// PWM2 Interrupt Asserted// PWM3 Interrupt Asserted// Interrupt Fault PWM 0// Interrupt Fault PWM 1// Interrupt Fault PWM 2// Interrupt Fault PWM 3// The following are defines for the bit fields in the PWM_O_RIS register.// PWM0 Interrupt Enable// PWM1 Interrupt Enable// PWM2 Interrupt Enable// PWM3 Interrupt Enable// Interrupt Fault 0// Interrupt Fault 1// Interrupt Fault 2// Interrupt Fault 3// The following are defines for the bit fields in the PWM_O_INTEN register.// MnPWM0 Fault// MnPWM1 Fault// MnPWM2 Fault// MnPWM3 Fault// MnPWM4 Fault// MnPWM5 Fault// MnPWM6 Fault// MnPWM7 Fault// The following are defines for the bit fields in the PWM_O_FAULT register.// Invert MnPWM0 Signal// Invert MnPWM1 Signal// Invert MnPWM2 Signal// Invert MnPWM3 Signal// Invert MnPWM4 Signal// Invert MnPWM5 Signal// Invert MnPWM6 Signal// Invert MnPWM7 Signal// The following are defines for the bit fields in the PWM_O_INVERT register.// MnPWM0 Output Enable// MnPWM1 Output Enable// MnPWM2 Output Enable// MnPWM3 Output Enable// MnPWM4 Output Enable// MnPWM5 Output Enable// MnPWM6 Output Enable// MnPWM7 Output Enable// The following are defines for the bit fields in the PWM_O_ENABLE register.// Reset Generator 0 Counter// Reset Generator 1 Counter// Reset Generator 2 Counter// Reset Generator 3 Counter// The following are defines for the bit fields in the PWM_O_SYNC register.// Update PWM Generator 0// Update PWM Generator 1// Update PWM Generator 2// Update PWM Generator 3// The following are defines for the bit fields in the PWM_O_CTL register.// PWM Clock Configuration// PWM Peripheral Properties// PWM3 Fault Status 1// PWM3 Fault Status 0// PWM3 Fault Pin Logic Sense// PWM2 Fault Status 1// PWM2 Fault Status 0// PWM2 Fault Pin Logic Sense// PWM1 Fault Status 1// PWM1 Fault Status 0// PWM1 Fault Pin Logic Sense// PWM0 Fault Status 1// PWM0 Fault Status 0// PWM0 Fault Pin Logic Sense// PWM3 Minimum Fault Period// PWM3 Fault Source 1// PWM3 Fault Source 0// Falling-Edge-Delay// PWM3 Dead-Band// PWM3 Dead-Band Rising-Edge Delay// PWM3 Dead-Band Control// PWM3 Generator B Control// PWM3 Generator A Control// PWM3 Compare B// PWM3 Compare A// PWM3 Counter// PWM3 Load// PWM3 Interrupt Status and Clear// PWM3 Raw Interrupt Status// PWM3 Interrupt and Trigger// PWM3 Control// PWM2 Minimum Fault Period// PWM2 Fault Source 1// PWM2 Fault Source 0// PWM2 Dead-Band// PWM2 Dead-Band Rising-Edge Delay// PWM2 Dead-Band Control// PWM2 Generator B Control// PWM2 Generator A Control// PWM2 Compare B// PWM2 Compare A// PWM2 Counter// PWM2 Load// PWM2 Interrupt Status and Clear// PWM2 Raw Interrupt Status// PWM2 Interrupt and Trigger// PWM2 Control// PWM1 Minimum Fault Period// PWM1 Fault Source 1// PWM1 Fault Source 0// PWM1 Dead-Band// PWM1 Dead-Band Rising-Edge Delay// PWM1 Dead-Band Control// PWM1 Generator B Control// PWM1 Generator A Control// PWM1 Compare B// PWM1 Compare A// PWM1 Counter// PWM1 Load// PWM1 Interrupt Status and Clear// PWM1 Raw Interrupt Status// PWM1 Interrupt and Trigger// PWM1 Control// PWM0 Minimum Fault Period// PWM0 Fault Source 1// PWM0 Fault Source 0// PWM0 Dead-Band// PWM0 Dead-Band Rising-Edge Delay// PWM0 Dead-Band Control// PWM0 Generator B Control// PWM0 Generator A Control// PWM0 Compare B// PWM0 Compare A// PWM0 Counter// PWM0 Load// PWM0 Interrupt Status and Clear// PWM0 Raw Interrupt Status// PWM0 Interrupt and Trigger// PWM0 Control// PWM Enable Update// PWM Fault Condition Value// PWM Status// PWM Interrupt Status and Clear// PWM Raw Interrupt Status// PWM Interrupt Enable// PWM Output Fault// PWM Output Inversion// PWM Output Enable// PWM Time Base Sync// PWM Master Control// The following are defines for the PWM register offsets.// hw_pwm.h - Defines and Macros for Pulse Width Modulation (PWM) ports./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/pwm.hPWM_OUTPUT_MODE_SYNC_GLOBALPWM_OUTPUT_MODE_SYNC_LOCALPWM_OUTPUT_MODE_NO_SYNCPWM_SYSCLK_DIV_64PWM_SYSCLK_DIV_32PWM_SYSCLK_DIV_16PWM_SYSCLK_DIV_8PWM_SYSCLK_DIV_4PWM_SYSCLK_DIV_2PWM_SYSCLK_DIV_1PWM_FAULT3_SENSE_LOWPWM_FAULT3_SENSE_HIGHPWM_FAULT2_SENSE_LOWPWM_FAULT2_SENSE_HIGHPWM_FAULT1_SENSE_LOWPWM_FAULT1_SENSE_HIGHPWM_FAULT0_SENSE_LOWPWM_FAULT0_SENSE_HIGHPWM_FAULT_DCMP7PWM_FAULT_DCMP6PWM_FAULT_DCMP5PWM_FAULT_DCMP4PWM_FAULT_DCMP3PWM_FAULT_DCMP2PWM_FAULT_DCMP1PWM_FAULT_DCMP0PWM_FAULT_GROUP_1PWM_FAULT_ACMP2PWM_FAULT_ACMP1PWM_FAULT_ACMP0PWM_FAULT_GROUP_0PWM_OUT_7_BITPWM_OUT_6_BITPWM_OUT_5_BITPWM_OUT_4_BITPWM_OUT_3_BITPWM_OUT_2_BITPWM_OUT_1_BITPWM_OUT_0_BITPWM_OUT_7PWM_OUT_6PWM_OUT_50x000000C5PWM_OUT_4PWM_OUT_30x00000083PWM_OUT_20x00000082PWM_OUT_10x00000041PWM_OUT_0PWM_GEN_EXT_3PWM_GEN_EXT_2PWM_GEN_EXT_1PWM_GEN_EXT_0PWM_GEN_3_BITPWM_GEN_2_BITPWM_GEN_1_BITPWM_GEN_0_BITPWM_GEN_3PWM_GEN_2PWM_GEN_1PWM_GEN_0PWM_INT_FAULT_MPWM_INT_FAULT3PWM_INT_FAULT2PWM_INT_FAULT1PWM_INT_FAULT0PWM_INT_GEN_3PWM_INT_GEN_2PWM_INT_GEN_1PWM_INT_GEN_0PWM_TR_CNT_BDPWM_TR_CNT_BUPWM_TR_CNT_ADPWM_TR_CNT_AUPWM_TR_CNT_LOADPWM_TR_CNT_ZEROPWM_INT_CNT_BDPWM_INT_CNT_BUPWM_INT_CNT_ADPWM_INT_CNT_AUPWM_INT_CNT_LOADPWM_INT_CNT_ZEROPWM_GEN_MODE_GEN_SYNC_GLOBALPWM_GEN_MODE_GEN_SYNC_LOCALPWM_GEN_MODE_GEN_NO_SYNCPWM_GEN_MODE_DB_SYNC_GLOBALPWM_GEN_MODE_DB_SYNC_LOCAL0x0000A800PWM_GEN_MODE_DB_NO_SYNCPWM_GEN_MODE_FAULT_LEGACYPWM_GEN_MODE_FAULT_EXTPWM_GEN_MODE_FAULT_NO_MINPERPWM_GEN_MODE_FAULT_MINPERPWM_GEN_MODE_FAULT_UNLATCHEDPWM_GEN_MODE_FAULT_LATCHEDPWM_GEN_MODE_DBG_STOPPWM_GEN_MODE_DBG_RUNPWM_GEN_MODE_NO_SYNCPWM_GEN_MODE_SYNCPWM_GEN_MODE_UP_DOWNPWM_GEN_MODE_DOWN__DRIVERLIB_PWM_H__PWMOutputUpdateModePWMClockGetPWMClockSetPWMGenFaultClearPWMGenFaultStatusPWMGenFaultTriggerGetPWMGenFaultTriggerSetPWMGenFaultConfigurePWMFaultIntClearExtPWMIntStatusPWMFaultIntClearPWMIntDisablePWMIntEnablePWMGenIntClearPWMGenIntStatusPWMGenIntTrigDisablePWMGenIntTrigEnablePWMFaultIntUnregisterPWMFaultIntRegisterPWMGenIntUnregisterPWMGenIntRegisterPWMOutputFaultPWMOutputFaultLevelPWMOutputInvertPWMOutputStatePWMSyncTimeBasePWMSyncUpdatePWMDeadBandDisablePWMDeadBandEnablePWMPulseWidthGetPWMPulseWidthSetPWMGenDisablePWMGenEnablePWMGenPeriodGetPWMGenPeriodSetPWMGenConfigure// __DRIVERLIB_PWM_H__// Updates are globally synchronized// Updates are locally synchronized// Updates to occur immediately// to use when enabling or disabling outputs using PWMOutputState().// Defines passed to PWMOutputUpdateMode() to identify the synchronization mode// PWM clock is system clock /64// PWM clock is system clock /32// PWM clock is system clock /16// PWM clock is system clock /8// PWM clock is system clock /4// PWM clock is system clock /2// PWM clock is system clock// parameter, and can be returned by the PWMClockGet() API.// Defines that can be passed to the PWMClockSet() API as the ui32Config// Defines to identify the sense of each of the external FAULTn signals// PWM_FAULT_GROUP_1.// Defines to identify each of the possible fault trigger conditions in// PWM_FAULT_GROUP_0.// Bit-wise ID for PWM7// Bit-wise ID for PWM6// Bit-wise ID for PWM5// Bit-wise ID for PWM4// Bit-wise ID for PWM3// Bit-wise ID for PWM2// Bit-wise ID for PWM1// Bit-wise ID for PWM0// Encoded offset address of PWM7// Encoded offset address of PWM6// Encoded offset address of PWM5// Encoded offset address of PWM4// Encoded offset address of PWM3// Encoded offset address of PWM2// Encoded offset address of PWM1// Encoded offset address of PWM0// Defines to identify the outputs within a module.// Offset of Gen3 ext address range// Offset of Gen2 ext address range// Offset of Gen1 ext address range// Offset of Gen0 ext address range// Bit-wise ID for Gen3// Bit-wise ID for Gen2// Bit-wise ID for Gen1// Bit-wise ID for Gen0// Offset address of Gen3// Offset address of Gen2// Offset address of Gen1// Offset address of Gen0// Defines to identify the generators within a module.// Fault interrupt source mask// Fault3 interrupt// Fault2 interrupt// Fault1 interrupt// Fault0 interrupt// Generator 3 interrupt// Generator 2 interrupt// Generator 1 interrupt// Generator 0 interrupt// Defines for enabling, disabling, and clearing PWM interrupts.// Trig if COUNT = CMPA D// Trig if COUNT = CMPA U// Trig if COUNT = LOAD// Trig if COUNT = 0// Int if COUNT = CMPA D// Int if COUNT = CMPA U// Int if COUNT = LOAD// Int if COUNT = 0// Defines for enabling, disabling, and clearing PWM generator interrupts and// synchronized// Generator mode updates globally// Generator mode updates locally// immediately// Generator mode updates occur// Deadband updates globally// Deadband updates locally// Deadband updates occur// Disable extended fault support// Enable extended fault support// Disable min fault period// Enable min fault period// Fault is not latched// Fault is latched// Stop running in debug mode// Continue running in debug mode// Immediate updates// Synchronous updates// Up/Down count mode// Down count mode// parameter and specify the configuration of the PWM generator.// The following defines are passed to PWMGenConfigure() as the ui32Config// pwm.h - API function protoypes for Pulse Width Modulation (PWM) portsui32PWMOutBitsui32Groupui32FaultTriggersui32MinFaultPeriodui32FaultSensesui32FaultIntsui32GenFaultui32Intsui32IntTrigbFaultSuppressbDriveHighbInvertui32GenBitsui16Riseui16Fallui32PWMOut/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/pwm.c"driverlib/pwm.h""inc/hw_pwm.h"ui8Indexui32PWMOutputMaskui32UpdateValueMaskui32UpdateValueui32Base + PWM_O_ENUPD(ui32Base == PWM0_BASE) || (ui32Base == PWM1_BASE)!(ui32PWMOutBits & ~(PWM_OUT_0_BIT | PWM_OUT_1_BIT | PWM_OUT_2_BIT | PWM_OUT_3_BIT | PWM_OUT_4_BIT | PWM_OUT_5_BIT | PWM_OUT_6_BIT | PWM_OUT_7_BIT))(ui32Mode == PWM_OUTPUT_MODE_NO_SYNC) || (ui32Mode == PWM_OUTPUT_MODE_SYNC_LOCAL) || (ui32Mode == PWM_OUTPUT_MODE_SYNC_GLOBAL)ui32Base + PWM_O_CC(PWM_SYSCLK_DIV_1)263(PWM_CC_USEPWM | PWM_CC_PWMDIV_M)4294967032~(PWM_CC_USEPWM | PWM_CC_PWMDIV_M)(ui32Config == PWM_SYSCLK_DIV_1) || (ui32Config == PWM_SYSCLK_DIV_2) || (ui32Config == PWM_SYSCLK_DIV_4) || (ui32Config == PWM_SYSCLK_DIV_8) || (ui32Config == PWM_SYSCLK_DIV_16) || (ui32Config == PWM_SYSCLK_DIV_32) || (ui32Config == PWM_SYSCLK_DIV_64)PWM_GEN_EXT_BADDR(ui32Base, ui32Gen) + PWM_O_X_FLTSTAT0((ui32Base) + 0x00000800 + ((ui32Gen) - 0x00000040) * 2) + 0x00000004PWM_GEN_EXT_BADDR(ui32Base, ui32Gen) + PWM_O_X_FLTSTAT1((ui32Base) + 0x00000800 + ((ui32Gen) - 0x00000040) * 2) + 0x00000008_PWMGenValid(ui32Gen)(ui32Group == PWM_FAULT_GROUP_0) || (ui32Group == PWM_FAULT_GROUP_1)(ui32Group == PWM_FAULT_GROUP_0) && ((ui32FaultTriggers & ~(PWM_FAULT_FAULT0 | PWM_FAULT_FAULT1 | PWM_FAULT_FAULT2 | PWM_FAULT_FAULT3)) == 0)(ui32Group == PWM_FAULT_GROUP_1) && ((ui32FaultTriggers & ~(PWM_FAULT_DCMP0 | PWM_FAULT_DCMP1 | PWM_FAULT_DCMP2 | PWM_FAULT_DCMP3 | PWM_FAULT_DCMP4 | PWM_FAULT_DCMP5 | PWM_FAULT_DCMP6 | PWM_FAULT_DCMP7)) == 0)PWM_GEN_BADDR(ui32Base, ui32Gen) + PWM_O_X_FLTSRC0((ui32Base) + (ui32Gen)) + 0x00000034PWM_GEN_BADDR(ui32Base, ui32Gen) + PWM_O_X_FLTSRC1((ui32Base) + (ui32Gen)) + 0x00000038PWM_GEN_BADDR(ui32Base, ui32Gen) + PWM_O_X_MINFLTPER((ui32Base) + (ui32Gen)) + 0x0000003CPWM_GEN_EXT_BADDR(ui32Base, ui32Gen) + PWM_O_X_FLTSEN((ui32Base) + 0x00000800 + ((ui32Gen) - 0x00000040) * 2) + 0x00000000ui32MinFaultPeriod < PWM_X_MINFLTPER_M(ui32FaultSenses & ~(PWM_FAULT0_SENSE_HIGH | PWM_FAULT0_SENSE_LOW | PWM_FAULT1_SENSE_HIGH | PWM_FAULT1_SENSE_LOW | PWM_FAULT2_SENSE_HIGH | PWM_FAULT2_SENSE_LOW | PWM_FAULT3_SENSE_HIGH | PWM_FAULT3_SENSE_LOW)) == 0ui32Base + PWM_O_ISC(ui32FaultInts & ~(PWM_INT_FAULT0 | PWM_INT_FAULT1 | PWM_INT_FAULT2 | PWM_INT_FAULT3)) == 0ui32Base + PWM_O_RISui32Base + PWM_O_INTEN(ui32GenFault & ~(PWM_INT_GEN_0 | PWM_INT_GEN_1 | PWM_INT_GEN_2 | PWM_INT_GEN_3 | PWM_INT_FAULT0 | PWM_INT_FAULT1 | PWM_INT_FAULT2 | PWM_INT_FAULT3)) == 0PWM_GEN_BADDR(ui32Base, ui32Gen) + PWM_O_X_ISC((ui32Base) + (ui32Gen)) + 0x0000000C(ui32Ints & ~(PWM_INT_CNT_ZERO | PWM_INT_CNT_LOAD | PWM_INT_CNT_AU | PWM_INT_CNT_AD | PWM_INT_CNT_BU | PWM_INT_CNT_BD)) == 0ui32Gen + PWM_O_X_ISCui32Gen + 0x0000000Cui32Gen + PWM_O_X_RISui32Gen + 0x00000008PWM_GEN_BADDR(ui32Base, ui32Gen) + PWM_O_X_INTEN((ui32Base) + (ui32Gen)) + 0x00000004(ui32IntTrig & ~(PWM_INT_CNT_ZERO | PWM_INT_CNT_LOAD | PWM_INT_CNT_AU | PWM_INT_CNT_AD | PWM_INT_CNT_BU | PWM_INT_CNT_BD | PWM_TR_CNT_ZERO | PWM_TR_CNT_LOAD | PWM_TR_CNT_AU | PWM_TR_CNT_AD | PWM_TR_CNT_BU | PWM_TR_CNT_BD)) == 0_PWMFaultIntNumberGet1073905664PWM0_BASE_PWMGenIntNumberGet1073905728(INT_PWM0_0_TM4C123)(INT_PWM0_0_TM4C129)1073905792(INT_PWM0_1_TM4C129)1073905856(INT_PWM0_2_TM4C129)1073905920(INT_PWM0_3_TM4C129)1073909760PWM1_BASE1073909824(INT_PWM1_0_TM4C123)1073909888(INT_PWM1_1_TM4C123)1073909952(INT_PWM1_2_TM4C123)1073910016(INT_PWM1_3_TM4C123)ui32Base + PWM_O_FAULTui32Base + PWM_O_FAULTVALui32Base + PWM_O_INVERTui32Base + PWM_O_ENABLEui32Base + PWM_O_SYNC!(ui32GenBits & ~(PWM_GEN_0_BIT | PWM_GEN_1_BIT | PWM_GEN_2_BIT | PWM_GEN_3_BIT))ui32Base + PWM_O_CTLPWM_GEN_BADDR(ui32Base, ui32Gen) + PWM_O_X_DBCTL((ui32Base) + (ui32Gen)) + 0x00000028(PWM_X_DBCTL_ENABLE)~(PWM_X_DBCTL_ENABLE)ui32Gen + PWM_O_X_DBRISEui32Gen + 0x0000002Cui32Gen + PWM_O_X_DBFALLui32Gen + 0x00000030ui32Gen + PWM_O_X_DBCTLui32Gen + 0x00000028ui16Rise < 4096ui16Fall < 4096ui32GenBaseui32Load4294967232ui32GenBase + PWM_O_X_LOADui32GenBase + 0x00000010ui32GenBase + PWM_O_X_CMPBui32GenBase + 0x0000001Cui32GenBase + PWM_O_X_CMPAui32GenBase + 0x00000018ui32GenBase + PWM_O_X_CTLui32GenBase + 0x00000000_PWMOutValid(ui32PWMOut)ui32Width < ui32RegPWM_GEN_BADDR(ui32Base, ui32Gen) + PWM_O_X_CTL((ui32Base) + (ui32Gen)) + 0x00000000(PWM_X_CTL_ENABLE)~(PWM_X_CTL_ENABLE)ui32Gen + PWM_O_X_CTLui32Gen + 0x00000000ui32Gen + PWM_O_X_LOADui32Gen + 0x00000010(ui32Period / 2) < 65536(ui32Period <= 65536) && (ui32Period != 0)262150393222458758507910520198523270524038524230524238524254524286(PWM_X_CTL_MODE | PWM_X_CTL_DEBUG |
                                       PWM_X_CTL_LATCH | PWM_X_CTL_MINFLTPER |
                                       PWM_X_CTL_FLTSRC |
                                       PWM_X_CTL_DBFALLUPD_M |
                                       PWM_X_CTL_DBRISEUPD_M |
                                       PWM_X_CTL_DBCTLUPD_M |
                                       PWM_X_CTL_GENBUPD_M |
                                       PWM_X_CTL_GENAUPD_M |
                                       PWM_X_CTL_LOADUPD | PWM_X_CTL_CMPAUPD |
                                       PWM_X_CTL_CMPBUPD)4294443009~(PWM_X_CTL_MODE | PWM_X_CTL_DEBUG |
                                       PWM_X_CTL_LATCH | PWM_X_CTL_MINFLTPER |
                                       PWM_X_CTL_FLTSRC |
                                       PWM_X_CTL_DBFALLUPD_M |
                                       PWM_X_CTL_DBRISEUPD_M |
                                       PWM_X_CTL_DBCTLUPD_M |
                                       PWM_X_CTL_GENBUPD_M |
                                       PWM_X_CTL_GENAUPD_M |
                                       PWM_X_CTL_LOADUPD | PWM_X_CTL_CMPAUPD |
                                       PWM_X_CTL_CMPBUPD)ui32Gen + PWM_O_X_GENAui32Gen + 0x00000020ui32Gen + PWM_O_X_GENBui32Gen + 0x00000024(PWM_X_GENA_ACTCMPAU_ONE |
                                         PWM_X_GENA_ACTCMPAD_ZERO)2816(PWM_X_GENB_ACTCMPBU_ONE |
                                         PWM_X_GENB_ACTCMPBD_ZERO)(PWM_X_GENA_ACTLOAD_ONE |
                                         PWM_X_GENA_ACTCMPAD_ZERO)(PWM_X_GENB_ACTLOAD_ONE |
                                         PWM_X_GENB_ACTCMPBD_ZERO)PWM_IS_OUTPUT_ODD(_out_)((_out_) & 0x00000001)PWM_OUT_BADDR(_mod_,_out_)((_mod_) + ((_out_) & 0xFFFFFFC0))PWM_GEN_EXT_BADDR(_mod_,_gen_)((_mod_) + PWM_GEN_EXT_0 + ((_gen_) - PWM_GEN_0) * 2)PWM_GEN_BADDR(_mod_,_gen_)((_mod_) + (_gen_))// Write the updated values to Enable Update register.// updated.// Read the Enable Update register and mask the bits that are to be// Update the PWM output to be checked and the index.// Compute the mask for the bits to be updated.// writing to the appropriate field.// Set the update mode value for the requested PWM output by// Check if this PWM output is to be modified.// Loop to find out which PWM outputs are to be modified.// Initialize the local variables//! \note This function is only available on Snowflake class devices.//! parameter.//! PWMSyncUpdate() which specifies the same generator in its \e ui32GenBits//! the local PWM generator's count next reaches 0 following a call to//! - \b PWM_OUTPUT_MODE_SYNC_GLOBAL, which causes changes to take effect when//! the local PWM generator's count next reaches 0.//! - \b PWM_OUTPUT_MODE_SYNC_LOCAL, which causes changes to take effect when//! immediately.//! - \b PWM_OUTPUT_MODE_NO_SYNC, which enables/disables changes to take effect//! made via calls to PWMOutputState() take effect.  Possible values are://! the requested PWM outputs.  The \e ui32Mode parameter controls when changes//! This function sets one of three possible update modes to enable or disable//! disabling PWM outputs.//! \param ui32Mode specifies the enable update mode to use when enabling or//! \b PWM_OUT_6_BIT, or \b PWM_OUT_7_BIT.//! \b PWM_OUT_2_BIT, \b PWM_OUT_3_BIT, \b PWM_OUT_4_BIT, \b PWM_OUT_5_BIT,//! must be the logical OR of any of \b PWM_OUT_0_BIT, \b PWM_OUT_1_BIT,//! \param ui32PWMOutBits are the PWM outputs to be modified.  This parameter//! \param ui32Base is the base address of the PWM module.//! Sets the update mode or synchronization mode to the PWM outputs.// The divider is active so directly return the masked register value.// The divider is not active so reflect this in the value we return.// PWM_SYSCLK_DIV_1 is returned in all cases where the divider is disabled.// Return the current PWM clock configuration.  Make sure that//! or \b PWM_SYSCLK_DIV_64.//! \b PWM_SYSCLK_DIV_8, \b PWM_SYSCLK_DIV_16, \b PWM_SYSCLK_DIV_32,//! \b PWM_SYSCLK_DIV_1, \b PWM_SYSCLK_DIV_2, \b PWM_SYSCLK_DIV_4,//! \return Returns the current PWM clock configuration; is one of//! TM4C123 devices, the SysCtlPWMClockGet() function should be used.//! \note This function should not be used with TM4C123 devices.  For//! This function returns the current PWM clock configuration.//! Gets the current PWM clock configuration.// Set the PWM clock configuration into the PWM clock configuration//! configured by SysCtlClockFreqSet().//! \note The clocking of the PWM is dependent upon the system clock rate as//! signals; its rate forms the basis for all PWM signals.//! system clock.  This clock is used by the PWM module to generate PWM//! configures the clock frequency to the PWM module as a division of the//! This function sets the PWM clock divider as the PWM clock source.  It also//! \b PWM_SYSCLK_DIV_64.//! \b PWM_SYSCLK_DIV_8, \b PWM_SYSCLK_DIV_16, \b PWM_SYSCLK_DIV_32, or//! \param ui32Config is the configuration for the PWM clock; it must be one of//! Sets the PWM clock configuration.///// Clear the given faults.// Check for valid parameters.//! fault handling.//! \note This function is only available on devices supporting extended PWM//! parameter \e ui32Config.//! has previously been called with flag \b PWM_GEN_MODE_FAULT_LATCHED in//! given PWM generator.  This function is only required if PWMGenConfigure()//! This function allows an application to clear the fault triggers for a//! \param ui32FaultTriggers is the set of fault triggers which are to be//! This parameter must be \b PWM_FAULT_GROUP_0 or \b PWM_FAULT_GROUP_1.//! \param ui32Group indicates the subset of faults that are being queried.//! \b PWM_GEN_2, or \b PWM_GEN_3.//! being queried.  This parameter must be one of \b PWM_GEN_0, \b PWM_GEN_1,//! \param ui32Gen is the PWM generator for which fault trigger states are//! Clears one or more latched fault triggers for a given PWM generator.// Return the current fault status.//! \b PWM_FAULT_DCMP5, \b PWM_FAULT_DCMP6, or \b PWM_FAULT_DCMP7.//! \b PWM_FAULT_DCMP2, \b PWM_FAULT_DCMP3, \b PWM_FAULT_DCMP4,//! logical OR of \b PWM_FAULT_DCMP0, \b PWM_FAULT_DCMP1,//! \b PWM_FAULT_FAULT3.  For \b PWM_FAULT_GROUP_1, the return value is the//! \b PWM_FAULT_FAULT0, \b PWM_FAULT_FAULT1, \b PWM_FAULT_FAULT2, or//! For \b PWM_FAULT_GROUP_0, the returned value is a logical OR of//! generator.  A set bit indicates that the associated trigger is active.//! \return Returns the current state of the fault triggers for the given PWM//! PWMGenFaultClear() to clear each trigger.//! If latched faults are configured, the application must call//! fault trigger status.//! \e ui32Config parameter, in which case the returned status is the latched//! previously been called with flag \b PWM_GEN_MODE_FAULT_LATCHED in the//! each fault trigger input is returned unless PWMGenConfigure() has//! the fault trigger inputs to a given PWM generator.  The current state of//! This function allows an application to query the current state of each of//! Returns the current state of the fault triggers for a given PWM generator.// Return the current fault triggers.//! provided.  For \b PWM_FAULT_GROUP_0, the returned value is a logical OR of//! \return Returns the current fault triggers configured for the fault group//! contribute to the generation of a fault condition to a given PWM generator.//! This function allows an application to query the current set of inputs that//! queried.  This parameter must be one of \b PWM_GEN_0, \b PWM_GEN_1,//! \param ui32Gen is the PWM generator for which fault triggers are being//! generator.//! Returns the set of fault triggers currently configured for a given PWM// Write the fault triggers to the appropriate register.//! previously set using a call to PWMGenFaultConfigure().//! adjusted the sense of each FAULTn input based on the configuration//! of the signals specified in the \e ui32FaultTriggers parameter after having//! The fault signal to the PWM generator is generated by ORing together each//! function must be called to configure the fault triggers.//! \e ui32Config parameter, extended fault handling is enabled and this//! PWMGenConfigure() is called with flag \b PWM_GEN_MODE_FAULT_SRC in the//! generators use only FAULT0 (for backwards compatibility) but if//! to generate a fault condition to a given PWM generator.  By default, all//! This function allows selection of the set of fault inputs that is combined//! \b PWM_FAULT_DCMP7.//! \b PWM_FAULT_DCMP4, \b PWM_FAULT_DCMP5, \b PWM_FAULT_DCMP6, or//! \b PWM_FAULT_DCMP1, \b PWM_FAULT_DCMP2, \b PWM_FAULT_DCMP3,//! \b PWM_FAULT_GROUP_1, this is the logical OR of \b PWM_FAULT_DCMP0,//! \b PWM_FAULT_FAULT1, \b PWM_FAULT_FAULT2, or \b PWM_FAULT_FAULT3.  For//! \b PWM_FAULT_GROUP_0, this is the logical OR of \b PWM_FAULT_FAULT0,//! towards generation of the fault signal to the given PWM generator.  For//! \param ui32FaultTriggers defines the set of inputs that are to contribute//! \b PWM_FAULT_GROUP_1.//! configured.  This parameter must be \b PWM_FAULT_GROUP_0 or//! \param ui32Group indicates the subset of possible faults that are to be//! \b PWM_GEN_3.//! This parameter must be one of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or//! \param ui32Gen is the PWM generator for which fault triggers are being set.//! Configures the set of fault triggers for a given PWM generator.// Write the fault senses.// Write the minimum fault period.//! clock cycles specified.//! period timer ensures that it remains asserted for at least the number of//! \e ui32Config parameter.  When a fault input is asserted, the minimum fault//! PWMGenConfigure() is called with flag \b PWM_GEN_MODE_FAULT_PER set in the//! fault period is expressed in PWM clock cycles and takes effect only if//! along with the sense of each of the 4 possible fault inputs.  The minimum//! This function configures the minimum fault period for a given generator//! combinations of \b PWM_FAULTn_SENSE_HIGH and \b PWM_FAULTn_SENSE_LOW.//! considered the ``asserted'' state.  Valid values are logical OR//! \param ui32FaultSenses indicates which sense of each FAULT input should be//! PWM clock cycles.//! \param ui32MinFaultPeriod is the minimum fault active period expressed in//! set.  This function must be one of \b PWM_GEN_0, \b PWM_GEN_1,//! \param ui32Gen is the PWM generator for which fault configuration is being//! PWM generator.//! Configures the minimum fault period and fault pin senses for a given// Clear the supplied fault bits.//! possible PWM generators. //! the device but indicate that a fault has been signaled to one of the four //! interrupts are not directly related to the four possible FAULTn inputs to //! configured fault trigger signals for a given generator.  Therefore, these//! The fault interrupts are derived by performing a logical OR of each of the //! \b PWM_INT_FAULT1, \b PWM_INT_FAULT2, or \b PWM_INT_FAULT3.//! \e ui32FaultInts must be the logical OR of any of \b PWM_INT_FAULT0,//!  appropriate bit of the PWM interrupt status register.  The parameter//! This function clears one or more fault interrupts by writing to the//! \param ui32FaultInts specifies the fault interrupts to clear.//! Clears the fault interrupt for a PWM module.// Read and return either the module's raw or enabled interrupt status.//! \b PWM_INT_FAULT3.//! \b PWM_INT_FAULT0, \b PWM_INT_FAULT1, \b PWM_INT_FAULT2, and//! \b PWM_INT_GEN_0, \b PWM_INT_GEN_1, \b PWM_INT_GEN_2, \b PWM_INT_GEN_3,//! Gets the interrupt status for a PWM module.// Write the only writeable bit in the module's interrupt register.//! with and without extended PWM fault handling support.//! used instead because it supports all fault interrupts supported on devices//! backwards compatibility.  It is recommended that PWMFaultIntClearExt() be//! This function clears only the FAULT0 interrupt and is retained for//! of the interrupt status register for the selected PWM module.//! This function clears the fault interrupt by writing to the appropriate bit// for the specified PWM generators.// Read the module's interrupt enable register and disable interrupts//! bits of the interrupt enable register for the selected PWM module.//! This function masks the specified interrupt(s) by clearing the specified//! \b PWM_INT_FAULT2, or \b PWM_INT_FAULT3.//! \b PWM_INT_GEN_2, \b PWM_INT_GEN_3, \b PWM_INT_FAULT0, \b PWM_INT_FAULT1,//! must be a logical OR of any of \b PWM_INT_GEN_0, \b PWM_INT_GEN_1,//! \param ui32GenFault contains the interrupts to be disabled.  This parameter//! Disables generator and fault interrupts for a PWM module.// Read the module's interrupt enable register and enable interrupts//! This function unmasks the specified interrupt(s) by setting the specified//! \param ui32GenFault contains the interrupts to be enabled.  This parameter//! Enables generator and fault interrupts for a PWM module.// of the module's interrupt enable register.// Clear the requested interrupts by writing ones to the specified bit//! \b PWM_INT_CNT_AD, \b PWM_INT_CNT_BU, or \b PWM_INT_CNT_BD.//! \b PWM_INT_CNT_ZERO, \b PWM_INT_CNT_LOAD, \b PWM_INT_CNT_AU,//! generator.  The \e ui32Ints parameter is the logical OR of//! specified bits of the interrupt status register for the specified PWM//! This function clears the specified interrupt(s) by writing a 1 to the//! \param ui32Ints specifies the interrupts to be cleared.//! of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.//! \param ui32Gen is the PWM generator to query.  This parameter must be one//! Clears the specified interrupt(s) for the specified PWM generator block.// status.// Read and return the specified generator's raw or enabled interrupt// Compute the generator's base address.//! contents of the raw interrupt status register for the specified//! \return Returns the contents of the interrupt status register or the//! of \b PWM_GEN_0,  \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.//! Gets interrupt status for the specified PWM generator block.// Disable the specified interrupts/triggers.//! \b PWM_TR_CNT_BU, or \b PWM_TR_CNT_BD.//! \b PWM_TR_CNT_ZERO, \b PWM_TR_CNT_LOAD, \b PWM_TR_CNT_AU, \b PWM_TR_CNT_AD,//! \b PWM_INT_CNT_AD, \b PWM_INT_CNT_BU, \b PWM_INT_CNT_BD,//! specified PWM generator.  The \e ui32IntTrig parameter is the logical OR of//! the specified bits of the interrupt/trigger enable register for the//! This function masks the specified interrupt(s) and trigger(s) by clearing//! \param ui32IntTrig specifies the interrupts and triggers to be disabled.//! disabled.  This parameter must be one of \b PWM_GEN_0, \b PWM_GEN_1,//! \param ui32Gen is the PWM generator to have interrupts and triggers//! Disables interrupts for the specified PWM generator block.// Enable the specified interrupts/triggers.//! This function unmasks the specified interrupt(s) and trigger(s) by setting//! \param ui32IntTrig specifies the interrupts and triggers to be enabled.//! enabled.  This parameter must be one of \b PWM_GEN_0, \b PWM_GEN_1,//! Enables interrupts and triggers for the specified PWM generator block.// Unregister the interrupt handler, returning an error if one occurs.// Disable the PWM fault interrupt.// Get the interrupt number associated with the specified module.//! at the module level using PWMIntDisable().//! fault interrupt in the NVIC; the PWM fault interrupt must also be disabled//! from the selected PWM module.  This function also disables the PWM//! This function removes the interrupt handler for a PWM fault interrupt//! Removes the PWM fault condition interrupt handler.// Enable the PWM fault interrupt.// Register the interrupt handler, returning an error if one occurs.//! module level using PWMIntEnable().//! interrupt in the NVIC; the PWM fault interrupt must also be enabled at the//! selected PWM module.  This function also enables the PWM fault//! \e pfnIntHandler is called when a fault interrupt is detected for the//! fault interrupt occurs.//! \param pfnIntHandler is a pointer to the function to be called when the PWM//! Registers an interrupt handler for a fault condition detected in a PWM// Return the fault interrupt number.//! \return Returns the interrupt number.//! PWM module.//! This function returns the fault interrupt number of the corresponding//! Gets the PWM fault interrupt number.// Disable the PWMx interrupt.// Get the interrupt number associated with the specified generator.//! PWMGenIntTrigDisable().//! interrupts and interrupt sources must be disabled with PWMIntDisable() and//! PWM generator interrupt in the interrupt controller; individual generator//! PWM generator block.  This function also disables the corresponding//! one of \b PWM_GEN_0, \b PWM_GEN_1, \b PWM_GEN_2, or \b PWM_GEN_3.//! \param ui32Gen is the PWM generator in question.  This parameter must be//! Removes an interrupt handler for the specified PWM generator block.// Enable the PWMx interrupt.//! PWMGenIntTrigEnable().//! interrupts and interrupt sources must be enabled with PWMIntEnable() and//! PWM generator block.  This function also enables the corresponding//! \e pfnIntHandler is called when an interrupt is detected for the specified//! generator interrupt occurs.//! Registers an interrupt handler for the specified PWM generator block.// An unknown PWM module/generator was specified.// The first PWM generator in the second PWM module.// The fourth PWM generator in the first PWM module.// The third PWM generator in the first PWM module.// The second PWM generator in the first PWM module.// The first PWM generator in the first PWM module.// Determine the generator and PWM module in question.//! This function returns the interrupt number of the corresponding PWM//! Gets the PWM generator interrupt number.// requested bits.// Read the module's FAULT output control register and set or clear the//! handling, affected outputs are driven low on a fault condition.//! not configured, or if the device does not support extended PWM fault//! output pins are driven to can be configured with PWMOutputFaultLevel().  If//! On devices supporting extended PWM fault handling, the state the affected//! \b false, then the selected outputs are unaffected by the detected fault.//! then the selected outputs are made inactive.  If \e bFaultSuppress is//! characteristics for the selected outputs.  If \e bFaultSuppress is \b true,//! The parameter \e bFaultSuppress determines the fault handling//! outputs.  The outputs are selected using the parameter \e ui32PWMOutBits.//! This function sets the fault handling characteristics of the selected PWM//! through during an active fault condition.//! \param bFaultSuppress determines if the signal is suppressed or passed//! must be the  logical OR of any of \b PWM_OUT_0_BIT, \b PWM_OUT_1_BIT,//! Specifies the state of PWM outputs in response to a fault condition.//! PWM fault handling.//! \note This function is available only on devices which support extended//! via a call to PWMOutputFault() are unaffected by this function.//! In a fault condition, pins which have not been configured to be suppressed//! driven low.//! are driven high when a fault is detected.  If it is \e false, the pins are//! \e ui32PWMOutBits.  If \e bDriveHigh is \b true then the selected outputs//! \e bDriveHigh determines the output level for the pins identified by//! are selected using the parameter \e ui32PWMOutBits.  The parameter//! response to a fault condition is driven high or low.  The affected outputs//! This function determines whether a PWM output pin that is suppressed in//! active fault condition.//! \param bDriveHigh determines if the signal is driven high or low during an//! condition.//! Specifies the level of PWM outputs suppressed in response to a fault// Read the module's INVERT output control register and set or clear the//! \b false, the specified outputs are passed through as is or made active//! PWM output signals to be inverted or made active low.  If \e bInvert is//! outputs.  If \e bInvert is \b true, this function causes the specified//! The parameter \e bInvert determines the inversion mode for the selected//! This function is used to select the inversion mode for the selected PWM//! \param bInvert determines if the signal is inverted or passed through.//! Selects the inversion mode for PWM outputs.// Read the module's ENABLE output control register and set or clear the//! or placed in the inactive state.//! state.  If \e bEnable is \b false, then the selected outputs are disabled//! \b true, then the selected PWM outputs are enabled, or placed in the active//! bEnable determines the state of the selected outputs.  If \e bEnable is//! are selected using the parameter \e ui32PWMOutBits.  The parameter \e//! This function enables or disables the selected PWM outputs.  The outputs//! \param bEnable determines if the signal is enabled or disabled.//! Enables or disables PWM outputs.// module's synchronization register.// Synchronize the counters in the specified generators by writing to the//! reset to zero.//! the generator blocks by causing the specified generator counters to be//! For the selected PWM module, this function synchronizes the time base of//! \b PWM_GEN_1_BIT, \b PWM_GEN_2_BIT, or \b PWM_GEN_3_BIT.//! parameter must be the logical OR of any of \b PWM_GEN_0_BIT,//! \param ui32GenBits are the PWM generator blocks to be synchronized.  This//! Synchronizes the counters in one or multiple PWM generator blocks.// Synchronize pending PWM register changes.//! counter becomes zero.//! the period or pulse width to be applied the next time the corresponding//! For the selected PWM generators, this function causes all queued updates to//! \param ui32GenBits are the PWM generator blocks to be updated.  This//! Synchronizes all pending updates.// Disable the deadband functionality.//! Doing so decouples the \b OutA and \b OutB signals.//! This function disables the dead band mode for the specified PWM generator.//! \param ui32Gen is the PWM generator to modify.  This parameter must be one//! Disables the PWM dead band output.// Enable the deadband functionality.// Write the dead band delay values.//! function causes the coupling of \b OutB to \b OutA.//! rising or falling edge of the generator's \b OutA signal.  Note that this//! the dead bands are defined as the number of \b PWM clock ticks from the//! This function sets the dead bands for the specified PWM generator, where//! \param ui16Fall specifies the width of delay from the falling edge.//! \param ui16Rise specifies the width of delay from the rising edge.//! Enables the PWM dead band output and sets the dead band delays.// Return the pulse width.// If in up/down count mode, double the pulse width.// width = (load - compare) * 2.  Otherwise, set width = load - compare.// Then compute the pulse width.  If mode is UpDown, set//! \return Returns the width of the pulse in PWM clock ticks.//! ticks.//! The value returned is the programmed pulse width, measured in PWM clock//! yet to be completed, the value returned may not be the active pulse width.//! PWM output.  If the update of the comparator for the specified output has//! This function gets the currently programmed pulse width for the specified//! \b PWM_OUT_5, \b PWM_OUT_6, or \b PWM_OUT_7.//! of \b PWM_OUT_0, \b PWM_OUT_1, \b PWM_OUT_2, \b PWM_OUT_3, \b PWM_OUT_4,//! \param ui32PWMOut is the PWM output to query.  This parameter must be one//! Gets the pulse width of a PWM output.// Write to the appropriate registers.// Compute the compare value.// Make sure the width is not too large.// Get the period.// If the counter is in up/down count mode, divide the width by two.//! cause the previous values to be overwritten.//! \note Any subsequent calls made to this function before an update occurs//! pulse width is defined as the number of PWM clock ticks.//! This function sets the pulse width for the specified PWM output, where the//! \param ui32Width specifies the width of the positive portion of the pulse.//! \param ui32PWMOut is the PWM output to modify.  This parameter must be one//! Sets the pulse width for the specified PWM output.// Disable the PWM generator.//! specified generator block.//! This function blocks the PWM clock from driving the timer/counter for the//! \param ui32Gen is the PWM generator to be disabled.  This parameter must be//! Disables the timer/counter for a PWM generator block.// Enable the PWM generator.//! This function allows the PWM clock to drive the timer/counter for the//! \param ui32Gen is the PWM generator to be enabled.  This parameter must be//! Enables the timer/counter for a PWM generator block.// The period is the reload register value plus one.// The period is twice the reload register value.// Figure out the counter mode.//! in PWM clock ticks.//! \return Returns the programmed period of the specified generator block//! value returned is the programmed period, measured in PWM clock ticks.//! to be completed, the value returned may not be the active period.  The//! If the update of the counter for the specified PWM generator has yet//! between pulses on the generator block zero signal.//! period of the generator block is defined as the number of PWM clock ticks//! This function gets the period of the specified PWM generator block.  The//! Gets the period of a PWM generator block.// minus one.// In down count mode, set the reload register to the requested period// period.// In up/down count mode, set the reload register to half the requested// Set the reload register based on the mode.//! ticks between pulses on the generator block zero signal.//! the period of the generator block is defined as the number of PWM clock//! This function sets the period of the specified PWM generator block, where//! in clock ticks.//! \param ui32Period specifies the period of PWM generator output, measured//! \param ui32Gen is the PWM generator to be modified.  This parameter must be//! Sets the period of a PWM generator.// comparison (that is, left align the signals).// In down count mode, set the signal high on load and low on count// signals).// and low on down count comparison (that is, center align the// In up/down count mode, set the signal high on up count comparison// Set the individual PWM generator controls.// Change the global configuration of the generator.//! any changes to the counter mode of a generator.//! produced.  PWMGenPeriodSet() and PWMPulseWidthSet() should be called after//! \note Changes to the counter mode affect the period of the PWM signals//! prior to expiration of the fault timer.//! fault interrupt handler may, therefore, reenter immediately if it exits//! period, the fault interrupt from the PWM generator remains asserted.  The//! should be taken when using this mode because during the fault signal//! least this time even if the external fault pin deasserts earlier.  Care//! minimum duration of a PWM fault signal.  Faults are signaled for at//! Setting \b PWM_GEN_MODE_FAULT_MINPER allows an application to set the//!   whether extended fault source selection support is enabled or not//! - \b PWM_GEN_MODE_FAULT_EXT or \b PWM_GEN_MODE_FAULT_LEGACY to specify//!   specify whether minimum fault period support is required//! - \b PWM_GEN_MODE_FAULT_MINPER or \b PWM_GEN_MODE_FAULT_NO_MINPER to//!   specify whether fault conditions are latched or not//! - \b PWM_GEN_MODE_FAULT_LATCHED or \b PWM_GEN_MODE_FAULT_UNLATCHED to//!   synchronization mode//!   \b PWM_GEN_MODE_DB_SYNC_GLOBAL to specify the deadband parameter//! - \b PWM_GEN_MODE_DB_NO_SYNC, \b PWM_GEN_MODE_DB_SYNC_LOCAL, or//!   mode for generator counting mode changes//!   \b PWM_GEN_MODE_GEN_SYNC_GLOBAL to specify the update synchronization//! - \b PWM_GEN_MODE_GEN_NO_SYNC, \b PWM_GEN_MODE_GEN_SYNC_LOCAL, or//!   behavior//! - \b PWM_GEN_MODE_DBG_RUN or \b PWM_GEN_MODE_DBG_STOP to specify the debug//!   load and comparator update synchronization mode//! - \b PWM_GEN_MODE_SYNC or \b PWM_GEN_MODE_NO_SYNC to specify the counter//!   mode//! - \b PWM_GEN_MODE_DOWN or \b PWM_GEN_MODE_UP_DOWN to specify the counting//! The \e ui32Config parameter contains the desired configuration.  It is the//! counting as if nothing had happened.//! processor is restarted.  If configured to continue running, it keeps//! count until it reaches zero, at which point it pauses until the//! is stopped via the debugger.  If configured to pause, it continues to//! The PWM generator can either pause or continue running when the processor//! during the update (that is, a PWM pulse that is too short or too long).//! occur when the counter is at zero to help prevent oddly formed PWM signals//! until a synchronization event.  In either mode, the parameter updates only//! generator.  In non-synchronous mode, the parameter updates are not delayed//! simultaneously, allowing them to be treated as if they were a unified//! to multiple PWM generators in synchronous mode can be updated//! effect simultaneously, instead of one at a time.  Additionally, parameters//! occurs.  This mode allows multiple parameters to be modified and take//! mode, the parameter updates are not applied until a synchronization event//! their effect on the output PWM signals can be delayed.  In synchronous//! When the PWM generator parameters (period and pulse width) are modified,//! generator occurs at the same time).//! the middle of the high/low period of the PWM signals produced by the//! the process, producing center-aligned PWM signals (that is,//! from zero to the preset value, counts back down to zero, and then repeats//! generator occur at the same time).  In count up/down mode, it counts up//! signals (that is, the rising edge of the two PWM signals produced by the//! and then resets to the preset value, producing left-aligned PWM//! up/down mode.  In count down mode, it counts from a value down to zero,//! A PWM generator can count in two different modes:  count down mode or count//! state.//! configured.  After configuration, the generator is left in the disabled//! The counting mode, synchronization mode, and debug behavior are all//! This function is used to set the mode of operation for a PWM generator.//! \param ui32Config is the configuration for the PWM generator.//! \param ui32Gen is the PWM generator to configure.  This parameter must be//! Configures a PWM generator.//! \return Returns \b true if the output number is valid and \b false//! This function determines if a PWM output number is valid.//! \param ui32PWMOut is the output number.//! Checks a PWM output number.//! \return Returnes \b true if the generator number is valid and \b false//! This function determines if a PWM generator number is valid.//! \param ui32Gen is the generator number.//! Checks a PWM generator number.// by the API.// Misc macros for manipulating the encoded generator and output defines used//! \addtogroup pwm_api// pwm.c - API for the PWM modules/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/inc/hw_qei.hQEI_ISC_INDEXQEI_ISC_TIMERQEI_ISC_DIRQEI_ISC_ERRORQEI_RIS_INDEXQEI_RIS_TIMERQEI_RIS_DIRQEI_RIS_ERRORQEI_INTEN_INDEXQEI_INTEN_TIMERQEI_INTEN_DIRQEI_INTEN_ERRORQEI_SPEED_SQEI_SPEED_MQEI_COUNT_SQEI_COUNT_MQEI_TIME_SQEI_TIME_MQEI_LOAD_SQEI_LOAD_MQEI_MAXPOS_SQEI_MAXPOS_MQEI_POS_SQEI_POS_MQEI_STAT_ERRORQEI_STAT_DIRECTIONQEI_CTL_FILTCNT_SQEI_CTL_ENABLEQEI_CTL_SWAPQEI_CTL_SIGMODEQEI_CTL_CAPMODEQEI_CTL_RESMODEQEI_CTL_VELENQEI_CTL_VELDIV_128QEI_CTL_VELDIV_64QEI_CTL_VELDIV_32QEI_CTL_VELDIV_16QEI_CTL_VELDIV_8QEI_CTL_VELDIV_4QEI_CTL_VELDIV_2QEI_CTL_VELDIV_1QEI_CTL_VELDIV_MQEI_CTL_INVAQEI_CTL_INVBQEI_CTL_INVIQEI_CTL_STALLENQEI_CTL_FILTENQEI_CTL_FILTCNT_MQEI_O_ISCQEI_O_RISQEI_O_INTENQEI_O_SPEEDQEI_O_COUNTQEI_O_TIMEQEI_O_LOADQEI_O_MAXPOSQEI_O_POSQEI_O_STATQEI_O_CTL__HW_QEI_H__// __HW_QEI_H__// Index Pulse Interrupt// Velocity Timer Expired Interrupt// Direction Change Interrupt// Phase Error Interrupt// The following are defines for the bit fields in the QEI_O_ISC register.// Index Pulse Asserted// Velocity Timer Expired// Direction Change Detected// Phase Error Detected// The following are defines for the bit fields in the QEI_O_RIS register.// Index Pulse Detected Interrupt// Timer Expires Interrupt Enable// Phase Error Interrupt Enable// The following are defines for the bit fields in the QEI_O_INTEN register.// Velocity// The following are defines for the bit fields in the QEI_O_SPEED register.// Velocity Pulse Count// The following are defines for the bit fields in the QEI_O_COUNT register.// Velocity Timer Current Value// The following are defines for the bit fields in the QEI_O_TIME register.// Velocity Timer Load Value// The following are defines for the bit fields in the QEI_O_LOAD register.// Value// Maximum Position Integrator// The following are defines for the bit fields in the QEI_O_MAXPOS register.// Current Position Integrator// The following are defines for the bit fields in the QEI_O_POS register.// Error Detected// Direction of Rotation// The following are defines for the bit fields in the QEI_O_STAT register.// Enable QEI// Swap Signals// Signal Mode// Capture Mode// Reset Mode// Capture Velocity// QEI clock /128// QEI clock /64// QEI clock /32// QEI clock /16// QEI clock /8// QEI clock /4// QEI clock /2// QEI clock /1// Predivide Velocity// Invert PhA// Invert PhB// Invert Index Pulse// Stall QEI// Enable Input Filter// Input Filter Prescale Count// The following are defines for the bit fields in the QEI_O_CTL register.// QEI Interrupt Status and Clear// QEI Raw Interrupt Status// QEI Interrupt Enable// QEI Velocity// QEI Velocity Counter// QEI Timer// QEI Timer Load// QEI Maximum Position// QEI Position// QEI Status// QEI Control// The following are defines for the QEI register offsets.// hw_qei.h - Macros used when accessing the QEI hardware./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/qei.hQEI_INTINDEXQEI_INTTIMERQEI_INTDIRQEI_INTERRORQEI_VELDIV_128QEI_VELDIV_64QEI_VELDIV_32QEI_VELDIV_16QEI_VELDIV_8QEI_VELDIV_4QEI_VELDIV_2QEI_VELDIV_1QEI_FILTCNT_17QEI_FILTCNT_16QEI_FILTCNT_15QEI_FILTCNT_14QEI_FILTCNT_13QEI_FILTCNT_12QEI_FILTCNT_11QEI_FILTCNT_10QEI_FILTCNT_9QEI_FILTCNT_8QEI_FILTCNT_7QEI_FILTCNT_6QEI_FILTCNT_5QEI_FILTCNT_4QEI_FILTCNT_3QEI_FILTCNT_2QEI_CONFIG_SWAPQEI_CONFIG_NO_SWAPQEI_CONFIG_CLOCK_DIRQEI_CONFIG_QUADRATUREQEI_CONFIG_RESET_IDXQEI_CONFIG_NO_RESETQEI_CONFIG_CAPTURE_A_BQEI_CONFIG_CAPTURE_A__DRIVERLIB_QEI_H__QEIIntClearQEIIntStatusQEIIntDisableQEIIntEnableQEIIntUnregisterQEIIntRegisterQEIVelocityGetQEIVelocityConfigureQEIVelocityDisableQEIVelocityEnableQEIFilterConfigureQEIFilterDisableQEIFilterEnableQEIErrorGetQEIDirectionGetQEIPositionSetQEIPositionGetQEIConfigureQEIDisableQEIEnable// __DRIVERLIB_QEI_H__// Index pulse detected// Velocity timer expired// Direction change// Phase error detected// as the ui32IntFlags parameter, and returned by QEIGetIntStatus.// Values that can be passed to QEIEnableInts, QEIDisableInts, and QEIClearInts// Predivide by 128// Predivide by 64// Predivide by 32// Predivide by 16// Predivide by 8// Predivide by 4// Predivide by 2// Predivide by 1// Values that can be passed to QEIVelocityConfigure as the ui32PreDiv// Filter Count of 17 System Clocks// Filter Count of 16 System Clocks// Filter Count of 15 System Clocks// Filter Count of 14 System Clocks// Filter Count of 13 System Clocks// Filter Count of 12 System Clocks// Filter Count of 11 System Clocks// Filter Count of 10 System Clocks// Filter Count of 9 System Clocks// Filter Count of 8 System Clocks// Filter Count of 7 System Clocks// Filter Count of 6 System Clocks// Filter Count of 5 System Clocks// Filter Count of 4 System Clocks// Filter Count of 3 System Clocks// Filter Count of 2 System Clocks// Values that can be passed to QEIFilterConfigure as the ui32PreDiv// Swap ChA and ChB// Do not swap ChA and ChB// ChA and ChB are clock and dir// ChA and ChB are quadrature// Reset position on index pulse// Do not reset on index pulse// Count on ChA and ChB edges// Count on ChA edges only// Values that can be passed to QEIConfigure as the ui32Config paramater.// qei.h - Prototypes for the Quadrature Encoder Driver.ui32PreDivui32FiltCntui32Positionui32MaxPosition/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/qei.c"driverlib/qei.h""inc/hw_qei.h"ui32Base + QEI_O_ISC(ui32Base == QEI0_BASE) || (ui32Base == QEI1_BASE)ui32Base + QEI_O_RISui32Base + QEI_O_INTEN_QEIIntNumberGet1073922048QEI0_BASEui32Base + QEI_O_SPEEDui32Base + QEI_O_CTL448(QEI_CTL_VELDIV_M)4294966847~(QEI_CTL_VELDIV_M)ui32Base + QEI_O_LOAD!(ui32PreDiv & ~(QEI_CTL_VELDIV_M))ui32Period != 0(QEI_CTL_VELEN)~(QEI_CTL_VELEN)(QEI_CTL_FILTCNT_M)~(QEI_CTL_FILTCNT_M)!(ui32FiltCnt & ~(QEI_CTL_FILTCNT_M))(QEI_CTL_FILTEN)~(QEI_CTL_FILTEN)ui32Base + QEI_O_STATui32Base + QEI_O_POS(QEI_CTL_CAPMODE | QEI_CTL_RESMODE |
                                      QEI_CTL_SIGMODE | QEI_CTL_SWAP)4294967265~(QEI_CTL_CAPMODE | QEI_CTL_RESMODE |
                                      QEI_CTL_SIGMODE | QEI_CTL_SWAP)ui32Base + QEI_O_MAXPOS(QEI_CTL_ENABLE)~(QEI_CTL_ENABLE)// Clear the requested interrupt sources.//! exit.//! handler to keep the interrupt from being triggered again immediately upon//! they no longer assert.  This function must be called in the interrupt//! The specified quadrature encoder interrupt sources are cleared, so that//! \b QEI_INTTIMER, or \b QEI_INTINDEX values.//! This parameter can be any of the \b QEI_INTERROR, \b QEI_INTDIR,//! \param ui32Base is the base address of the quadrature encoder module.//! Clears quadrature encoder interrupt sources.//! \b QEI_INTERROR, \b QEI_INTDIR, \b QEI_INTTIMER, and \b QEI_INTINDEX.//! module.  Either the raw interrupt status or the status of interrupts that//! This function returns the interrupt status for the quadrature encoder//! This function disables the indicated quadrature encoder interrupt sources.//! Disables individual quadrature encoder interrupt sources.//! This function enables the indicated quadrature encoder interrupt sources.//! \b QEI_INTINDEX values.//! Can be any of the \b QEI_INTERROR, \b QEI_INTDIR, \b QEI_INTTIMER, or//! Enables individual quadrature encoder interrupt sources.// Determine the interrupt number based on the QEI module.//! the interrupt controller so that the interrupt handler no longer is called.//! encoder interrupt occurs.  This function also masks off the interrupt in//! This function unregisters the handler to be called when a quadrature//! Unregisters an interrupt handler for the quadrature encoder interrupt.// Enable the quadrature encoder interrupt.//! to clear the interrupt source via QEIIntClear().//! enabled via QEIIntEnable().  It is the interrupt handler's responsibility//! interrupt controller; specific quadrature encoder interrupts must be//! This function registers the handler to be called when a quadrature encoder//! quadrature encoder interrupt occurs.//! Registers an interrupt handler for the quadrature encoder interrupt.// Find the valid interrupt number for this quadrature encoder.//! \return Returns a quadrature encoder interrupt number or 0 if the interrupt//! the base address passed in the \e ui32Base parameter.//! This function returns the interrupt number for the quadrature encoder with//! \param ui32Base is the base address of the selected quadrature encoder//! Returns the quadrature encoder interrupt number.// Return the speed capture value.//! \return Returns the number of pulses captured in the given time period.//! second.//! the number of pulses per revolution to obtain the number of revolutions per//! can be multiplied by the number of time periods per second and divided by//! is the number of pulses detected in the specified time period; this number//! This function returns the current speed of the encoder.  The value returned//! Gets the current encoder speed.// Set the timer period.// Set the velocity predivider.//! before being saved and resetting the accumulator.//! capture.  The divided signal is accumulated over \e ui32Period system clock//! specified by \e ui32PreDiv before being accumulated by the velocity//! the quadrature encoder.  The position increment signal is predivided as//! This function configures the operation of the velocity capture portion of//! the velocity; must be non-zero.//! \param ui32Period specifies the number of clock ticks over which to measure//! \b QEI_VELDIV_32, \b QEI_VELDIV_64, or \b QEI_VELDIV_128.//! \b QEI_VELDIV_2, \b QEI_VELDIV_4, \b QEI_VELDIV_8, \b QEI_VELDIV_16,//! signal before it is counted; can be one of \b QEI_VELDIV_1,//! \param ui32PreDiv specifies the predivider applied to the input quadrature//! Configures the velocity capture.// Disable the velocity capture.//! encoder module.//! This function disables operation of the velocity capture in the quadrature//! Disables the velocity capture.// Enable the velocity capture.//! \sa QEIVelocityConfigure() and QEIEnable()//! encoder module.  The module must be configured before velocity capture is//! This function enables operation of the velocity capture in the quadrature//! Enables the velocity capture.// Set the input filter prescale count.//! quadrature encoder module.//! as specified by \e ui32FiltCnt before the input signals are sent to the//! This function configures the operation of the input filter prescale count.//! \b QEI_FILTCNT_15, \b QEI_FILTCNT_16 or \b QEI_FILTCNT_17//! \b QEI_FILTCNT_11, \b QEI_FILTCNT_12, \b QEI_FILTCNT_13, \b QEI_FILTCNT_14,//! \b QEI_FILTCNT_7, \b QEI_FILTCNT_8, \b QEI_FILTCNT_9, \b QEI_FILTCNT_10,//! \b QEI_FILTCNT_3, \b QEI_FILTCNT_4, \b QEI_FILTCNT_5, \b QEI_FILTCNT_6,//! signal before it is counted; can be one of \b QEI_FILTCNT_2,//! \param ui32FiltCnt specifies the filter count applied to the input quadrature//! Configures the input filter.// Disable the input filter.//! This function disables operation of the input filter in the quadrature//! Disables the input filter.// Enable the input filter.//! \sa QEIFilterConfigure() and QEIEnable()//! encoder module.  The module must be configured before input filter is//! This function enables operation of the input filter in the quadrature//! Enables the input filter.// Return the error indicator.//! \return Returns \b true if an error has occurred and \b false otherwise.//! the same time.//! is an error for both of the signals of the quadrature input to change at//! This function returns the error indicator for the quadrature encoder.  It//! Gets the encoder error indicator.// Return the direction of rotation.//! reverse direction.//! \return Returns 1 if moving in the forward direction or -1 if moving in the//! not be presently moving but this is the direction it last moved before it//! current means the most recently detected direction of the encoder; it may//! This function returns the current direction of rotation.  In this case,//! Gets the current direction of rotation.// Set the position counter.//! position is then measured relative to this value.//! This function sets the current position of the encoder; the encoder//! \param ui32Position is the new position for the encoder.//! Sets the current encoder position.// Return the current position counter.//! \return The current position of the encoder.//! counter is not yet aligned with the index pulse).//! index mode, if an index pulse has not been encountered, the position//! value may or may not contain the expected data (that is, if in reset on//! the configuration of the encoder, and the incident of an index pulse, this//! This function returns the current position of the encoder.  Depending upon//! Gets the current encoder position.// Set the maximum position.// Write the new configuration to the hardware.//! moving in the reverse (negative) direction.//! the value used to reset the position capture when in index reset mode and//! \e ui32MaxPosition is the maximum value of the position integrator and is//!   provided on ChA and ChB should be swapped before being processed.//! - \b QEI_CONFIG_NO_SWAP or \b QEI_CONFIG_SWAP to specify if the signals//!   signal and a clock are being provided instead.//!   quadrature signals are being provided on ChA and ChB, or if a direction//! - \b QEI_CONFIG_QUADRATURE or \b QEI_CONFIG_CLOCK_DIR specify if//!   position integrator should be reset when the index pulse is detected.//! - \b QEI_CONFIG_NO_RESET or \b QEI_CONFIG_RESET_IDX specify if the//!   position integrator and velocity accumulator.//!   on channel A or on both channels A and B should be counted by the//! - \b QEI_CONFIG_CAPTURE_A or \b QEI_CONFIG_CAPTURE_A_B specify if edges//! the logical OR of several values://! \e ui32Config parameter provides the configuration of the encoder and is//! This function configures the operation of the quadrature encoder.  The//! \param ui32MaxPosition specifies the maximum position value.//! below for a description of this parameter.//! \param ui32Config is the configuration for the quadrature encoder.  See//! Configures the quadrature encoder.// Disable the QEI module.//! This function disables operation of the quadrature encoder module.//! Disables the quadrature encoder.// Enable the QEI module.//! \sa QEIConfigure()//! module must be configured before it is enabled.//! This function enables operation of the quadrature encoder module.  The//! Enables the quadrature encoder.//! \addtogroup qei_api// qei.c - Driver for the Quadrature Encoder with Index./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/inc/hw_shamd5.hSHAMD5_DMAIC_CINSHAMD5_DMAIC_DINSHAMD5_DMAIC_COUTSHAMD5_DMAMIS_CINSHAMD5_DMAMIS_DINSHAMD5_DMAMIS_COUTSHAMD5_DMARIS_CINSHAMD5_DMARIS_DINSHAMD5_DMARIS_COUTSHAMD5_DMAIM_CINSHAMD5_DMAIM_DINSHAMD5_DMAIM_COUTSHAMD5_IRQENABLE_OUTPUT_READYSHAMD5_IRQENABLE_INPUT_READYSHAMD5_IRQENABLE_CONTEXT_READYSHAMD5_IRQSTATUS_OUTPUT_READYSHAMD5_IRQSTATUS_INPUT_READYSHAMD5_IRQSTATUS_CONTEXT_READYSHAMD5_SYSSTATUS_RESETDONESHAMD5_SYSCONFIG_SOFTRESETSHAMD5_SYSCONFIG_IT_ENSHAMD5_SYSCONFIG_DMA_ENSHAMD5_SYSCONFIG_SIDLE_FORCESHAMD5_SYSCONFIG_SIDLE_MSHAMD5_SYSCONFIG_SADVANCEDSHAMD5_REVISION_SSHAMD5_REVISION_MSHAMD5_DATA_15_IN_DATA_SSHAMD5_DATA_15_IN_DATA_MSHAMD5_DATA_14_IN_DATA_SSHAMD5_DATA_14_IN_DATA_MSHAMD5_DATA_13_IN_DATA_SSHAMD5_DATA_13_IN_DATA_MSHAMD5_DATA_12_IN_DATA_SSHAMD5_DATA_12_IN_DATA_MSHAMD5_DATA_11_IN_DATA_SSHAMD5_DATA_11_IN_DATA_MSHAMD5_DATA_10_IN_DATA_SSHAMD5_DATA_10_IN_DATA_MSHAMD5_DATA_9_IN_DATA_SSHAMD5_DATA_9_IN_DATA_MSHAMD5_DATA_8_IN_DATA_SSHAMD5_DATA_8_IN_DATA_MSHAMD5_DATA_7_IN_DATA_SSHAMD5_DATA_7_IN_DATA_MSHAMD5_DATA_6_IN_DATA_SSHAMD5_DATA_6_IN_DATA_MSHAMD5_DATA_5_IN_DATA_SSHAMD5_DATA_5_IN_DATA_MSHAMD5_DATA_4_IN_DATA_SSHAMD5_DATA_4_IN_DATA_MSHAMD5_DATA_3_IN_DATA_SSHAMD5_DATA_3_IN_DATA_MSHAMD5_DATA_2_IN_DATA_SSHAMD5_DATA_2_IN_DATA_MSHAMD5_DATA_1_IN_DATA_SSHAMD5_DATA_1_IN_DATA_MSHAMD5_DATA_0_IN_DATA_SSHAMD5_DATA_0_IN_DATA_MSHAMD5_LENGTH_SSHAMD5_LENGTH_MSHAMD5_MODE_ALGO_SHA256SHAMD5_MODE_ALGO_SHA224SHAMD5_MODE_ALGO_SHA1SHAMD5_MODE_ALGO_MD5SHAMD5_MODE_ALGO_MSHAMD5_MODE_ALGO_CONSTANTSHAMD5_MODE_CLOSE_HASHSHAMD5_MODE_HMAC_KEY_PROCSHAMD5_MODE_HMAC_OUTER_HASHSHAMD5_DIGEST_COUNT_SSHAMD5_DIGEST_COUNT_MSHAMD5_IDIGEST_H_DATA_SSHAMD5_IDIGEST_H_DATA_MSHAMD5_IDIGEST_G_DATA_SSHAMD5_IDIGEST_G_DATA_MSHAMD5_IDIGEST_F_DATA_SSHAMD5_IDIGEST_F_DATA_MSHAMD5_IDIGEST_E_DATA_SSHAMD5_IDIGEST_E_DATA_MSHAMD5_IDIGEST_D_DATA_SSHAMD5_IDIGEST_D_DATA_MSHAMD5_IDIGEST_C_DATA_SSHAMD5_IDIGEST_C_DATA_MSHAMD5_IDIGEST_B_DATA_SSHAMD5_IDIGEST_B_DATA_MSHAMD5_IDIGEST_A_DATA_SSHAMD5_IDIGEST_A_DATA_MSHAMD5_ODIGEST_H_DATA_SSHAMD5_ODIGEST_H_DATA_MSHAMD5_ODIGEST_G_DATA_SSHAMD5_ODIGEST_G_DATA_MSHAMD5_ODIGEST_F_DATA_SSHAMD5_ODIGEST_F_DATA_MSHAMD5_ODIGEST_E_DATA_SSHAMD5_ODIGEST_E_DATA_MSHAMD5_ODIGEST_D_DATA_SSHAMD5_ODIGEST_D_DATA_MSHAMD5_ODIGEST_C_DATA_SSHAMD5_ODIGEST_C_DATA_MSHAMD5_ODIGEST_B_DATA_SSHAMD5_ODIGEST_B_DATA_MSHAMD5_ODIGEST_A_DATA_SSHAMD5_ODIGEST_A_DATA_MSHAMD5_O_DMAIC0xFFFFC01CSHAMD5_O_DMAMIS0xFFFFC018SHAMD5_O_DMARIS0xFFFFC014SHAMD5_O_DMAIM0xFFFFC010SHAMD5_O_IRQENABLESHAMD5_O_IRQSTATUSSHAMD5_O_SYSSTATUSSHAMD5_O_SYSCONFIGSHAMD5_O_REVISIONSHAMD5_O_DATA_15_INSHAMD5_O_DATA_14_INSHAMD5_O_DATA_13_INSHAMD5_O_DATA_12_INSHAMD5_O_DATA_11_INSHAMD5_O_DATA_10_INSHAMD5_O_DATA_9_INSHAMD5_O_DATA_8_INSHAMD5_O_DATA_7_INSHAMD5_O_DATA_6_INSHAMD5_O_DATA_5_INSHAMD5_O_DATA_4_INSHAMD5_O_DATA_3_INSHAMD5_O_DATA_2_INSHAMD5_O_DATA_1_INSHAMD5_O_DATA_0_INSHAMD5_O_LENGTHSHAMD5_O_MODESHAMD5_O_DIGEST_COUNTSHAMD5_O_IDIGEST_HSHAMD5_O_IDIGEST_GSHAMD5_O_IDIGEST_FSHAMD5_O_IDIGEST_ESHAMD5_O_IDIGEST_DSHAMD5_O_IDIGEST_CSHAMD5_O_IDIGEST_BSHAMD5_O_IDIGEST_ASHAMD5_O_ODIGEST_HSHAMD5_O_ODIGEST_GSHAMD5_O_ODIGEST_FSHAMD5_O_ODIGEST_ESHAMD5_O_ODIGEST_DSHAMD5_O_ODIGEST_CSHAMD5_O_ODIGEST_BSHAMD5_O_ODIGEST_A__HW_SHAMD5_H__// __HW_SHAMD5_H__// The following are defines for the bit fields in the SHAMD5_O_DMAIC register.// The following are defines for the bit fields in the SHAMD5_O_DMAMIS// The following are defines for the bit fields in the SHAMD5_O_DMARIS// The following are defines for the bit fields in the SHAMD5_O_DMAIM register.// Mask for output ready interrupt// Mask for input ready interrupt// Mask for context ready interrupt// The following are defines for the bit fields in the SHAMD5_O_IRQENABLE// Context Ready Status// The following are defines for the bit fields in the SHAMD5_O_IRQSTATUS// Reset done status// The following are defines for the bit fields in the SHAMD5_O_SYSSTATUS// uDMA Request Enable// Advanced Mode Enable// The following are defines for the bit fields in the SHAMD5_O_SYSCONFIG// Revision Number// The following are defines for the bit fields in the SHAMD5_O_REVISION// Digest/Key Data// The following are defines for the bit fields in the SHAMD5_O_DATA_15_IN// The following are defines for the bit fields in the SHAMD5_O_DATA_14_IN// The following are defines for the bit fields in the SHAMD5_O_DATA_13_IN// The following are defines for the bit fields in the SHAMD5_O_DATA_12_IN// The following are defines for the bit fields in the SHAMD5_O_DATA_11_IN// The following are defines for the bit fields in the SHAMD5_O_DATA_10_IN// The following are defines for the bit fields in the SHAMD5_O_DATA_9_IN// The following are defines for the bit fields in the SHAMD5_O_DATA_8_IN// The following are defines for the bit fields in the SHAMD5_O_DATA_7_IN// The following are defines for the bit fields in the SHAMD5_O_DATA_6_IN// The following are defines for the bit fields in the SHAMD5_O_DATA_5_IN// The following are defines for the bit fields in the SHAMD5_O_DATA_4_IN// The following are defines for the bit fields in the SHAMD5_O_DATA_3_IN// The following are defines for the bit fields in the SHAMD5_O_DATA_2_IN// The following are defines for the bit fields in the SHAMD5_O_DATA_1_IN// The following are defines for the bit fields in the SHAMD5_O_DATA_0_IN// Block Length/Remaining Byte// The following are defines for the bit fields in the SHAMD5_O_LENGTH// SHA-256// SHA-224// SHA-1// MD5// Hash Algorithm// register will be reset to 0// and the initial digest count// selected algorithm when hashing// algorithm constants for the// be overwritten with the// The initial digest register will// MD5/SHA-1/SHA-2 specification// the end of the block, as per// Hash/HMAC will be 'closed' at// Performs the padding, the// HMAC Key Processing Enable// HMAC Outer Hash Processing// The following are defines for the bit fields in the SHAMD5_O_MODE register.// Digest Count// The following are defines for the bit fields in the SHAMD5_O_DIGEST_COUNT// The following are defines for the bit fields in the SHAMD5_O_IDIGEST_H// The following are defines for the bit fields in the SHAMD5_O_IDIGEST_G// The following are defines for the bit fields in the SHAMD5_O_IDIGEST_F// The following are defines for the bit fields in the SHAMD5_O_IDIGEST_E// The following are defines for the bit fields in the SHAMD5_O_IDIGEST_D// The following are defines for the bit fields in the SHAMD5_O_IDIGEST_C// The following are defines for the bit fields in the SHAMD5_O_IDIGEST_B// The following are defines for the bit fields in the SHAMD5_O_IDIGEST_A// The following are defines for the bit fields in the SHAMD5_O_ODIGEST_H// The following are defines for the bit fields in the SHAMD5_O_ODIGEST_G// The following are defines for the bit fields in the SHAMD5_O_ODIGEST_F// The following are defines for the bit fields in the SHAMD5_O_ODIGEST_E// The following are defines for the bit fields in the SHAMD5_O_ODIGEST_D// The following are defines for the bit fields in the SHAMD5_O_ODIGEST_C// The following are defines for the bit fields in the SHAMD5_O_ODIGEST_B// The following are defines for the bit fields in the SHAMD5_O_ODIGEST_A// SHA DMA Interrupt Clear// SHA DMA Masked Interrupt Status// SHA DMA Raw Interrupt Status// SHA DMA Interrupt Mask// SHA Interrupt Enable// SHA Interrupt Status// SHA System Status// SHA System Configuration// SHA Revision// SHA Data 15 Input// SHA Data 14 Input// SHA Data 13 Input// SHA Data 12 Input// SHA Data 11 Input// SHA Data 10 Input// SHA Data 9 Input// SHA Data 8 Input// SHA Data 7 Input// SHA Data 6 Input// SHA Data 5 Input// SHA Data 4 Input// SHA Data 3 Input// SHA Data 2 Input// SHA Data 1 Input// SHA Data 0 Input// SHA Length// SHA Mode// SHA Digest Count// SHA Inner Digest H// SHA Inner Digest G// SHA Inner Digest F// SHA Inner Digest E// SHA Inner Digest D// SHA Inner Digest C// SHA Inner Digest B// SHA Inner Digest A// SHA Outer Digest H// SHA Outer Digest G// SHA Outer Digest F// SHA Outer Digest E// SHA Outer Digest D// SHA Outer Digest C// SHA Outer Digest B// SHA Outer Digest A// The following are defines for the SHA/MD5 register offsets.// hw_shamd5.h - Macros used when accessing the SHA/MD5 hardware./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/shamd5.hSHAMD5_INT_DMA_CONTEXT_OUTSHAMD5_INT_DMA_DATA_INSHAMD5_INT_DMA_CONTEXT_INSHAMD5_INT_OUTPUT_READYSHAMD5_INT_INPUT_READYSHAMD5_INT_PARTHASH_READYSHAMD5_INT_CONTEXT_READYSHAMD5_ALGO_HMAC_SHA256SHAMD5_ALGO_HMAC_SHA224SHAMD5_ALGO_HMAC_SHA1SHAMD5_ALGO_HMAC_MD5SHAMD5_ALGO_SHA2560x0000001eSHAMD5_ALGO_SHA2240x0000001cSHAMD5_ALGO_SHA10x0000001aSHAMD5_ALGO_MD5__DRIVERLIB_SHAMD5_H__SHAMD5ResultReadSHAMD5ResetSHAMD5IntUnregisterSHAMD5IntStatusSHAMD5IntRegisterSHAMD5IntEnableSHAMD5IntDisableSHAMD5IntClearSHAMD5HMACProcessSHAMD5HMACPPKeySetSHAMD5HMACPPKeyGenerateSHAMD5HMACKeySetSHAMD5HashLengthSetSHAMD5DMAEnableSHAMD5DMADisableSHAMD5DataWriteNonBlockingSHAMD5DataWriteSHAMD5DataProcessSHAMD5ConfigSet// __DRIVERLIB_SHAMD5_H__// Function prototypes// SHAMD5BlockOnIntStatus() functions.// in SHAMD5IntEnable(), SHAMD5IntDisable(), SHAMD5GetIntStatus(), and// The following defines are used to represent the different interrupt sources// SHA/MD5 module.// The following defines are used to specify the algorithm in use in the// shamd5.h - Defines and Macros for the SHA/MD5.pui32DataSrcpui32HashResultpui32PPKey/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/shamd5.c"driverlib/shamd5.h""inc/hw_shamd5.h"ui32Base + SHAMD5_O_ODIGEST_A + ui32Idxui32Base + 0x00000000 + ui32Idxui32Base + SHAMD5_O_MODE(SHAMD5_MODE_HMAC_OUTER_HASH |
                                        SHAMD5_MODE_CLOSE_HASH)ui32Base + SHAMD5_O_DIGEST_COUNTui32Base == SHAMD5_BASE(SHAMD5_MODE_HMAC_OUTER_HASH |
                                        SHAMD5_MODE_HMAC_KEY_PROC |
                                        SHAMD5_MODE_CLOSE_HASH)ui32Base + SHAMD5_O_IRQSTATUSui32Base + 0x00000118280ui32Base + SHAMD5_O_ODIGEST_A + ui32Indexui32Base + 0x00000000 + ui32Indexui32Base + SHAMD5_O_LENGTH(ui32DataLength % 64) == 0_SHAMD5DataWriteMultipleui32Base + SHAMD5_O_DATA_0_IN + ui32Idxui32Base + 0x00000080 + ui32Idxui32Base + SHAMD5_O_IDIGEST_A + ui32Idxui32Base + 0x00000020 + ui32Idxui32Counterui32Base + SHAMD5_O_DATA_0_IN + ui32Counterui32Base + 0x00000080 + ui32Counter(ui32Mode == SHAMD5_ALGO_MD5) || (ui32Mode == SHAMD5_ALGO_SHA1) || (ui32Mode == SHAMD5_ALGO_SHA224) || (ui32Mode == SHAMD5_ALGO_SHA256) || (ui32Mode == SHAMD5_ALGO_HMAC_MD5) || (ui32Mode == SHAMD5_ALGO_HMAC_SHA1) || (ui32Mode == SHAMD5_ALGO_HMAC_SHA224) || (ui32Mode == SHAMD5_ALGO_HMAC_SHA256)ui32Base + SHAMD5_O_DMAICui32Base + 0xFFFFC01C4294950940(ui32IntFlags == SHAMD5_INT_CONTEXT_READY) || (ui32IntFlags == SHAMD5_INT_PARTHASH_READY) || (ui32IntFlags == SHAMD5_INT_INPUT_READY) || (ui32IntFlags == SHAMD5_INT_OUTPUT_READY)ui32Base + SHAMD5_O_DMAIMui32Base + 0xFFFFC0104294950928ui32Base + SHAMD5_O_IRQENABLEui32Base + 0x0000011C284ui32Base + SHAMD5_O_SYSCONFIG~SHAMD5_SYSCONFIG_IT_ENui32Base + SHAMD5_O_DMAMISui32Base + 0xFFFFC018ui32Base + SHAMD5_O_DMARISui32Base + 0xFFFFC01442949509364294950932(SHAMD5_SYSCONFIG_SADVANCED | SHAMD5_SYSCONFIG_DMA_EN)4294967159~(SHAMD5_SYSCONFIG_SADVANCED | SHAMD5_SYSCONFIG_DMA_EN)ui32Base + SHAMD5_O_SYSSTATUSui32Base + 0x000001142764294967247~SHAMD5_SYSCONFIG_SIDLE_M// Write the digest count to 64 to account for the preprocessed key.// Configure the SHA engine to continue the HMAC.// Write the key to the digest registers.//! whether the context is ready before writing the key.//! \note It is recommended to use the SHAMD5IntStatus() function to check//! less than 512 bytes, then it must be padded with zeros.//! key preprocessing.  The size of pui32Src must be 512 bytes.  If the key is//! This function is used to write HMAC key to the digest registers for//! \param pui32Src is the pointer to the 16-word array of the HMAC key.//! \param ui32Base is the base address of the SHA/MD5 module.//! Writes a pre-processed HMAC key to the digest registers in the SHA/MD5// Configure the SHA engine for HMAC operation.//! Writes an HMAC key to the digest registers in the SHA/MD5 module.// Read the pre-processed key from the SHA/MD5 module.// Wait for key to be processed.// Set the length to zero to start the HMAC key pre-processing.// Set the flag to cause the HMAC key to be pre-processed.// Write the HMAC key.// Wait for the context to be ready before writing the mode.//! each be 16 words (512 bits) long.//! than 512 bits, it must be padded with zeros.  The \e pui32PPKey array must//! The \e pui32Key array must be 16 words (512 bits) long.  If the key is less//! processing time.//! pre-processed key can then be used with later HMAC operations to speed//! This function processes an HMAC key using the SHA/MD5.  The resultant//! pre-processed key.//! \param pui32PPKey is the pointer to the array that contains the//! processed.//! \param pui32Key is a pointer to an array that contains the key to be//! Process an HMAC key using the SHA/MD5 module.// Read the result.// Wait for the output to be ready.// Write the data in the registers.// Write the length.//! -----------------------------------------//! | SHA-256   | 8 Words (256 bits)        |//! | SHA-224   | 7 Words (224 bits)        |//! | SHA-1     | 5 Words (160 bits)        |//! | MD5       | 4 Words (128 bits)        |//! | Algorithm | Number of Words in Result |//! correct array size for each algorithm://! selected with the \e ui32Algo argument.  The following table shows the//! The length of the hash result is dependent on the algorithm that is//! module with a preprocessed key.//! This function computes a HMAC with the given data using the SHA/MD5//! of the hashing operation.//! \param pui32HashResult is a pointer to an array that holds the result//! \param ui32DataLength specifies the length of the data to be hashed in//! data that is to be hashed.//! \param pui32DataSrc is a pointer to an array of data that contains the//! Compute a HMAC with key pre-processing using the SHA/MD5 module.//! The following table shows the correct array size for each algorithm://! The length of the hash result is dependent on the algorithm that is in use.//! This function computes the hash of an array of data using the SHA/MD5//! data that will be hashed.//! Compute a hash using the SHA/MD5 module.// Write the word into the data register.// Loop through the remaining words.// Wait until the engine has finished processing the previous block.// write them separately.// If there are bytes that do not make up a whole block, then// Calculate the remaining bytes of data that don't make up a full block.// Increment the pointer to next block of data.// Write the block of data.// next 16 words.// making sure to block additional operations until we can write the// Loop through all the blocks and write them into the data registers// Calculate the number of blocks of data.//! to process data.//! \note This function is used by SHAMD5DataProcess() and SHAMD5HMACProcess()//! multiple of 4 to fall on a word boundry.//! before another is written.  The \e ui32DataLength parameter must be a//! registers.  The function waits for each block of data to be processed//! This function writes a variable number of words into the SHA/MD5 data//! \param ui32DataLength is the length of the data to be written in bytes.//! \param pui32DataSrc is a pointer to an array of data to be written.//! Writes multiple words of data into the SHA/MD5 data registers.// Read the hash result.// misconfigured.// Return without reading a result since the hardware appears to be// The hash type is not recognized.// Done.// There are 32 bytes in the SHA-256 hash.// The SHA-256 hash is being used.// There are 28 bytes in the SHA-224 hash.// The SHA-224 hash is being used.// There are 20 bytes in the SHA-1 hash.// The SHA-1 hash is being used.// There are 16 bytes in the MD5 hash.// The MD5 hash is being used.// Determine the number of bytes in the result, based on the hash type.//! the data has been written.//! This function does not return until the module is ready to accept data and//! \param pui32Dest is the pointer to the 16-word array of data that will be//! Reads the result of a hashing operation.// Write the 16 words of data.// Wait for the module to be ready to accept data.//! \param pui32Src is the pointer to the 16-word array of data that will be//! Perform a blocking write of 16 words of data to the SHA/MD5 module.// Return true as a sign of successfully completing the function.// Check that the SHA/MD5 module is ready for data.  If not, return false.//! It returns false if the module was not ready.//! \return This function returns true if the write completed successfully.//! of whether or not the module is ready to accept the data.//! This function writes 16 words of data into the data register regardless//! Perform a non-blocking write of 16 words of data to the SHA/MD5 module.// Write the value in the MODE register.//! - \b SHAMD5_ALGO_HMAC_SHA256 - HMAC with SHA-256//! - \b SHAMD5_ALGO_HMAC_SHA224 - HMAC with SHA-224//! - \b SHAMD5_ALGO_HMAC_SHA1 - HMAC with SHA-1//! - \b SHAMD5_ALGO_HMAC_MD5 - HMAC with MD5//! - \b SHAMD5_ALGO_SHA256 - Regular hash with SHA-256//! - \b SHAMD5_ALGO_SHA224 - Regular hash with SHA-224//! - \b SHAMD5_ALGO_SHA1 - Regular hash with SHA-1//! - \b SHAMD5_ALGO_MD5 - Regular hash with MD5//! The ui32Mode parameter is a bit-wise OR of values://! This function writes the mode register configuring the SHA/MD5 module.//! \param ui32Mode is the mode of the SHA/MD5 module.//! Writes the mode in the SHA/MD5 module.// Set the LENGTH register and start processing.//! \note When this register is written, hash processing is triggered.//! hash is not set in the mode register.//! to the SHA/MD5 module.  The value must be a multiple of 64 if the close//! This function writes the length of the hash data of the current operation//! \param ui32Length is the hash length in bytes.//! Write the hash length to the SHA/MD5 module.//! Unregisters an interrupt handler for the SHA/MD5 module.//! Instead, IntEnable() should be used to enable SHA/MD5 interrupts on the//! the source of the interrupt using SHAMD5IntClear().//! SHAMD5IntEnable().  The interrupt handler being registered must clear//! specific SHA/MD5 interrupt sources must be enabled using//! table, and enables SHA/MD5 interrupts on the interrupt controller;//! enabled SHA/MD5 interrupts occur.//! Registers an interrupt handler for the SHA/MD5 module.// Clear the corresponding flags disabling the interrupt sources.//! - \b SHAMD5_INT_OUTPUT_READY - Context output registers are ready.//! - \b SHAMD5_INT_INPUT_READY - Data FIFO is ready to receive data.//!   a context switch.//! - \b SHAMD5_INT_PARTHASH_READY - Context output registers are ready after//! - \b SHAMD5_INT_CONTEXT_READY - Context input registers are ready.//! \e ui32IntFlags must be a logical OR of one or more of the following//! \param ui32IntFlags contains desired interrupts to disable.//! Clears interrupt sources in the SHA/MD5 module.// If there are no interrupts enabled, then disable all interrupts.//! Disable interrupt sources in the SHA/MD5 module.// Enable all interrupts.// Enable the interrupt sources.//! ui32IntFlags must be a logical OR of one or more of the following//! This function enables interrupt sources in the SHA/MD5 module.//! \param ui32IntFlags contains desired interrupts to enable.//! Enable interrupt sources in the SHA/MD5 module.// Return the value of the IRQSTATUS register.//! \return Interrupt status//! value will be a logical OR of the following://! This function returns the current value of the IRQSTATUS register.  The//! Get the interrupt status of the SHA/MD5 module.// Write the new configuration into the register.//! This function configures the DMA options of the SHA/MD5 module.//! Disables the uDMA requests in the SHA/MD5 module.//! Enables the uDMA requests in the SHA/MD5 module.// Force idle mode.// Set the soft-reset bit.//! SYSCONFIG register.//! This function performs a soft-reset of the SHA/MD5 module using the//! Resets the SHA/MD5 module.//! \addtogroup shamd5_api// shamd5.c - Driver for the SHA/MD5 module./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/inc/hw_ssi.hSSI_CC_CS_PIOSCSSI_CC_CS_SYSPLLSSI_CC_CS_MSSI_PP_HSCLKSSI_PP_MODE_ADVBIQUADSSI_PP_MODE_ADVBISSI_PP_MODE_LEGACYSSI_PP_MODE_MSSI_PP_FSSHLDFRMSSI_DMACTL_RXDMAESSI_DMACTL_TXDMAESSI_ICR_RORICSSI_ICR_RTICSSI_ICR_DMARXICSSI_ICR_DMATXICSSI_ICR_EOTICSSI_MIS_RORMISSSI_MIS_RTMISSSI_MIS_RXMISSSI_MIS_TXMISSSI_MIS_DMARXMISSSI_MIS_DMATXMISSSI_MIS_EOTMISSSI_RIS_RORRISSSI_RIS_RTRISSSI_RIS_RXRISSSI_RIS_TXRISSSI_RIS_DMARXRISSSI_RIS_DMATXRISSSI_RIS_EOTRISSSI_IM_RORIMSSI_IM_RTIMSSI_IM_RXIMSSI_IM_TXIMSSI_IM_DMARXIMSSI_IM_DMATXIMSSI_IM_EOTIMSSI_CPSR_CPSDVSR_SSSI_CPSR_CPSDVSR_MSSI_SR_TFESSI_SR_TNFSSI_SR_RNESSI_SR_RFFSSI_SR_BSYSSI_DR_DATA_SSSI_DR_DATA_MSSI_CR1_LBMSSI_CR1_SSESSI_CR1_MSSSI_CR1_EOTSSI_CR1_MODE_ADVANCEDSSI_CR1_MODE_QUADSSI_CR1_MODE_BISSI_CR1_MODE_LEGACYSSI_CR1_MODE_MSSI_CR1_DIRSSI_CR1_HSCLKENSSI_CR1_FSSHLDFRMSSI_CR1_EOMSSI_CR0_SCR_SSSI_CR0_DSS_16SSI_CR0_DSS_15SSI_CR0_DSS_14SSI_CR0_DSS_13SSI_CR0_DSS_12SSI_CR0_DSS_11SSI_CR0_DSS_10SSI_CR0_DSS_9SSI_CR0_DSS_8SSI_CR0_DSS_7SSI_CR0_DSS_6SSI_CR0_DSS_5SSI_CR0_DSS_4SSI_CR0_DSS_MSSI_CR0_FRF_NMWSSI_CR0_FRF_TISSI_CR0_FRF_MOTOSSI_CR0_FRF_MSSI_CR0_SPOSSI_CR0_SPHSSI_CR0_SCR_MSSI_O_CCSSI_O_PPSSI_O_DMACTLSSI_O_ICRSSI_O_MISSSI_O_RISSSI_O_IMSSI_O_CPSRSSI_O_SRSSI_O_DRSSI_O_CR1SSI_O_CR0__HW_SSI_H__// __HW_SSI_H__// source and divisor factor)// System clock (based on clock// SSI Baud Clock Source// The following are defines for the bit fields in the SSI_O_CC register.// High Speed Capability// Bi-SSI and Quad-SSI mode enabled// Legacy mode, Advanced mode,// and Bi-SSI mode enabled// Legacy mode, Advanced SSI mode// Legacy SSI mode// Mode of Operation// FSS Hold Frame Capability// The following are defines for the bit fields in the SSI_O_PP register.// Receive DMA Enable// Transmit DMA Enable// The following are defines for the bit fields in the SSI_O_DMACTL register.// SSI Receive Overrun Interrupt// SSI Receive Time-Out Interrupt// SSI Receive DMA Interrupt Clear// SSI Transmit DMA Interrupt Clear// End of Transmit Interrupt Clear// The following are defines for the bit fields in the SSI_O_ICR register.// SSI Receive Overrun Masked// SSI Receive Time-Out Masked// SSI Receive FIFO Masked// SSI Transmit FIFO Masked// SSI Receive DMA Masked Interrupt// SSI Transmit DMA Masked// End of Transmit Masked Interrupt// The following are defines for the bit fields in the SSI_O_MIS register.// SSI Receive Overrun Raw// SSI Receive Time-Out Raw// SSI Receive FIFO Raw Interrupt// SSI Transmit FIFO Raw Interrupt// SSI Receive DMA Raw Interrupt// SSI Transmit DMA Raw Interrupt// End of Transmit Raw Interrupt// The following are defines for the bit fields in the SSI_O_RIS register.// SSI Receive FIFO Interrupt Mask// SSI Transmit FIFO Interrupt Mask// SSI Receive DMA Interrupt Mask// SSI Transmit DMA Interrupt Mask// End of Transmit Interrupt Mask// The following are defines for the bit fields in the SSI_O_IM register.// SSI Clock Prescale Divisor// The following are defines for the bit fields in the SSI_O_CPSR register.// SSI Transmit FIFO Empty// SSI Transmit FIFO Not Full// SSI Receive FIFO Not Empty// SSI Receive FIFO Full// SSI Busy Bit// The following are defines for the bit fields in the SSI_O_SR register.// SSI Receive/Transmit Data// The following are defines for the bit fields in the SSI_O_DR register.// SSI Loopback Mode// SSI Synchronous Serial Port// SSI Master/Slave Select// End of Transmission// packet size// Advanced SSI Mode with 8-bit// Quad-SSI Mode// Bi-SSI mode// SSI Mode// SSI Direction of Operation// High Speed Clock Enable// FSS Hold Frame// Stop Frame (End of Message)// The following are defines for the bit fields in the SSI_O_CR1 register.// 16-bit data// 15-bit data// 14-bit data// 13-bit data// 12-bit data// 11-bit data// 10-bit data// 9-bit data// 8-bit data// 7-bit data// 6-bit data// 5-bit data// 4-bit data// SSI Data Size Select// MICROWIRE Frame Format// Synchronous Serial Frame Format// Freescale SPI Frame Format// SSI Frame Format Select// SSI Serial Clock Polarity// SSI Serial Clock Phase// SSI Serial Clock Rate// The following are defines for the bit fields in the SSI_O_CR0 register.// SSI Clock Configuration// SSI Peripheral Properties// SSI DMA Control// SSI Interrupt Clear// SSI Masked Interrupt Status// SSI Raw Interrupt Status// SSI Interrupt Mask// SSI Clock Prescale// SSI Status// SSI Data// SSI Control 1// SSI Control 0// The following are defines for the SSI register offsets.// hw_ssi.h - Macros used when accessing the SSI hardware./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/ssi.hSSI_ADV_MODE_QUAD_WRITESSI_ADV_MODE_QUAD_READSSI_ADV_MODE_BI_WRITESSI_ADV_MODE_BI_READSSI_ADV_MODE_WRITE0x000000c0SSI_ADV_MODE_READ_WRITE0x000001c0SSI_ADV_MODE_LEGACYSSI_CLOCK_PIOSCSSI_CLOCK_SYSTEMSSI_DMA_RXSSI_DMA_TXSSI_MODE_SLAVE_ODSSI_MODE_SLAVESSI_MODE_MASTERSSI_FRF_NMWSSI_FRF_TISSI_FRF_MOTO_MODE_3SSI_FRF_MOTO_MODE_2SSI_FRF_MOTO_MODE_1SSI_FRF_MOTO_MODE_0SSI_RXORSSI_RXTOSSI_RXFFSSI_TXFFSSI_DMARXSSI_DMATXSSI_TXEOT__DRIVERLIB_SSI_H__SSILoopbackDisableSSILoopbackEnableSSIAdvFrameHoldDisableSSIAdvFrameHoldEnableSSIAdvDataPutFrameEndNonBlockingSSIAdvDataPutFrameEndSSIAdvModeSetSSIClockSourceGetSSIClockSourceSetSSIBusySSIDMADisableSSIDMAEnableSSIIntUnregisterSSIIntStatusSSIIntRegisterSSIIntEnableSSIIntDisableSSIIntClearSSIEnableSSIDisableSSIDataPutNonBlockingSSIDataPutSSIDataGetNonBlockingSSIDataGetSSIConfigSetExpClk// __DRIVERLIB_SSI_H__// Values that can be passed to SSIAdvModeSet().// SSIClockSourceGet().// Values that can be passed to SSIClockSourceSet() or returned from// Enable DMA for receive// Enable DMA for transmit// Values that can be passed to SSIDMAEnable() and SSIDMADisable().// SSI slave with output disabled// SSI slave// SSI master// National MicroWire frame format// TI frame format// Moto fmt, polarity 1, phase 1// Moto fmt, polarity 1, phase 0// Moto fmt, polarity 0, phase 1// Moto fmt, polarity 0, phase 0// Values that can be passed to SSIConfigSetExpClk.// RX overrun// RX timeout// RX FIFO half full or more// TX FIFO half full or less// DMA Receive complete// DMA Transmit complete// Transmit FIFO is empty// as the ui32IntFlags parameter, and returned by SSIIntStatus.// Values that can be passed to SSIIntEnable, SSIIntDisable, and SSIIntClear// ssi.h - Prototypes for the Synchronous Serial Interface Driver.ui32Sourceui32SSIClkui32Protocolui32DataWidth/home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/ssi.c"driverlib/ssi.h""inc/hw_ssi.h"ui32Base + SSI_O_CR11u(1u)~(1u)_SSIBaseValid(ui32Base)(SSI_CR1_FSSHLDFRM)4294966271~(SSI_CR1_FSSHLDFRM)ui32Base + SSI_O_SRui32Base + SSI_O_DR(ui32Data & 0xffffff00) == 0(SSI_CR1_DIR | SSI_CR1_MODE_M)~(SSI_CR1_DIR | SSI_CR1_MODE_M)(ui32Mode == SSI_ADV_MODE_LEGACY) || (ui32Mode == SSI_ADV_MODE_WRITE) || (ui32Mode == SSI_ADV_MODE_READ_WRITE) || (ui32Mode == SSI_ADV_MODE_BI_READ) || (ui32Mode == SSI_ADV_MODE_BI_WRITE) || (ui32Mode == SSI_ADV_MODE_QUAD_READ) || (ui32Mode == SSI_ADV_MODE_QUAD_WRITE)ui32Base + SSI_O_CC(ui32Source == SSI_CLOCK_SYSTEM) || (ui32Source == SSI_CLOCK_PIOSC)ui32Base + SSI_O_DMACTL(ui32Data & (0xfffffffe << (HWREG(ui32Base + SSI_O_CR0) & SSI_CR0_DSS_M))) == 0ui32Base + SSI_O_ICRui32Base + SSI_O_MISui32Base + SSI_O_RISui32Base + SSI_O_IM(SSI_CR1_SSE)~(SSI_CR1_SSE)ui32MaxBitRateui32RegValui32SCRui32SPH_SPOui32Base + SSI_O_CPSRui32Base + SSI_O_CR0(ui32Protocol == SSI_FRF_MOTO_MODE_0) || (ui32Protocol == SSI_FRF_MOTO_MODE_1) || (ui32Protocol == SSI_FRF_MOTO_MODE_2) || (ui32Protocol == SSI_FRF_MOTO_MODE_3) || (ui32Protocol == SSI_FRF_TI) || (ui32Protocol == SSI_FRF_NMW)(ui32Mode == SSI_MODE_MASTER) || (ui32Mode == SSI_MODE_SLAVE)((ui32Mode == SSI_MODE_MASTER) && (ui32BitRate <= (ui32SSIClk / 2))) || ((ui32Mode != SSI_MODE_MASTER) && (ui32BitRate <= (ui32SSIClk / 12)))(ui32SSIClk / ui32BitRate) <= (254 * 256)(ui32DataWidth >= 4) && (ui32DataWidth <= 16)_SSIIntNumberGetui8Idxui8Rowsppui32SSIIntMapconst uint32_t[4][2]unsigned long[4][2]const uint_fast8_tg_ui8SSIIntMapRowsg_ui8SSIIntMapSnowflakeRowssizeof(g_ppui32SSIIntMapSnowflake)sizeof(g_ppui32SSIIntMapSnowflake[0])sizeof(g_ppui32SSIIntMapSnowflake) / sizeof(g_ppui32SSIIntMapSnowflake[0])g_ppui32SSIIntMapSnowflake1073774592SSI0_BASE1073778688SSI1_BASE1073782784SSI2_BASE1073786880SSI3_BASEsizeof(g_ppui32SSIIntMap)sizeof(g_ppui32SSIIntMap[0])sizeof(g_ppui32SSIIntMap) / sizeof(g_ppui32SSIIntMap[0])g_ppui32SSIIntMap// Disable Loopback mode//! connected internally to the output of the transmit serial shift register.//! where the the input of the receive serial shift register is no longer//! This function restores the SSI module to be in normal serial port operation//! \param ui32Base is the base address of the SSI module.//! Disables the use of SSI Loopback mode.// Enable Loopback mode//! This mode is useful for diagnostic/debug testing of the SSI module.//! connected internally to the input of the receive serial shift register.//! loopback mode, the output of the transmit serial shift register is//! This function configures the SSI module to enter loopback mode.  When in//! Enables the use of SSI Loopback mode.// Clear the hold frame bit.//! part in use to determine whether this support is available.//! the Tiva part and SSI in use.  Please consult the data sheet for the//! \note The availability of the advanced mode of SSI operation varies with//! This mode is the default operation.//! advanced modes (instead of leaving it asserted for the entire transfer).//! for one SSI clock cycle after every byte is transferred using one of the//! This function configures the SSI module to de-assert the SSIFss signal//! byte transfer.//! Configures the SSI advanced mode to de-assert the SSIFss signal after every // Set the hold frame bit.//! SSIAdvDataPutFrameEndNonBlocking().//! mode, SSIFss can be directly controlled via SSIAdvDataPutFrameEnd() and//! (instead of briefly de-asserting it after every byte).  When using this//! during the entire data transfer when using one of the advanced modes//! transfer.//! Configures the SSI advanced mode to hold the SSIFss signal during the full// Check for space to write.//! \return Returns the number of elements written to the SSI transmit FIFO.//! \note The upper 24 bits of \e ui32Data are discarded by the hardware.//! SSI clock.  If there is no space in the FIFO, then this function returns a//! transmitted by the SSI module, the FSS signal de-asserts for at least one//! specified SSI module, marking it as the end of a frame.  After this byte is//! This function places the supplied data into the transmit FIFO of the//! \param ui32Data is the data to be transmitted over the SSI interface.//! \param ui32Base specifies the SSI module base address.//! Puts a data element into the SSI transmit FIFO as the end of a frame.// Write the data to the SSI.//! SSI module, the FSS signal de-asserts for at least one SSI clock.//! space available before returning.  After this byte is transmitted by the//! space available in the transmit FIFO, this function waits until there is//! specified SSI module, marking it as the end of a frame.  If there is no// Set the SSI mode of operation.//! empty.//! Switching into and out of legacy mode should only occur when the FIFO is//! handled using the advanced mode of operation in effect when that data was//! written into the FIFO; the data that is already present in the FIFO is//! The advanced mode operation that is selected applies only to data newly//! configured for eight data bits and the \b SSI_FRF_MOTO_MODE_0 protocol.//! When using an advanced mode of operation, the SSI module must have been//! +----------+------+-----+----------+-------+--------+---------+----------+//! |Quad write|      | yes |   yes    |       |        |   yes   |   yes    |//! |Quad read |      | yes |   yes    |       |        |   yes   |   yes    |//! |Bi write  |      | yes |   yes    |  yes  |  yes   |         |          |//! |Bi Read   |      | yes |   yes    |  yes  |  yes   |         |          |//! |Read/Write| yes  | yes |   yes    |  yes  |  yes   |   yes   |   yes    |//! |Write     | yes  | yes |   yes    |  yes  |  yes   |   yes   |   yes    |//! |Legacy    | yes  | yes |   yes    |       |        |         |          |//! |          |Legacy|Write|Read Write|Bi Read|Bi Write|Quad Read|Quad Write|//! |FROM      |                             TO                              |//! +----------+-------------------------------------------------------------+//! undefined results)://! The following mode transitions are valid (other transitions produce//!   every SSI clock.//!   written to the slave in Quad-SPI mode, with four bits of data written on//! - \b SSI_ADV_MODE_QUAD_WRITE - The advanced mode of operation where data is//!   read from the slave in Quad-SPI mode, with four bits of data read on//! - \b SSI_ADV_MODE_QUAD_READ - The advanced mode of operation where data is//!   written to the slave in Bi-SPI mode, with two bits of data written on//! - \b SSI_ADV_MODE_BI_WRITE - The advanced mode of operation where data is//!   SSI clock.//!   read from the slave in Bi-SPI mode, with two bits of data read on every//! - \b SSI_ADV_MODE_BI_READ - The advanced mode of operation where data is//!   operation.//!   \b SSI_ADV_MODE_LEGACY but allows transitions to Bi- or Quad-SPI//!   written to and read from the slave; this mode is the same as//! - \b SSI_ADV_MODE_READ_WRITE - The advanced mode of operation where data is//!   away (instead of being placed into the SSI Rx FIFO).//!   written to the slave; any data clocked in via the \b SSIRx pin is thrown//! - \b SSI_ADV_MODE_WRITE - The advanced mode of operation where data is only//!   This mode is the default.//!   is selected, it is not valid to switch to Bi- or Quad-SPI operation.//!   resulting in legacy, or backwards-compatible, operation.  When this mode//! - \b SSI_ADV_MODE_LEGACY - Disables the advanced modes of operation,//! the following modes can be selected://! needed when using the advanced operation modes (Bi- or Quad-SPI).  One of//! This function selects the mode of operation for the SSI module, which is//! \param ui32Mode is the mode of operation to use.//! Selects the advanced mode of operation for the SSI module.// Return the SSI clock source.//! \b SSI_CLOCK_SYSTEM or \b SSI_CLOCK_PIOSC.//! \return Returns the current clock source, which is either//! in use to determine whether this support is available.//! Tiva part and SSI in use.  Please consult the data sheet for the part//! \note The ability to specify the SSI data clock source varies with the//! This function returns the data clock source for the specified SSI.//! Gets the data clock source for the specified SSI peripheral.// Set the SSI clock source.//! \note The ability to specify the SSI baud clock source varies with the//! the SSI clock source.//! SSI.  Therefore, the data rate should be reconfigured after any change to//! Changing the baud clock source changes the data rate generated by the//! the precision internal oscillator (\b SSI_CLOCK_PIOSC).//! The possible clock source are the system clock (\b SSI_CLOCK_SYSTEM) or//! This function allows the baud clock source for the SSI to be selected.//! \param ui32Source is the baud clock source for the SSI.//! Sets the data clock source for the specified SSI peripheral.// Determine if the SSI is busy.//! transmissions are complete.//! \return Returns \b true if the SSI is transmitting or \b false if all//! the hardware shift register.//! transmit FIFO is empty and all bits of the last transmitted word have left//! have cleared the transmitter hardware.  If \b false is returned, then the//! This function allows the caller to determine whether all transmitted bytes//! Determines whether the SSI transmitter is busy or not.// Clear the requested bits in the SSI DMA control register.//! - SSI_DMA_TX - disable DMA for transmit//! - SSI_DMA_RX - disable DMA for receive//! \e ui32DMAFlags parameter is the logical OR of any of the following values://! by SSIDMAEnable().  The specified SSI DMA features are disabled.  The//! This function is used to disable SSI DMA features that were enabled//! Disables SSI DMA operation.// Set the requested bits in the SSI DMA control register.//! with the SSI.//! \note The uDMA controller must also be set up before DMA can be used//! - SSI_DMA_TX - enable DMA for transmit//! - SSI_DMA_RX - enable DMA for receive//! The \e ui32DMAFlags parameter is the logical OR of any of the following//! configured to use DMA for transmit and/or receive data transfers.//! This function enables the specified SSI DMA features.  The SSI can be//! Enables SSI DMA operation.// Check for data to read.//! \return Returns 1 if there is data element read or 0 if no data in FIFO//! \e pui32Data contain valid data.//! 8-bit data width, only the lower 8 bits of the value written to//! SSIConfigSetExpClk().  For example, if the interface is configured for//! valid data, where N is the data width as configured by//! \note Only the lower N bits of the value written to \e pui32Data contain//! function returns a zero.//! the \e ui32Data parameter.  If there is no data in the FIFO, then this //! specified SSI module and places that data into the location specified by //! This function gets one received data element from the receive FIFO of the //! received over the SSI interface.//! \param pui32Data is a pointer to a storage location for data that was//! Gets a data element from the SSI receive FIFO.// Read data from SSI.// Wait until there is data to be read.//! until data is received before returning.//! \e pui32Data parameter.  If there is no data available, this function waits//! SSI module and places that data into the location specified by the//! This function gets received data from the receive FIFO of the specified//! bits of \e ui32Data are discarded.//! example, if the interface is configured for 8-bit data width, the upper 24//! where N is the data width as configured by SSIConfigSetExpClk().  For//! \note The upper 32 - N bits of \e ui32Data are discarded by the hardware,//! returns a zero.//! specified SSI module.  If there is no space in the FIFO, then this function//! Puts a data element into the SSI transmit FIFO.//! this function waits until there is space available before returning.//! specified SSI module.  If there is no space available in the transmit FIFO,//! \b SSI_RXOR values.//! \e ui32IntFlags parameter can consist of either or both the \b SSI_RXTO and//! This function clears the specified SSI interrupt sources so that they no//! Clears SSI interrupt sources.//! \b SSI_TXFF, \b SSI_RXFF, \b SSI_RXTO, and \b SSI_RXOR.//! raw interrupt status or the status of interrupts that are allowed to//! This function returns the interrupt status for the SSI module.  Either the//!  \b SSI_RXTO, or \b SSI_RXOR values.//! \e ui32IntFlags parameter can be any of the \b SSI_TXFF, \b SSI_RXFF,//! This function disables the indicated SSI interrupt sources.  The//! Disables individual SSI interrupt sources.//! parameter can be any of the \b SSI_TXFF, \b SSI_RXFF, \b SSI_RXTO, or//! This function enables the indicated SSI interrupt sources.  Only the//! Enables individual SSI interrupt sources.// Determine the interrupt number based on the SSI module.//! This function clears the handler to be called when an SSI interrupt//! Unregisters an interrupt handler for the synchronous serial interface.// Enable the synchronous serial interface interrupt.//! interrupt source via SSIIntClear().//! controller; specific SSI interrupts must be enabled via SSIIntEnable().  If//! This function registers the handler to be called when an SSI interrupt//! synchronous serial interface interrupt occurs.//! Registers an interrupt handler for the synchronous serial interface.// Read-modify-write the enable bit.//! This function disables operation of the synchronous serial interface.//! Disables the synchronous serial interface.//! synchronous serial interface must be configured before it is enabled.//! This function enables operation of the synchronous serial interface.  The//! Enables the synchronous serial interface.// Set protocol and clock rate.// Set the clock predivider.// Set the mode.//! can be a value between 4 and 16, inclusive.//! The \e ui32DataWidth parameter defines the width of the data transfers and//! Generation section of the SSI chapter in the data sheet.//! that there are frequency limits for FSSI that are described in the Bit Rate//! where FSSI is the frequency of the clock supplied to the SSI module. Note//! - FSSI >= 12 * bit rate (slave modes)//! - FSSI >= 2 * bit rate (master mode)//! rate must satisfy the following clock ratio criteria://! The \e ui32BitRate parameter defines the bit rate for the SSI.  This bit//! \b SSI_MODE_MASTER, \b SSI_MODE_SLAVE, or \b SSI_MODE_SLAVE_OD.//! \e ui32Mode parameter can be one of the following values://! can be configured to disable output on its serial output line.  The//! The SSI module can operate as a master or slave; if it is a slave, the SSI//! The \e ui32Mode parameter defines the operating mode of the SSI module.//! </pre>//!   1       1   SSI_FRF_MOTO_MODE_3//!   1       0   SSI_FRF_MOTO_MODE_2//!   0       1   SSI_FRF_MOTO_MODE_1//!   0       0   SSI_FRF_MOTO_MODE_0//! Polarity Phase       Mode//! <pre>//! polarity and phase configurations://! a particular device.  The Motorola  frame formats encode the following//! device data sheet to determine if the Microwire format is supported on //! the \b SSI_FRF_NMW option is only available on some devices. Refer to the//! \b SSI_FRF_MOTO_MODE_3, \b SSI_FRF_TI, or \b SSI_FRF_NMW. Note that //! \b SSI_FRF_MOTO_MODE_0, \b SSI_FRF_MOTO_MODE_1, \b SSI_FRF_MOTO_MODE_2,//! \e ui32Protocol parameter can be one of the following values://! The \e ui32Protocol parameter defines the data frame format.  The//! the SSI protocol, mode of operation, bit rate, and data width.//! This function configures the synchronous serial interface.  It sets//! \param ui32DataWidth specifies number of bits transferred per frame.//! \param ui32BitRate specifies the clock rate.//! \param ui32Mode specifies the mode of operation.//! \param ui32Protocol specifies the data transfer protocol.//! \param ui32SSIClk is the rate of the clock supplied to the SSI module.//! Configures the synchronous serial interface.// Loop through the table that maps SSI base addresses to interrupt//! \return Returns an SSI interrupt number, or 0 if the interrupt does not//! This function returns the interrupt number for the SSI module with the base//! Returns the interrupt number of SSI module .//! This function determines if a SSI module base address is valid.//! Checks an SSI base address.// A mapping of timer base address to interrupt number.//! \addtogroup ssi_api// ssi.c - Driver for Synchronous Serial Interface./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/sw_crc.c*pui8Dataconst uint32_t[256]unsigned long[256]ui32Temp >> 8ui32Temp >> 16ui32Temp >> 24ui16Cri8Oddui16Cri8Evenconst uint16_t[256]unsigned short[256]const uint8_t[256]unsigned char[256]g_pui32Crc32g_pui16Crc16g_pui8Crc8CCITTCRC32_ITER(crc,data)(((crc) >> 8) ^ g_pui32Crc32[(uint8_t)((crc & 0xFF) ^ (data))])CRC16_ITER(crc,data)(((crc) >> 8) ^ g_pui16Crc16[(uint8_t)((crc) ^ (data))])CRC8_ITER(crc,data)g_pui8Crc8CCITT[(uint8_t)((crc) ^ (data))]// Return the resulting CRC-32 value.// single step of the CRC.// If there is a final byte remaining in the input buffer, then perform a// Skip these input bytes.// Perform the CRC on these two bytes.// Read the two bytes.// the CRC.// If there are 16 bits left in the input buffer, then perform two steps of// Perform the CRC on these four bytes.// Read the next word.// four steps of the CRC to consume a word.// While there is at least a word remaining in the data buffer, perform// Read the next int16_t.// of data left, then perform two steps of the CRC to make it word-aligned.// If the data buffer is not word-aligned and there are at least two bytes// Skip this input byte.// Perform the CRC on this input byte.// of the CRC to make it 16 bit-aligned.// If the data buffer is not 16 bit-aligned, then perform a single step//! \return The accumulated CRC-32 of the input data.//! available at one time.//! is arriving via a serial link (for example) and is therefore not all//! Computing a CRC-32 in a running fashion is useful in cases where the data//!     ui32Crc ^= 0xFFFFFFFF;//!     ui32Crc = Crc32(ui32Crc, pui8Data3, ui32Len3);//!     ui32Crc = Crc32(ui32Crc, pui8Data2, ui32Len2);//!     ui32Crc = Crc32(0xFFFFFFFF, pui8Data1, ui32Len1);//! three pieces, use the following://! For example, to compute the CRC-32 of a block that has been split into//! the last returned value.//! been passed to the function, the final CRC-32 can be obtained by inverting//! back in as \b ui32Crc for the next portion of the data.  Once all data has//! first portion of the data, and then the returned value should be passed//! data is not available, then \b ui32Crc should be set to 0xFFFFFFFF for the//! \b ui32Crc should be set to 0xFFFFFFFF.  If, however, the entire block of//! once.  If the input buffer contains the entire block of data, then//! that is to have its CRC-32 computed does not need to be supplied all at//! CRC-32 is computed in a running fashion, meaning that the entire data block//! This function is used to calculate the CRC-32 of the input buffer.  The//! \param ui32Count is the number of bytes in the data buffer.//! \param pui8Data is a pointer to the data buffer.//! \param ui32Crc is the starting CRC-32 value.//! Calculates the CRC-32 of an array of bytes.// Return the resulting CRC-16 values.// Perform the third CRC on only the odd-index data bytes.// Perform the second CRC on only the even-index data bytes.// Perform the first CRC on all four data bytes.// Loop while there are more words in the data buffer.// Initialize the CRC values to zero.//! 5, etc.).//! uses only the odd-index bytes from the array (in other words, bytes 1, 3,//! bytes from the array (in other words, bytes 0, 2, 4, etc.), and the third//! first uses every byte from the array, the second uses only the even-index//! This function is used to calculate three CRC-16s of the input buffer; the//! CRC-16 values.//! \param pui16Crc3 is a pointer to an array in which to place the three//! \param pui32Data is a pointer to the data buffer.//! divided by 4).//! \param ui32WordLen is the length of the array in words (the number of bytes//! Calculates three CRC-16s of an array of words.// Calculate and return the CRC-16 of this array of words.//! \return The CRC-16 of the input data.//! the CRC-16 for a single block of data.//! This function is a wrapper around the running CRC-16 function, providing//! Calculates the CRC-16 of an array of words.// Return the resulting CRC-16 value.// of the CRC.// If there are two bytes left in the input buffer, then perform two steps// Read the next 16 bits.// the CRC to make it 16 bit-aligned.// If the data buffer is not 16 bit-aligned, then perform a single step of//! Computing a CRC-16 in a running fashion is useful in cases where the data//!     ui16Crc = Crc16(ui16Crc, pui8Data3, ui32Len3);//!     ui16Crc = Crc16(ui16Crc, pui8Data2, ui32Len2);//!     ui16Crc = Crc16(0, pui8Data1, ui32Len1);//! For example, to compute the CRC-16 of a block that has been split into//! \b ui16Crc for the next portion of the data.//! the data, and then the returned value should be passed back in as//! not available, then \b ui16Crc should be set to 0 for the first portion of//! \b ui16Crc should be set to 0.  If, however, the entire block of data is//! that is to have its CRC-16 computed does not need to be supplied all at//! CRC-16 is computed in a running fashion, meaning that the entire data block//! This function is used to calculate the CRC-16 of the input buffer.  The//! \param ui16Crc is the starting CRC-16 value.//! Calculates the CRC-16 of an array of bytes.// Return the resulting CRC-8-CCITT value.// Read the 16 bits.//! \return The CRC-8-CCITT of the input data.//! data is arriving via a serial link (for example) and is therefore not all//! Computing a CRC-8-CCITT in a running fashion is useful in cases where the//!     ui8Crc = Crc8CCITT(ui8Crc, pui8Data3, ui32Len3);//!     ui8Crc = Crc8CCITT(ui8Crc, pui8Data2, ui32Len2);//!     ui8Crc = Crc8CCITT(0, pui8Data1, ui32Len1);//! For example, to compute the CRC-8-CCITT of a block that has been split into//! as \b ui8Crc for the next portion of the data.//! portion of the data, and then the returned value should be passed back in//! data is not available, then \b ui8Crc should be set to 0 for the first//! data, then \b ui8Crc should be set to 0.  If, however, the entire block of//! supplied all at once.  If the input buffer contains the entire block of//! data block that is to have its CRC-8-CCITT computed does not need to be//! The CRC-8-CCITT is computed in a running fashion, meaning that the entire//! This function is used to calculate the CRC-8-CCITT of the input buffer.//! \param ui8Crc is the starting CRC-8-CCITT value.//! Calculates the CRC-8-CCITT of an array of bytes.// This macro executes one iteration of the CRC-32.// This macro executes one iteration of the CRC-16.// This macro executes one iteration of the CRC-8-CCITT.// CRC32 as used in Ethernet, MPEG-2, PNG, etc.).// x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1 (standard// The CRC-32 table for the polynomial C(x) = x^32 + x^26 + x^23 + x^22 +// CRC-16, also known as CRC-16-IBM and CRC-16-ANSI).// The CRC-16 table for the polynomial C(x) = x^16 + x^15 + x^2 + 1 (standard// The CRC table for the polynomial C(x) = x^8 + x^2 + x + 1 (CRC-8-CCITT).//! \addtogroup sw_crc_api// sw_crc.c - Software CRC functions./home/frost/Documents/ectf_2023/qlSpace/2023-ectf-insecure-example/car/lib/tivaware/driverlib/sysctl.cSysCtlAltClkConfig1074782520SysCtlClockOutConfig1074782536ui32Div != 0(ui32Config & ~(SYSCTL_CLKOUT_EN | SYSCTL_CLKOUT_DIS | SYSCTL_CLKOUT_SYSCLK | SYSCTL_CLKOUT_PIOSC | SYSCTL_CLKOUT_MOSC)) == 0SysCtlNMIClear1074782308SysCtlNMIStatusSysCtlVCOGeti32XtalIdxui32RSClkConfigui32PLLFreq0ui32PLLFreq1ui32Oscui32MIntui32MFracui32NDivui32QDivui32TempVCO1074782384ui32Crystal1984const uint32_t[27]unsigned long[27]1074782560107478256410475527936SysCtlVoltageEventClear1074782304SysCtlVoltageEventStatusSysCtlVoltageEventConfig1074782264SysCtlUSBPLLDisable1074782320SysCtlUSBPLLEnable4294950911~SYSCTL_RCC2_USBPWRDNSysCtlGPIOAHBDisable(ui32GPIOPeripheral == SYSCTL_PERIPH_GPIOA) || (ui32GPIOPeripheral == SYSCTL_PERIPH_GPIOB) || (ui32GPIOPeripheral == SYSCTL_PERIPH_GPIOC) || (ui32GPIOPeripheral == SYSCTL_PERIPH_GPIOD) || (ui32GPIOPeripheral == SYSCTL_PERIPH_GPIOE) || (ui32GPIOPeripheral == SYSCTL_PERIPH_GPIOF) || (ui32GPIOPeripheral == SYSCTL_PERIPH_GPIOG) || (ui32GPIOPeripheral == SYSCTL_PERIPH_GPIOH) || (ui32GPIOPeripheral == SYSCTL_PERIPH_GPIOJ)SysCtlGPIOAHBEnableSysCtlPWMClockGetSYSCTL_PWMDIV_1(SYSCTL_PWMDIV_1)1966080(SYSCTL_RCC_USEPWMDIV | SYSCTL_RCC_PWMDIV_M)HWREG(SYSCTL_DC1) & (SYSCTL_DC1_PWM0 | SYSCTL_DC1_PWM1)SysCtlPWMClockSet4293001215~(SYSCTL_RCC_USEPWMDIV | SYSCTL_RCC_PWMDIV_M)(ui32Config == SYSCTL_PWMDIV_1) || (ui32Config == SYSCTL_PWMDIV_2) || (ui32Config == SYSCTL_PWMDIV_4) || (ui32Config == SYSCTL_PWMDIV_8) || (ui32Config == SYSCTL_PWMDIV_16) || (ui32Config == SYSCTL_PWMDIV_32) || (ui32Config == SYSCTL_PWMDIV_64)SysCtlDeepSleepClockConfigSet10747825325284823043766484991~SYSCTL_DSLPCLKCFG_D_MSYSCTL_DSLP_OSC_MAINSYSCTL_DSLP_OSC_INT30SYSCTL_DSLP_OSC_EXT32SYSCTL_DSLP_OSC_INTSYSCTL_DSLP_PIOSC_PDSYSCTL_DSLP_MOSC_PDSysCtlDeepSleepClockSetSysCtlClockGetui32RCCui32RCC2ui32PLLui32Clkui32Maxui32PLL116000000400000016000000 / 430000pui32VCOFrequencyui32GPIOPeripheral1074782224800000005000000040000000250000003686420000000532676608(SYSCTL_RCC2_SYSDIV2_M |
                                               SYSCTL_RCC2_SYSDIV2LSB)(SYSCTL_RCC2_SYSDIV2_S - 1)125829120CLASS_IS_TM4C123SysCtlClockSetui32Delay(SYSCTL_RCC_USESYSDIV)~(SYSCTL_RCC_USESYSDIV)SYSCTL_MAIN_OSC_DIS~SYSCTL_RCC_MOSCDIS107478229610747822882032(SYSCTL_RCC_XTAL_M | SYSCTL_RCC_OSCSRC_M)4294965263~(SYSCTL_RCC_XTAL_M | SYSCTL_RCC_OSCSRC_M)2147483760(SYSCTL_RCC2_USERCC2 | SYSCTL_RCC2_OSCSRC2_M)2147483535~(SYSCTL_RCC2_USERCC2 | SYSCTL_RCC2_OSCSRC2_M)2147483696(SYSCTL_RCC2_USERCC2 | SYSCTL_RCC_OSCSRC_M)~SYSCTL_RCC_PWRDN~SYSCTL_RCC2_PWRDN2130023424130023425(SYSCTL_RCC_SYSDIV_M | SYSCTL_RCC_USESYSDIV |
                 SYSCTL_RCC_MOSCDIS)4164943870~(SYSCTL_RCC_SYSDIV_M | SYSCTL_RCC_USESYSDIV |
                 SYSCTL_RCC_MOSCDIS)(SYSCTL_RCC_SYSDIV_M | SYSCTL_RCC_USESYSDIV |
                             SYSCTL_RCC_MOSCDIS)(SYSCTL_RCC2_SYSDIV2_M)~(SYSCTL_RCC2_SYSDIV2_M)1077936128(SYSCTL_RCC2_DIV400 | SYSCTL_RCC2_SYSDIV2LSB)(SYSCTL_RCC2_DIV400)~(SYSCTL_RCC2_DIV400)1074782568(SYSCTL_RCC_BYPASS)4294965247~(SYSCTL_RCC_BYPASS)(SYSCTL_RCC2_BYPASS2)~(SYSCTL_RCC2_BYPASS2)SysCtlClockFreqSeti32Timeouti32VCOIdxui32MOSCCTLui32SysDivui32OscSelectSYSCTL_XTAL_16MHZSYSCTL_XTAL_25MHZSYSCTL_XTAL_5MHZSYSCTL_XTAL_10MHZ0x38SYSCTL_OSC_INTSysCtlXtalCfgToIndex(SYSCTL_XTAL_16MHZ)SYSCTL_OSC_INT302147483704SYSCTL_OSC_EXT32(SYSCTL_OSC_EXT32 & 0x38)SYSCTL_OSC_MAIN1664SysCtlXtalCfgToIndex(SYSCTL_XTAL_25MHZ)(SysCtlXtalCfgToIndex(SYSCTL_XTAL_25MHZ))576SysCtlXtalCfgToIndex(SYSCTL_XTAL_5MHZ)(SysCtlXtalCfgToIndex(SYSCTL_XTAL_5MHZ))503316481074782332(SYSCTL_MOSCCTL_OSCRNG | SYSCTL_MOSCCTL_PWRDN |
                        SYSCTL_MOSCCTL_NOXTAL)4294967267~(SYSCTL_MOSCCTL_OSCRNG | SYSCTL_MOSCCTL_PWRDN |
                        SYSCTL_MOSCCTL_NOXTAL)SysCtlXtalCfgToIndex(SYSCTL_XTAL_10MHZ)(SysCtlXtalCfgToIndex(SYSCTL_XTAL_10MHZ) -
                          (SysCtlXtalCfgToIndex(SYSCTL_XTAL_5MHZ)))ui32SysClocki32VCOIdx < MAX_VCO_ENTRIES14336SYSCTL_USE_OSCSYSCTL_USE_PLL107478240015729663251658240267387903535823359(SYSCTL_RSCLKCFG_PSYSDIV_M |
                            SYSCTL_RSCLKCFG_OSCSRC_M |
                            SYSCTL_RSCLKCFG_PLLSRC_M | SYSCTL_RSCLKCFG_USEPLL)3759143936~(SYSCTL_RSCLKCFG_PSYSDIV_M |
                            SYSCTL_RSCLKCFG_OSCSRC_M |
                            SYSCTL_RSCLKCFG_PLLSRC_M | SYSCTL_RSCLKCFG_USEPLL)MAX_VCO_ENTRIESconst uint32_t[3]unsigned long[3]const uint32_t[18][3]unsigned long[18][3]MAX_XTAL_ENTRIESconst uint32_t[2][18][3]unsigned long[2][18][3]const uint32_t(*)[18][3]unsigned long(*)[18][3]const uint32_t(*)[3]unsigned long(*)[3]1 << SYSCTL_RSCLKCFG_PSYSDIV_S(1 << SYSCTL_RSCLKCFG_PSYSDIV_S)4286578687~SYSCTL_PLLFREQ0_PLLPWR16776192285211648(SYSCTL_RSCLKCFG_OSYSDIV_M |
                             SYSCTL_RSCLKCFG_OSCSRC_M |
                             SYSCTL_RSCLKCFG_USEPLL)4009755647~(SYSCTL_RSCLKCFG_OSYSDIV_M |
                             SYSCTL_RSCLKCFG_OSCSRC_M |
                             SYSCTL_RSCLKCFG_USEPLL)(SYSCTL_RSCLKCFG_OSCSRC_M)~(SYSCTL_RSCLKCFG_OSCSRC_M)SysCtlResetBehaviorGet1074782680SysCtlResetBehaviorSetSysCtlPIOSCCalibrate2147483904(SYSCTL_PIOSCCAL_UTEN | SYSCTL_PIOSCCAL_UPDATE)10747825442147483775(SYSCTL_PIOSCCAL_UTEN | SYSCTL_PIOSCCAL_UT_M)1074782548SysCtlMOSCConfigSetSysCtlDelaySysCtlResetCauseClear1074782300SysCtlResetCauseGetSysCtlDeepSleepNVIC_SYS_CTRL0xE000ED103758157072NVIC_SYS_CTRL_SLEEPDEEP(NVIC_SYS_CTRL_SLEEPDEEP)~(NVIC_SYS_CTRL_SLEEPDEEP)SysCtlSleepSysCtlResetNVIC_APINT_SYSRESETREQ100270084SysCtlDeepSleepPowerSet1074782604SysCtlSleepPowerSet1074782600SysCtlLDODeepSleepGet1074782652SysCtlLDODeepSleepSet(ui32Voltage == SYSCTL_LDO_0_90V) || (ui32Voltage == SYSCTL_LDO_0_95V) || (ui32Voltage == SYSCTL_LDO_1_00V) || (ui32Voltage == SYSCTL_LDO_1_05V) || (ui32Voltage == SYSCTL_LDO_1_10V) || (ui32Voltage == SYSCTL_LDO_1_15V) || (ui32Voltage == SYSCTL_LDO_1_20V)SysCtlLDOSleepGet1074782644SysCtlLDOSleepSetSysCtlIntStatusSysCtlIntClearSysCtlIntDisable1074782292SysCtlIntEnableSysCtlIntUnregisterSysCtlIntRegisterSysCtlPeripheralClockGating(SYSCTL_RCC_ACG)4160749567~(SYSCTL_RCC_ACG)3758096383~SYSCTL_RSCLKCFG_ACGSysCtlPeripheralDeepSleepDisableSYSCTL_DCGCBASE + ((ui32Peripheral & 0xff00) >> 8)0x400fe800 + ((ui32Peripheral & 0xff00) >> 8)ui32Peripheral & 0xff((uint32_t)(0x400fe800 + ((ui32Peripheral & 0xff00) >> 8)) & 0xF0000000) | 0x02000000 | (((uint32_t)(0x400fe800 + ((ui32Peripheral & 0xff00) >> 8)) & 0x000FFFFF) << 5) | ((ui32Peripheral & 0xff) << 2)107478425640265318401048575_SysCtlPeripheralValid(ui32Peripheral)SysCtlPeripheralDeepSleepEnableSysCtlPeripheralSleepDisableSYSCTL_SCGCBASE + ((ui32Peripheral & 0xff00) >> 8)0x400fe700 + ((ui32Peripheral & 0xff00) >> 8)((uint32_t)(0x400fe700 + ((ui32Peripheral & 0xff00) >> 8)) & 0xF0000000) | 0x02000000 | (((uint32_t)(0x400fe700 + ((ui32Peripheral & 0xff00) >> 8)) & 0x000FFFFF) << 5) | ((ui32Peripheral & 0xff) << 2)1074784000SysCtlPeripheralSleepEnableSysCtlPeripheralDisableSYSCTL_RCGCBASE + ((ui32Peripheral & 0xff00) >> 8)0x400fe600 + ((ui32Peripheral & 0xff00) >> 8)((uint32_t)(0x400fe600 + ((ui32Peripheral & 0xff00) >> 8)) & 0xF0000000) | 0x02000000 | (((uint32_t)(0x400fe600 + ((ui32Peripheral & 0xff00) >> 8)) & 0x000FFFFF) << 5) | ((ui32Peripheral & 0xff) << 2)1074783744ui32Behaviorui32Causesui32Voltageui32PeripheralSysCtlPeripheralEnableSysCtlPeripheralResetvolatile uint_fast8_tui8DelaySYSCTL_SRBASE + ((ui32Peripheral & 0xff00) >> 8)0x400fe500 + ((ui32Peripheral & 0xff00) >> 8)((uint32_t)(0x400fe500 + ((ui32Peripheral & 0xff00) >> 8)) & 0xF0000000) | 0x02000000 | (((uint32_t)(0x400fe500 + ((ui32Peripheral & 0xff00) >> 8)) & 0x000FFFFF) << 5) | ((ui32Peripheral & 0xff) << 2)1074783488SysCtlPeripheralPowerOffSYSCTL_PCBASE + ((ui32Peripheral & 0xff00) >> 8)0x400fe900 + ((ui32Peripheral & 0xff00) >> 8)((uint32_t)(0x400fe900 + ((ui32Peripheral & 0xff00) >> 8)) & 0xF0000000) | 0x02000000 | (((uint32_t)(0x400fe900 + ((ui32Peripheral & 0xff00) >> 8)) & 0x000FFFFF) << 5) | ((ui32Peripheral & 0xff) << 2)1074784512SysCtlPeripheralPowerOnSysCtlPeripheralReadySYSCTL_PRBASE + ((ui32Peripheral & 0xff00) >> 8)0x400fea00 + ((ui32Peripheral & 0xff00) >> 8)((uint32_t)(0x400fea00 + ((ui32Peripheral & 0xff00) >> 8)) & 0xF0000000) | 0x02000000 | (((uint32_t)(0x400fea00 + ((ui32Peripheral & 0xff00) >> 8)) & 0x000FFFFF) << 5) | ((ui32Peripheral & 0xff) << 2)1074784768SysCtlPeripheralPresentSYSCTL_PPBASE + ((ui32Peripheral & 0xff00) >> 8)0x400fe300 + ((ui32Peripheral & 0xff00) >> 8)((uint32_t)(0x400fe300 + ((ui32Peripheral & 0xff00) >> 8)) & 0xF0000000) | 0x02000000 | (((uint32_t)(0x400fe300 + ((ui32Peripheral & 0xff00) >> 8)) & 0x000FFFFF) << 5) | ((ui32Peripheral & 0xff) << 2)1074782976SysCtlFlashSectorSizeGet1074782144FLASH_PP_MAINSS_S(1024)SysCtlFlashSizeGet10747822160x800SysCtlSRAMSizeGet1074782148_SysCtlFrequencyGetui32Resultui16F1ui16F2ui16PIntui16PFractui8Qui8N_SysCtlMemTimingGetconst struct <unnamed>[6]struct <unnamed>[6]sizeof(g_sXTALtoMEMTIM)sizeof(g_sXTALtoMEMTIM[0])sizeof(g_sXTALtoMEMTIM) / sizeof(g_sXTALtoMEMTIM[0])(sizeof(g_sXTALtoMEMTIM) / sizeof(g_sXTALtoMEMTIM[0]))ui32MemTimingui32Frequencyg_pui32VCOFrequencies160000000240000000g_sXTALtoMEMTIM0 << SYSCTL_MEMTIM0_FWS_S(0 << SYSCTL_MEMTIM0_FWS_S)20971840 << SYSCTL_MEMTIM0_EWS_S(0 << SYSCTL_MEMTIM0_EWS_S)3145776(SYSCTL_MEMTIM0_FBCHT_0_5 | SYSCTL_MEMTIM0_FBCE |
                 (0 << SYSCTL_MEMTIM0_FWS_S) |
                 SYSCTL_MEMTIM0_EBCHT_0_5 | SYSCTL_MEMTIM0_EBCE |
                 (0 << SYSCTL_MEMTIM0_EWS_S) |
                 SYSCTL_MEMTIM0_MB1)1 << SYSCTL_MEMTIM0_FWS_S(1 << SYSCTL_MEMTIM0_FWS_S)83887371 << SYSCTL_MEMTIM0_EWS_S(1 << SYSCTL_MEMTIM0_EWS_S)84542739502865(SYSCTL_MEMTIM0_FBCHT_1_5 | (1 << SYSCTL_MEMTIM0_FWS_S) |
                 SYSCTL_MEMTIM0_EBCHT_1_5 | (1 << SYSCTL_MEMTIM0_EWS_S) |
                 SYSCTL_MEMTIM0_MB1)600000002 << SYSCTL_MEMTIM0_FWS_S(2 << SYSCTL_MEMTIM0_FWS_S)194125831062 << SYSCTL_MEMTIM0_EWS_S(2 << SYSCTL_MEMTIM0_EWS_S)1271417813762770(SYSCTL_MEMTIM0_FBCHT_2 | (2 << SYSCTL_MEMTIM0_FWS_S) |
                 SYSCTL_MEMTIM0_EBCHT_2 | (2 << SYSCTL_MEMTIM0_EWS_S) |
                 SYSCTL_MEMTIM0_MB1)3 << SYSCTL_MEMTIM0_FWS_S(3 << SYSCTL_MEMTIM0_FWS_S)259167774751966083 << SYSCTL_MEMTIM0_EWS_S(3 << SYSCTL_MEMTIM0_EWS_S)1697408318022675(SYSCTL_MEMTIM0_FBCHT_2_5 | (3 << SYSCTL_MEMTIM0_FWS_S) |
                 SYSCTL_MEMTIM0_EBCHT_2_5 | (3 << SYSCTL_MEMTIM0_EWS_S) |
                 SYSCTL_MEMTIM0_MB1)1000000004 << SYSCTL_MEMTIM0_FWS_S(4 << SYSCTL_MEMTIM0_FWS_S)20971520209718444 << SYSCTL_MEMTIM0_EWS_S(4 << SYSCTL_MEMTIM0_EWS_S)2123398822282580(SYSCTL_MEMTIM0_FBCHT_3 | (4 << SYSCTL_MEMTIM0_FWS_S) |
                  SYSCTL_MEMTIM0_EBCHT_3 | (4 << SYSCTL_MEMTIM0_EWS_S) |
                  SYSCTL_MEMTIM0_MB1)1200000003845 << SYSCTL_MEMTIM0_FWS_S(5 << SYSCTL_MEMTIM0_FWS_S)38925165824251662135 << SYSCTL_MEMTIM0_EWS_S(5 << SYSCTL_MEMTIM0_EWS_S)2549389326542485(SYSCTL_MEMTIM0_FBCHT_3_5 | (5 << SYSCTL_MEMTIM0_FWS_S) |
                  SYSCTL_MEMTIM0_EBCHT_3_5 | (5 << SYSCTL_MEMTIM0_EWS_S) |
                  SYSCTL_MEMTIM0_MB1)g_pppui32XTALtoVCO412613358544608408304g_pui32Xtals1000000184320020000002457600357954536864004096000491520050000005120000600000061440007372800800000081920001000000012000000122880001356000014318180163840001800000024000000SYSCTL_PRBASE0x400fea00SYSCTL_PCBASE0x400fe900SYSCTL_DCGCBASE0x400fe800SYSCTL_SCGCBASE0x400fe700SYSCTL_RCGCBASE0x400fe600SYSCTL_SRBASE0x400fe500SYSCTL_PPBASE0x400fe300PLL_Q_TO_REG(q)((uint32_t)(q - 1) << SYSCTL_PLLFREQ1_Q_S)PLL_N_TO_REG(n)((uint32_t)(n - 1) << SYSCTL_PLLFREQ1_N_S)PLL_M_TO_REG(mi,mf)((uint32_t)mi | (uint32_t)(mf << SYSCTL_PLLFREQ0_MFRAC_S))SysCtlXtalCfgToIndex(a)((a & 0x7c0) >> 6)defined(ewarm) || defined(DOXYGEN)// Set the requested configuration and divisor.//! using to determine which interrupt sources are available.//! Tiva part in use.  Please consult the data sheet for the part you are//! \note The availability of the alternate peripheral clock varies with the//! SysCtlAltClkConfig(SYSCTL_ALTCLK_RTCOSC);//! // Select the Hibernate module RTC clock as the alternate clock source.//! source.//! \b Example: Select the Hibernate module RTC clock as the alternate clock//!      the alternate clock source.//! - \b SYSCTL_ALTCLK_LFIOSC - use the low-frequency internal oscillator as//!      alternate clock source.//! - \b SYSCTL_ALTCLK_RTCOSC - use the Hibernate module RTC clock as the//!      source (default).//! - \b SYSCTL_ALTCLK_PIOSC - use the PIOSC as the alternate clock//! source using one of the following values://! input clock.  The \e ui32Config parameter value provides the clock input//! to peripherals that support using the alternate peripheral clock as an//! peripheral clock is used to provide a known clock in all operating modes//! This function configures the alternate peripheral clock.  The alternate//! peripheral clock.//! \param ui32Config holds the configuration options for the alternate//! Configures the alternate peripheral clock source.//! determine which interrupt sources are available.//! in use.  Please consult the data sheet for the part you are using to//! \note The availability of the DIVSCLK output varies with the Tiva part//! SysCtlClockOutConfig(SYSCTL_DIVSCLK_EN | SYSCTL_DIVSCLK_SRC_PIOSC, 4);//! // Enable the PIOSC divided by 4 as the DIVSCLK output.//! \b Example: Enable the PIOSC divided by 4 as the DIVSCLK output.//! - \b SYSCTL_CLKOUT_MOSC - use the MOSC as the source.//! - \b SYSCTL_CLKOUT_PIOSC - use the PIOSC as the source.//! - \b SYSCTL_CLKOUT_SYSCLK - use the current system clock as the//! The next group of settings selects the source for the DIVSCLK.//! - \b SYSCTL_CLKOUT_DIS - disable the DIVSCLK output (default).//! - \b SYSCTL_CLKOUT_EN - enable the DIVSCLK output.//! The first setting allows the output to be enabled or disabled.//! the DIVSCLK output based on the following settings://! valid range of 1-256.  The \e ui32Config parameter configures//! parameter specifies the divider for the selected clock source and has a//! the clock output and provides an output divider value.  The \e ui32Div//! This function selects the source for the DIVSCLK, enables or disables//! \param ui32Div is the divisor for the clock selected in the \e ui32Config//! disabling the clock output on the DIVSCLK pin.//! \param ui32Config holds the configuration options including enabling or//! Configures and enables or disables the clock output on the DIVSCLK pin.//! which interrupt sources are available.//! use.  Please consult the data sheet for the part you are using to determine//! \note The availability of the NMI status varies with the Tiva part in//! SysCtlNMIClear(SysCtlNMIStatus());//! // Clear all the current NMI sources.//! \b Example: Clear all current NMI status flags.//! - \b SYSCTL_NMI_EXTERNAL an external NMI pin asserted.//! - \b SYSCTL_NMI_POWER a power event occurred.//! - \b SYSCTL_NMI_WDT1 watchdog 1 generated a timeout.//! - \b SYSCTL_NMI_WDT0 watchdog 0 generated a timeout.//! - \b SYSCTL_NMI_TAMPER a tamper event has been detected.//!   start.//! - \b SYSCTL_NMI_MOSCFAIL the main oscillator is not present or did not//! of the following values://! parameter.  The valid values for the \e ui32Ints parameter are a logical OR//! This function clears the current NMI status specified in the \e ui32Ints//! \param ui32Ints is a bit mask of the non-maskable interrupt sources.//! Clears NMI sources.//! \return The current NMI status.//! values for the \e ui32Ints parameter are a logical OR of the following//! This function returns the NMI status for the system controller.  The valid//! Returns the current NMI status.// Calculate the VCO at the output of the PLL// MINT, MFRAC, N and Q values of the PLL// Read the PLLFREQ0 and PLLFREQ1 registers to get information on the// Get the value of the crystal frequency based on the index// Get the index of the crystal from the ui32Config parameter.// Return error if PLL is not used.// Check if PLL is used.// Read the RSCLKCFG register to determine if PLL is being used.// Return error if TM4C123.// Check if TM4C123 device is being used. should not use this function.//! \b false if the device is not TM4C129x or the PLL is not used//! \return \b true if the PLL is configured correctly and a VCO is valid or//! applied//! This function calculates the VCO of the PLL before the system divider is//! value of the VCO computed.//! \param pui32VCOFrequency is a pointer to the storage location which holds //! such as \b SYSCTL_XTAL_25MHZ.//! \param ui32Crystal holds the crystal value definition from \b sysctl.h//! Gets the effective VCO frequency.// Clear the requested voltage events.//! \note The availability of voltage event status varies with the//! SysCtlVoltageEventClear(SysCtlVoltageEventStatus());//! // Clear all the current voltage events.//! \b Example: Clear the current voltage event status.//! - \b SYSCTL_VESTAT_VDDABOR a brown-out event occurred on the VDDA rail.//! - \b SYSCTL_VESTAT_VDDBOR a brown-out event occurred on the VDD rail.//! a logical OR of the following values://! specified in the \e ui32Status parameter.  The \e ui32Status value must be//! This function clears the current voltage events status for the values//! \param ui32Status is a bit mask of the voltage events to clear.//! Clears the voltage event status.// Return the current voltage event status.//! \note The availability of voltage events varies with the Tiva part//! \return The current voltage event status.//! SysCtlVoltageEventClear(ui32VoltageEvents);//! ui32VoltageEvents = SysCtlVoltageEventStatus();//! // Read the current voltage event status.//! uint32_t ui32VoltageEvents;//! status must be cleared by calling SysCtlVoltageEventClear().//! Because voltage events are not cleared due to a reset, the voltage event//! SysCtlVoltageEventClear() to clear the current voltage event status.//! The values returned from this function can be passed to the//! This function returns the voltage event status for the system controller.//! Returns the voltage event status.// Set the requested events.//!                          SYSCTL_VEVENT_VDDBO_RST);//! SysCtlVoltageEventConfig(SYSCTL_VEVENT_VDDABO_INT |//! // Trigger an interrupt on a VDDA brown out and a reset on a VDD brown out.//! SysCtlResetBehaviorSet(SYSCTL_ONRST_BOR_POR);//! // of reset is specified by this call.//! // the SysCtlVoltageEventConfig() call is triggering a reset so the type//! // Configure the BOR rest to trigger a full POR.  This is needed because//! brown out, an NMI on a VDDC brown out and a reset on a VDD brown out.//! \b Example: Configure the voltage events to trigger an interrupt on a VDDA//!      function.//!      \b SYSCTL_ONRST_BOR_* setting passed into the SysCtlResetBehaviorSet()//!      occurs.  The type of reset that is generated is controller by the//! - \b SYSCTL_VEVENT_VDDBO_RST - A reset is generated when a VDD brown out//!      occurs.//! - \b SYSCTL_VEVENT_VDDBO_NMI - An NMI is generated when a VDD brown out//!      VDD brown out occurs.//! - \b SYSCTL_VEVENT_VDDBO_INT - A system interrupt is generated when a//!      brown out.//! - \b SYSCTL_VEVENT_VDDBO_NONE - There is no action taken on a VDD//! The response to a brown out on the VDD rail is set by using one of the//! - \b SYSCTL_VEVENT_VDDABO_RST - A reset is generated when a VDDA brown out//! - \b SYSCTL_VEVENT_VDDABO_NMI - An NMI is generated when a VDDA brown out//!      VDDA brown out occurs.//! - \b SYSCTL_VEVENT_VDDABO_INT - A system interrupt is generated when a//! - \b SYSCTL_VEVENT_VDDABO_NONE - There is no action taken on a VDDA//! The response to a brown out on the VDDA rail is set by using one of the//! voltage events and is a combination of the \b SYSCTL_VEVENT_* values.//! levels.  The \e ui32Config parameter provides the configuration for the//! These events are triggered when the voltage rails drop below certain//! This function configures the response to voltage-related events.//! \param ui32Config holds the configuration options for the voltage events.//! Configures the response to system voltage events.// Turn off the USB PLL.//! \note This function should only be called on TM4C123 devices.//! layer no longer functions.//! physical layer.  The USB registers are still accessible, but the physical//! This function disables the USB controller's PLL, which is used by its//! Powers down the USB PLL.// Turn on the USB PLL.//! devices.//! physical layer.  This call is necessary before connecting to any external//! This function enables the USB controller's PLL, which is used by its//! Powers up the USB PLL.// Disable this GPIO for AHB access.//! available on AHB.//! access to these GPIO ports. On some devices, all GPIO ports are only//! present on the AHB.  Disabling AHB access to these ports will disable//! \note Some devices allow disabling AHB access to GPIO ports that are only//! \b SYSCTL_PERIPH_GPIOG, \b SYSCTL_PERIPH_GPIOH, or \b SYSCTL_PERIPH_GPIOJ.//! \b SYSCTL_PERIPH_GPIOD, \b SYSCTL_PERIPH_GPIOE, \b SYSCTL_PERIPH_GPIOF,//! \b SYSCTL_PERIPH_GPIOA, \b SYSCTL_PERIPH_GPIOB, \b SYSCTL_PERIPH_GPIOC,//! The \b ui32GPIOPeripheral argument must be only one of the following//! from the legacy Advanced Peripheral Bus (APB).//! Advanced Host Bus (AHB).  Once disabled, the GPIO peripheral is accessed//! This function disables the specified GPIO peripheral for access from the//! \param ui32GPIOPeripheral is the GPIO peripheral to disable.//! Disables access to a GPIO peripheral via the AHB.// Enable this GPIO for AHB access.//! \note On some devices, all GPIO ports are only available on AHB.//! The \e ui32GPIOPeripheral argument must be only one of the following//! address for GPIO functions, use \b GPIO_PORTA_AHB_BASE instead.//! functions.  For example, instead of using \b GPIO_PORTA_BASE as the base//! the \b _AHB_BASE form of the base address should be used for GPIO//! Peripheral Bus (APB).  When a GPIO peripheral is enabled for AHB access,//! accessed from the Advanced Host Bus (AHB) instead of the legacy Advanced//! This function is used to enable the specified GPIO peripheral to be//! \param ui32GPIOPeripheral is the GPIO peripheral to enable.//! Enables access to a GPIO peripheral via the AHB.// SYSCTL_PWMDIV_1 is returned in all cases where the divider is disabled.// Check that there is a PWM block on this part.//! other TM4C devices, the PWMClockGet() function should be used.//! \note This function should only be used with TM4C123 devices.  For//! \b SYSCTL_PWMDIV_64.//! \b SYSCTL_PWMDIV_8, \b SYSCTL_PWMDIV_16, \b SYSCTL_PWMDIV_32, or//! \b SYSCTL_PWMDIV_1, \b SYSCTL_PWMDIV_2, \b SYSCTL_PWMDIV_4,// Set the PWM clock configuration into the run-mode clock configuration//! configured by SysCtlClockSet().//! \note The clocking of the PWM is dependent on the system clock rate as//! other TM4C devices, the PWMClockSet() function should be used.//! generate PWM signals; its rate forms the basis for all PWM signals.//! as a ratio of the processor clock.  This clock is used by the PWM module to//! This function configures the rate of the clock provided to the PWM module// Update the deep-sleep clock configuration.// Set the PIOSC power down bit.// The zero value uses the PIOSC as the clock source.// Choose the low frequency oscillator.// Choose the main external oscillator.// compatibility.// SysCtlDeepSleepClockSet() function so that there is some backwards// Set the clock source selection based on the defines used for// Initialize the value with the divider.// Set the deep-sleep clock configuration.//! range for the clock divider.//! desired configuration options are available and to determine the valid//! the data sheet for the device you are using to determine whether the//! configuration values vary with the Tiva device in use.  Please consult//! \note The availability of deep-sleep clocking configuration and the//! (based on other configuration settings).//! not powered down if it is required for operation while in deep-sleep//! specifying \b SYSCTL_DSLP_MOSC_PD.  The main oscillator is//! The main oscillator can be powered down in deep-sleep mode by//! specifying \b SYSCTL_DSLP_PIOSC_PD.  The precision internal oscillator is//! The precision internal oscillator can be powered down in deep-sleep mode by//! hibernation module is enabled.//! available on devices with the hibernation module, and then only when the//! or \b SYSCTL_DSLP_OSC_EXT32.  The \b SYSCTL_DSLP_OSC_EXT32 option is only//! \b SYSCTL_DSLP_OSC_MAIN, \b SYSCTL_DSLP_OSC_INT, \b SYSCTL_DSLP_OSC_INT30,//! The oscillator source is chosen from one of the following values://! Tiva devices that support deep-sleep mode.//! replaces the SysCtlDeepSleepClockSet() function and can be used on//! all Tiva microcontrollers support this full range.  This function//! valid values for the \e ui32Div parameter range from 1 to 1024, however not//! \e ui32Div parameter sets the clock divider used in deep-sleep mode.  The//! mode.  The \e ui32Config parameter selects the oscillator and the//! This function configures the clocking of the device while in deep-sleep//! in deep-sleep mode.//! \param ui32Config is the configuration of the device clocking while//! \param ui32Div is the clock divider when in deep-sleep mode.//! Sets the clock configuration of the device while in deep-sleep mode.//! using to determine whether this support is available.//! \note The availability of deep-sleep clocking configuration varies with the//! other devices use the SysCtlDeepSleepClockConfigSet() function.//! \note This function should only be called on TM4C123 devices.  For//! (based on other configuration settings.)//! module has been enabled.//! devices with the hibernation module, and then only when the hibernation//! or \b SYSCTL_DSLP_OSC_EXT32.  \b SYSCTL_OSC_EXT32 is only available on//! \b SYSCTL_DSLP_DIV_64.//! \b SYSCTL_DSLP_DIV_1, \b SYSCTL_DSLP_DIV_2, \b SYSCTL_DSLP_DIV_3, ...//! The system clock divider is chosen from one of the following values://! The \e ui32Config parameter is the logical OR of the following values://! configured with this function.//! mode.  The oscillator to be used and the system clock divider are//! while in deep-sleep mode.//! \param ui32Config is the required configuration of the device clocking//! Sets the clocking of the device while in deep-sleep mode.// Return the computed clock rate.// Limit the maximum clock to the maximum clock frequency.// Adjust the clock rate by the system clock divider.// See if the system divider is being used.// Calculate the maximum system frequency.// using the PLL, but in some cases it does not read as being enabled.// Force the system divider to be enabled.  It is always used when// integer part and a fractional part.// Multiply the clock by the multiplier, which is split into an// Divide the input clock by the dividers.// TM4C123 device is "(xtal * m) / ((q + 1) * (n + 1))".// Read the two PLL frequency registers.  The formula for a// See if the PLL is being used.// Default the maximum frequency to the maximum 32-bit unsigned value.// clock rate).// An unknown setting, so return a zero clock (that is, an unknown// The 32.768-KHz clock from the hibernate module is the source clock.// The internal 30-KHz oscillator has an accuracy of +/- 30%.// The internal 30-KHz oscillator is the source clock.// The internal oscillator on all devices is 16 MHz.// The internal oscillator divided by four is the source clock.// The internal oscillator is the source clock.// the crystal setting field.// The main oscillator is the clock source.  Determine its rate from// Get the base clock rate.// Read RCC and RCC2.// This function is only valid on TM4C123 devices.//! \return The processor clock rate for TM4C123 devices only.//! clock frequency.//! devices, the return value from SysCtlClockFreqSet() indicates the system//! \note This function can only be called on TM4C123 devices.  For TM4C129//! modified to directly return the correct system clock rate.//! supported crystal frequencies.  In the latter case, this function should be//! directly clocked from a crystal (or a clock source) that is not one of the//! been called to configure the clocking of the device, or if the device is//! \note This cannot return accurate results if SysCtlClockSet() has not//! clocking, see the device data sheet for details).//! PWM, which has its own clock divider; other peripherals may have different//! also the clock rate of the peripheral modules (with the exception of//! This function determines the clock rate of the processor clock, which is//! Gets the processor clock rate.// Delay for a little bit so that the system divider takes effect.// Write the final RCC value.// Enable use of the PLL.// Wait until the PLL has locked.// See if the PLL output is being used to clock the system.// oscillators.  This value is not written immediately.// Set the requested system divider and disable the appropriate// Write the new RCC value.// Clear the PLL lock interrupt.// Set the PLL configuration.// special encoding within ui32Config to avoid the overlap.// field in RCC2 overlaps the XTAL field in RCC, the OSCSRC field has a// Set the new crystal value and oscillator source.  Because the OSCSRC2// it and return.// If the main oscillator failed to start up then do not switch to// Timeout using the legacy delay value.// set when waiting below.// Clear the MOSC power up raw interrupt status to be sure it is not// requested oscillators.// previously enabled oscillators must be enabled along with the newly// Make sure that the required oscillators are enabled.  For now, the// See if the oscillator needs to be enabled.// Bypass the PLL and system clock dividers for now.// Get the current value of the RCC and RCC2 registers.//! instead of completing as soon as PLL lock is achieved.//! PLL lock interrupt, this function delays until its timeout has occurred//! system control interrupt is in place, and it responds to and clears the//! determine when the PLL has locked.  If an interrupt handler for the//! \b SYSCTL_USE_PLL), this function polls the PLL lock interrupt to//! \note If selecting the PLL as the system clock source (that is, via//! all other devices use the SysCtlClockFreqSet() function.//! crystal with one of the \b SYSCTL_XTAL_xxx values.//! \b SYSCTL_USE_PLL \b | \b SYSCTL_OSC_MAIN, and select the appropriate//! \b SYSCTL_OSC_MAIN.  To clock the system from the PLL, use//! system from the main oscillator, use \b SYSCTL_USE_OSC \b |//! oscillator), use \b SYSCTL_USE_OSC \b | \b SYSCTL_OSC_MAIN.  To clock the//! To clock the system from an external source (such as an external crystal//! device is prevented by the hardware.//! source.  Note that attempts to disable the oscillator used to clock the//! The external oscillator must be enabled in order to use an external clock//! \b SYSCTL_INT_OSC_DIS and \b SYSCTL_MAIN_OSC_DIS flags, respectively.//! The internal and main oscillators are disabled with the//! hibernate module has been enabled.//! available on devices with the hibernate module, and then only when the//! \b SYSCTL_OSC_INT30, or \b SYSCTL_OSC_EXT32.  \b SYSCTL_OSC_EXT32 is only//! \b SYSCTL_OSC_MAIN, \b SYSCTL_OSC_INT, \b SYSCTL_OSC_INT4,//! The oscillator source is chosen with one of the following values://! Values below \b SYSCTL_XTAL_5MHZ are not valid when the PLL is in//! \b SYSCTL_XTAL_20MHZ, \b SYSCTL_XTAL_24MHZ, or \b SYSCTL_XTAL_25MHz.//! \b SYSCTL_XTAL_16MHZ, \b SYSCTL_XTAL_16_3MHZ, \b SYSCTL_XTAL_18MHZ,//! \b SYSCTL_XTAL_12_2MHZ, \b SYSCTL_XTAL_13_5MHZ, \b SYSCTL_XTAL_14_3MHZ,//! \b SYSCTL_XTAL_8_19MHZ, \b SYSCTL_XTAL_10MHZ, \b SYSCTL_XTAL_12MHZ,//! \b SYSCTL_XTAL_6_14MHZ, \b SYSCTL_XTAL_7_37MHZ, \b SYSCTL_XTAL_8MHZ,//! \b SYSCTL_XTAL_5MHZ, \b SYSCTL_XTAL_5_12MHZ, \b SYSCTL_XTAL_6MHZ,//! \b SYSCTL_XTAL_4MHZ, \b SYSCTL_XTAL_4_09MHZ, \b SYSCTL_XTAL_4_91MHZ,//! The external crystal frequency is chosen with one of the following values://! \b SYSCTL_USE_OSC.//! The use of the PLL is chosen with either \b SYSCTL_USE_PLL or//! \b SYSCTL_SYSDIV_3, ... \b SYSCTL_SYSDIV_63_5, \b SYSCTL_SYSDIV_64.//! \b SYSCTL_SYSDIV_1, \b SYSCTL_SYSDIV_2, \b SYSCTL_SYSDIV_2_5,//! The system clock divider is chosen with one of the following values://! many of which are grouped into sets where only one can be chosen.//! The \e ui32Config parameter is the logical OR of several different values,//! divider are all configured with this function.//! frequency, oscillator to be used, use of the PLL, and the system clock//! This function configures the clocking of the device.  The input crystal//! \param ui32Config is the required configuration of the device clocking.//! Sets the clocking of the device.// Finally change the OSCSRC back to PIOSC// Set the new clock configuration.// Update the memory timings.// Set the new system clock values.// Set the memory timing values for the new system clock.// Calculate the system clock.// be n-1.// set the value in the register which requires the value to// If the system divisor is not already zero, subtract one to// frequency.// Calculate the System divider based on the requested// If zero given as the system clock then default to divide by 1.// Clear the old PLL divider and source in case it was set.// Make sure that the PLL is powered down since it is not being used.// Set the Flash and EEPROM timing values for PIOSC.// If the loop above did not timeout then switch over to the PLL// Power up the PLL.// Trigger the PLL to lock to the new frequency.// Check if the PLL is already powered up.// Set the Flash and EEPROM timing values.// Calculate the actual system clock as PSYSDIV is always div-by 2.// the power state of the main PLL.// Set the M, N and Q values provided from the table and preserve// Set the oscillator source.// the closest to the requested frequency without going over.// Calculate the System divider such that we get a frequency that is// The table starts at 5 MHz so modify the index to match this.// Update clock configuration to switch back to PIOSC.// Update the memory timings to match running from PIOSC.// up to 25MHz.// this could be a switch to PIOSC or possibly to MOSC which can be// Set the memory timings for the maximum external frequency since// Check that the VCO index is not out of bounds.// Get the VCO index out of the ui32Config parameter.// ui32Config must be SYSCTL_OSC_MAIN or SYSCTL_OSC_INT.// Check if the running with the PLL enabled was requested.// indicated.// This was an invalid request because no oscillator source was// Increase the drive strength for MOSC of 10 MHz and above.// present setting.// Clear MOSC power down, high oscillator range setting, and no crystal// Set the PLL source select to MOSC.// from 5MHz to 25MHz.// because the PLL tables in the g_pppui32XTALtoVCO structure range// Bounds check the source frequency for the main oscillator.  The is// Use the RTC frequency.// Use the nominal frequency for the low frequency oscillator.// Force the crystal index to the value for 16-MHz.// crystal select.// Use the nominal frequency for the PIOSC oscillator and set the// Determine which non-PLL source was selected.// TM4C123 devices should not use this function.//! value could not be changed due to a parameter error or PLL lock failure.//! \return The actual configured system clock frequency in Hz or zero if the//! devices use the SysCtlClockSet() function.//! \note This function cannot be used with TM4C123 devices.  For TM4C123//!                    40000000);//! SysCtlClockFreqSet(SYSCTL_OSC_INT | SYSCTL_USE_PLL | SYSCTL_CFG_VCO_320,//! setting using the 16-MHz internal oscillator.//! Example: Configure the system clocking to be 40 MHz with a 320-MHz PLL//! - \b SYSCTL_CFG_VCO_320 to set the PLL VCO output to 320-MHz//! - \b SYSCTL_CFG_VCO_480 to set the PLL VCO output to 480-MHz//! The PLL VCO frequency is chosen with one of the the following values://! system clock.//! - \b SYSCTL_USE_OSC is used to choose one of the oscillators as the//! - \b SYSCTL_USE_PLL is used to select the PLL output as the system clock.//! The system clock source is chosen with one of the following values://! This option is only available on devices that include the hibernation//! - \b SYSCTL_OSC_EXT32 to use the hibernate modules 32.786-kHz oscillator.//! - \b SYSCTL_OSC_INT30 to use the internal low frequency oscillator.//! - \b SYSCTL_OSC_INT to use the 16-MHz precision internal oscillator.//! - \b SYSCTL_OSC_MAIN to use an external crystal or oscillator.//! \b SYSCTL_XTAL_25MHz.//! \b SYSCTL_XTAL_18MHZ, \b SYSCTL_XTAL_20MHZ, \b SYSCTL_XTAL_24MHZ, or//! \b SYSCTL_XTAL_10MHZ, \b SYSCTL_XTAL_12MHZ, \b SYSCTL_XTAL_16MHZ,//! \b SYSCTL_XTAL_5MHZ, \b SYSCTL_XTAL_6MHZ, \b SYSCTL_XTAL_8MHZ,//! set by using one of the following values://! If the application is using an external crystal then the frequency is//! requested frequency.//! function returns the current system frequency which may not match the//! are grouped into sets where only one of the set can be chosen.  This//! defines that are a logical OR of several different values, many of which//! parameter provides the remaining configuration options using a set of//! frequency that is lower than the requested frequency.  The \e ui32Config//! cannot exactly match the requested frequency, it picks the closest//! the values provided in the \e ui32Config parameter.  If this function//! system clock frequency, and this function then attempts to match this using//! parameter.  The caller sets the \e ui32SysClock parameter to request the//! of one of the fixed PLL VCO settings provided in the \e ui32Config//! function configures the system frequency to the closest available divisor//! the system clock divider are all configured with this function.  This//! input frequency, oscillator source, whether or not to enable the PLL, and//! This function configures the main system clocking for the device.  The//! \param ui32SysClock is the requested processor frequency.//! Configures the system clock.//! \return The reset behaviors for all configurable resets.//! \note This function should only be used with Flurry-class devices.//! of the SysCtlResetBehaviorSet() function.//! that are described in the documentation for the \e ui32Behavior parameter//! occurs.  The value returned is a logical OR combination of the valid values//! This function returns the types of resets issued when a configurable reset//! Returns the current types of reset issued due to reset events.//! \note This function cannot be used with TM4C123 devices.//! SysCtlResetBehaviorSet(SYSCTL_ONRST_WDOG0_POR | SYSCTL_ONRST_BOR_SYS);//! default behaviors.//! to trigger a system reset while leaving the remaining resets with their//! \b Example: Set Watchdog 0 reset to trigger a POR and a brown-out reset//!   system reset.//! - \b SYSCTL_ONRST_EXT_SYS configures an external pin reset to perform a//!   full POR.//! - \b SYSCTL_ONRST_EXT_POR configures an external pin reset to perform a//!   reset.//! - \b SYSCTL_ONRST_BOR_SYS configures a brown-out reset to perform a system//!   POR.//! - \b SYSCTL_ONRST_BOR_POR configures a brown-out reset to perform a full//! - \b SYSCTL_ONRST_WDOG1_SYS configures a Watchdog 1 reset to perform a//! - \b SYSCTL_ONRST_WDOG1_POR configures a Watchdog 1 reset to perform a full//! - \b SYSCTL_ONRST_WDOG0_SYS configures a Watchdog 0 reset to perform a//! - \b SYSCTL_ONRST_WDOG0_POR configures a Watchdog 0 reset to perform a full//! Valid values are logical combinations of the following://! can be selected for each reset cause.//! remains configured for its default behavior. Either POR or system reset//! of the values defined below.  Any reset option that is not specifically set//! reset behaviors can be configured with a single call using the logical OR//! information on the differences between a full POR and a system reset.  All//! system reset or a full POR sequence.  See the data sheet for more//! a brown out and the external RSTn pin.  The valid actions are either a//! event occurs.  The reset events that are configurable are: Watchdog 0 or 1,//! This function sets the types of reset issued when a configurable reset//! configurable reset events.//! \param ui32Behavior specifies the types of resets for each of the//! Sets the type of reset issued due to certain reset events.// The calibration was successful.// If the automatic calibration failed, return an error.// Wait for the automatic cal    Z    